<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Search | </title>
    
    <base target="_self">
    <meta name="description" content="      ... " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" value="notranslate">
    <link rel="icon"  type="image/x-icon" href="favicon.ico">
<!--
    Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with the License. A copy of the License is located at http://aws.amazon.com/apache2.0/ or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This site also includes third-party software subject to various copyrights. The licenses for these third party components are referenced in the NOTICE file.
-->

    <!-- FontAwesome -->
   <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
    <!-- jQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.js"></script>
    <!-- Navgoco -->
    <script type="text/javascript" src="assets/js/jquery.navgoco.min.js"></script>
    <!-- Bootstrap -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <!-- TOC generator-->
    <script src="assets/js/toc.js"></script>
    <!-- Anchor JS -->
    

    <script>
        $( document ).ready(function() {
            $("#docnavsidebar").navgoco({
                caretHtml: '',
                accordion: false,
                openClass: 'open', // open
                save: true,
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 300,
                    easing: 'swing'
                }
            });
            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#docnavsidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#docnavsidebar").navgoco('toggle', true);
            });
        });

    </script>
    <script src="assets/js/customscripts.js"></script>

    <script>
        $(document).ready(function() {
            $('[data-toggle=offcanvas]').click(function() {
                $('.row-offcanvas').toggleClass('active');
            });
        });
    </script>


    <!--Bootstrap -->

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <style>
        ul#markdown-toc::before  {
        content: "Table of Contents"
         }
    </style>

</head>
<body class="default">
<div class="page-container">


    <!-- Top Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container topnavlinks">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="fa fa-bars fa-2x"></span>
                </button>
                <button type="button" class="navbar-toggle toggle-sidebar-button"  data-toggle="offcanvas" data-target=".sidebar-nav">
                    <span class="sidebarToggle fa fa-columns fa-2x"></span>
                </button>

                <a class="navbar-brand noCrossRef" href="https://developer.amazon.com/">
                    <img class="navbar-logo" src="amazonlogowhite.png"/>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-left">

                    <!-- single item nav items appear here -->

                    
                    
                    
                    
                    <li><a href="index.html">Documentation Home</a></li>
                    
                    
                    
                    
                    

                    <!-- drop-down nav items appear here -->

                    


                </ul>

                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <!--start search -->
                        <!--
                        <div id="search-demo-container">
                            <form action="search.html" method="get">
                                <input type="text" id="search-input" placeholder="Global Search ..." name="query">
                            </form>
                        </div>
                        -->
                        <!-- end search-->
                    </li>
                </ul>
            </div>

        </div>


        <!-- /.container -->
    </nav>


<div class="container">
        <div class="row row-offcanvas row-offcanvas-left">

            <!-- sidebar -->
            <div class="col-xs-6 col-sm-3 sidebar-offcanvas" id="sidebar" role="navigation">

                


<div class="mydocsidebar">
<div class="sidebar-inner">
<!-- search bar - uses Lunr.js  -->

<div class="sidebarSearchBar">
<form action="search-taglist.html" method="get">
  <div class="input-group search">
    <input type="text" id="search-box" name="query" class="form-control" placeholder="Product Search ...">
    <div class="input-group-btn">
      <button class="btn btn-default" type="submit" value="search">
        <i class="glyphicon glyphicon-search"></i>
      </button>
    </div>
  </div>
</form>
</div>

<!-- end search bar -->


<div class="productTitle"></div>
<p class="external">
    <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
</p>



    <ul id="docnavsidebar" class="docnav">
    

    </li>
</ul>

<hr class="resourceSeparator"></hr>
<div class="relatedResources"></div>
<ul id="entrypages">
        
    </li>
</ul>
</div>
</div>
<script>$("li.open").parents('li').toggleClass("open");</script>






            </div>

            <!-- main area -->
            <div class="col-xs-12 col-sm-9 main">

                    <div class="subtitle"></div>

                    <h1>Search</h1>

                    <script>
    var search_no_results_found = "No results found."
</script>

<div style="display: none">
<form action="search.html" method="get">
  <div class="input-group search">
    <input type="text" id="search-box" name="query" class="form-control" placeholder="">
    <div class="input-group-btn">
      <button class="btn btn-default" type="submit" value="search">
        <i class="glyphicon glyphicon-search"></i>
      </button>
    </div>
  </div>
</form>
</div>

<div id="search-results"></div>

<script>
  window.store = {
      
          
          
      "about-the-cdf-html": {
        "title": "About the Catalog Data Format (CDF)",
        "tags": "[]",
        "content": "A Catalog Data Format (CDF) file, or “catalog file”, is an XML file that uses the schema defined in the CDF XSD file. The CDF file contains the metadata (title, length, release year, etc.) for your app’s media content (movies, TV shows, specials, mini-series, and extras).The CDF file is used to integrate that metadata into Amazon Fire TV’s universal browse and search, which enables a user to perform a search or browse for content through the Fire TV home screen rather than having to search in or browse through individual apps. See Getting Started with Fire TV Catalog Integration for an overview of the entire integration process.This page is intended as a general overview of the catalog format, including its major elements and how they fit together. We don’t cover the use of all possible elements here; for that, see the Fire TV Catalog Data Format (CDF) Schema or the XSD schema file itself.  An Example Catalog File  General CDF File Structure  Common Elements for All Works          Common Optional Elements for All Works      A Note About Strings        Elements Specific to the Work Type  Tying Shows, Seasons, and Episodes Together  Requirements for Box Art Images (ImageUrl)          Image requirements        Validating the CDF File Against the SchemaAn Example Catalog FileThe following example shows a very simple catalog file that contains only one item (a movie), and uses only required elements. We strongly recommend that you provide more details about each work than this, but this limited example is useful in showing the most basic CDF file structure. Download the cdf-examples.zip file for larger and more comprehensive examples.&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;    &lt;Catalog xmlns=\"http://www.amazon.com/FireTv/2014-04-11/ingestion\" version=\"FireTv-v1.3\"&gt;        &lt;Partner&gt;Everything Ever Made Filmworks&lt;/Partner&gt;        &lt;Works&gt;            &lt;Movie&gt;                &lt;ID&gt;MV-12345&lt;/ID&gt;                &lt;Title locale=\"en-US\"&gt;Edison Kinetoscopic Record of a Sneeze&lt;/Title&gt;                &lt;Offers&gt;                    &lt;SubscriptionOffer&gt;                        &lt;Regions&gt;                            &lt;Country&gt;US&lt;/Country&gt;                        &lt;/Regions&gt;                    &lt;/SubscriptionOffer&gt;                &lt;/Offers&gt;            &lt;/Movie&gt;        &lt;/Works&gt;    &lt;/Catalog&gt;General CDF File StructureThis section provides an overview of the structure of the CDF schema and its elements. Readers should have a good understanding of XML.The top-level outline of a catalog file can be represented as:&lt;Catalog&gt;    &lt;Partner&gt;        &lt;Works&gt;&lt;/Catalog&gt;Catalog (required) is the root element of all catalog files.Partner (required) identifies you, the content provider.Works (required) contains the bulk of the file: all of the movies and TV shows in your library, as much information as you choose to provide about each entry, and the offers that enable the user to view them.The Works element can contain any number of child elements, each representing an individual work such as a movie or a TV show. If the Works element contains no child elements, we infer that all of your content is no longer available and we will remove it from our index.The available work type elements are:            Movie      A theatrical or made-for-TV movie.              TvSpecial      A standalone TV show, which can be a special event or a show associated with a series but not part of its normal sequence of episodes              TvShow      A sequential TV presentation, normally presented in episodes grouped by seasons              TvSeason      A single season of a TV show              TvEpisode      A single episode in a single season of a TV show              MiniSeries      A TV series consisting of a small number of sequential episodes              MiniSeriesEpisode      A single episode in a mini-series              Extra      A clip or trailer, often related to another work      Movies are stand-alone elements. TV shows, seasons, and episodes are separate elements that are tied together by IDs, as are mini-series and mini-series episodes. TV specials and extras can be stand-alone elements, but can also be tied to other works. See Tying Shows, Seasons, and Episodes Together for details.Common Elements for All WorksAll of the work types listed above are built on a core of common elements, extended in each case with only 1-5 type-specific elements. Only a small subset of the common elements are required. The vast majority of elements available to you in the CDF schema are optional, but providing additional metadata both helps the user to find your content more easily and helps us match your content to that of other content providers for a better user search and browse experience.The outline of a work element can be represented as:&lt;_WorkType_&gt; (such as &lt;Movie&gt; or &lt;TvSeason&gt;)    &lt;ID&gt;        &lt;Title&gt;            &lt;Offers&gt;&lt;/_WorkType_&gt;ID (required) is an identifier of your choosing for the work. Each work’s ID must be unique within your catalog and it should never change as long as you offer that work. The ID element is also used in associating work elements, for instance to specify a TV episode as part of a TV show and season.Title (required) is, of course, the work’s title. You can provide the title in multiple languages.Offers (required) contains the methods through which the customer can view the work: for free, by rental or purchase, or through subscription. Offers can be limited by time or by region. The Offers element must contain at least one offer, but can contain as many as necessary. There are four offer types:            FreeOffer      The work is free to view at any time              SubscriptionOffer      The work requires a subscription to your service to view              PurchaseOffer      The work requires a one-time payment, after which it can be viewed at any time              RentalOffer      The work requires a one-time payment and can be viewed for only a limited time after that      The outline of an offer, including optional elements, can be represented as:&lt;_OfferType_&gt; (such as &lt;FreeOffer&gt; or &lt;PurchaseOffer&gt;)    &lt;Regions&gt;        &lt;WindowStart&gt;            &lt;WindowEnd&gt;                &lt;LaunchDetails&gt;                    &lt;Price&gt; (rental or purchase only)                        &lt;Duration&gt; (rental only)&lt;/_OfferType_&gt;Regions (required) specifies the countries in which this offer is valid. Regions is required and must contain at least one Country.WindowStart and WindowEnd (both optional) can be used together or separately to specify the time when this offer is valid. Before WindowStart and after WindowsEnd, the offer is not shown to the user.LaunchDetails (optional) enables you to specify options for visual quality, audio language, and subtitles under this offer. It also allows you to define a special ID that can be used to directly launch a work with a predetermined configuration of those options.Price is the cost to rent or buy the work, and is required for RentalOffer and PurchaseOffer. It can be specified in one of four currencies: US dollar, British pound, Japanese yen, and euro. Duration is the number of hours that a rental lasts, and is required for RentalOffer.If the availability of a given work changes, you must submit an updated catalog file with the new offer information.The detail page for a movie, extra, or TV show displays all of the available offers and providers for that item. We display viewing options in this order (subject to change):  Free offers  Subscription content  Fee-based content (purchase or rental)Common Optional Elements for All WorksSo far, we’ve discussed the common required elements and a handful of common optional elements. Using those alone, you have the knowledge to construct a valid CDF file. However, those elements account for only about one-third of the total available to you. All the rest of the common elements are optional and are used to provide more information about the work. For example, there are elements for genre, certification, cast and crew, plot description, studio, images, and customer rating. For a full list, see the Fire TV Catalog Data Format (CDF) Schema.A Note About StringsSome string data in the CDF schema, such as a work’s title and description, are defined as the custom LocalizedString type. Localized strings allow you to provide the same content in different languages, to be used according to the user’s device language setting. These strings have the required attribute locale (of standard type xsd:language). Here is an example:&lt;Title locale=\"en-US\"&gt;Edison Kinetoscopic Record of a Sneeze&lt;/Title&gt;Localized strings also have an optional attribute pronunciation (of standard type xsd:string). This attribute is provided for Japanese catalog entries that specify string text in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.Elements Specific to the Work TypeIn addition to the common elements, each work type has from one to five elements specific to that work type alone. In general, these elements have two uses: (1) to specify an original release or air date and (2) to tie works together, such as a TV episode to a TV show.Release dates are optional but recommended, and are specified by either a ReleaseDate (for movies, TV shows, or mini-series) or OriginalAirDate (for TV and mini-series episodes, and TV specials).The elements that bundle shows, seasons, and episodes are required, and are discussed in more detail in the next section.Refer to the Fire TV Catalog Data Format (CDF) Schema for particulars on the type-specific elements.Tying Shows, Seasons, and Episodes TogetherTV episodes are aired during one season of a particular TV show. A mini-series is made up of individual episodes. An extra can provide a preview or behind-the-scenes information about a movie. A TV special might be related to a TV show, but be outside of that show’s normal sequence. The CDF provides elements that enable you to make those connections. When a Fire TV user browses to a TV show and sees the show organized by seasons with each episode shown sequentially in its season, that is the result of these elements.In general, you can associate one work with another by either ID or title. An ID must match the ID of another work in your catalog. If that work is not in your catalog, you can use a title instead. The title isn’t required to match anything in your catalog and is only used to group works. The following table shows these elements for each work type:            Work Type      Link Elements                  TvEpisode      ShowID or ShowTitle  SeasonID or SeasonInShow  Note: TvEpisode also has a SeasonTitle element, but it is not used for grouping.              TvSeason      ShowID or ShowTitle              TvShow      None              TvSpecial      ShowID or ShowTitle              MiniSeries      None              MiniSeriesEpisode      MiniSeriesID or MiniSeriesTitle              Extra      RelatesToID or RelatesToExternalID              Movie      None      Rather than a title, TvEpisode uses a number to specify a season not in your catalog and Extra uses a link to an external ID scheme, such as IMDb. Also, while you can choose which to use, one in each element link pair is required for TvEpisode, TvSeason, and MiniSeriesEpisode. The link value is optional for TvSpecial and Extra, which can be standalone works.The following illustration shows how the various elements and values are matched for a TV show when using IDs.Diagram showing the relations between the IDs of TV shows, seasons, episodes, and specialsFor instance, if a TvShow had an ID of “TV-123456”, the ShowID values in TvEpisode and TvSeason would also equal “TV-123456”. Download the Catalog Data Format Examples to see fully implemented catalogs illustrating these concepts.Requirements for Box Art Images (ImageUrl)The ImageUrl element, one of the optional elements common to all works, provides the URL of an image that represents the work, sometimes called the “box art.” If you don’t include ImageUrl, we attempt to use art available from other sources such as IMDb, if we can make a match, or we might use a generic placeholder image. Note: Your catalog must provide valid images for at least 50% of its entries or the integration process will fail and the entire catalog will be rejected.Image requirements            Type      JPG (preferred) or PNG      Other image types will not be used              Aspect Ratio      Between 1:3 and 3:1 (1:2 and 2:1 preferred)      Images with aspect ratios less than 1:3 or greater than 3:1 will not be used Images with aspect ratios between 1:2 and 1:3 are cropped to 1:2  Images with aspect ratios between 2:1 and 3:1 are cropped to 2:1              Size      Height greater than 240 px (480 px preferred)      Images less than 480 px in height generate a warning in the ingestion report, but those between 240 px and 480 px are accepted without counting toward the total number of invalid images. Images less than 240 px in height will not be used. For optimal quality, we prefer large images (no image size is too big) that we can scale as needed. Note: If we crop your image because of its aspect ratio, the cropped version must still meet this height requirement regardless of its original dimensions.      At a minimum, we recommend that your images meet the specifications in the following table. Note that this refers to the box art image, not the work itself.            Media      Aspect Ratio      Minimum Size                  Movies      3:4      360 px by 480 px              TV episodes, seasons, shows, and specials Mini-series and mini-series episodes      16:10      768 px by 480 px              TV episodes, seasons, shows, and specials Mini-series and mini-series episodes      16:9      853 px by 480 px      Validating the CDF File Against the SchemaBefore you upload your catalog file, please ensure that it is well formed XML and validates against the schema. An incorrectly formatted or invalid catalog file cannot be accepted by our service. For example, on Linux systems, you can use the following xmllint command to validate your file. This command assumes that your catalog file (file.xml) is in the same folder as the schema file (schema.xsd), and you are in this folder when you issue the command. You can download the current schema file here.xmllint --noout --schema schema.xsd file.xmlMost Integrated Development Environment (IDEs) such as Eclipse or Intellij can also validate your catalog against the schema. For more information, see:  Eclipse XML Validation  Intellij XML Validation  Visual Studio XML Validation  Notepad++ XML Tools Plug-In",
        "url": "about-the-cdf.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "catalog-data-format-ingestion-report-messages-html": {
        "title": "Catalog Data Format (CDF) Ingestion Report Messages",
        "tags": "[]",
        "content": "A catalog data format (CDF) ingestion report is generated for each catalog file that an Amazon Fire TV client uploads to Amazon. The report states whether the catalog file was successfully integrated into Fire TV’s universal browse and search. If it was not, the report provides details that explain the failure. The report also provides warnings and suggestions that can be used to improve the file.This page lists errors, warnings, and suggestions seen in an ingestion report, explains their cause, and suggests a resolution to each situation. For more information on obtaining and using your ingestion report, see receiving-and-understanding-the-catalog-ingestion-report. Note: This is not a comprehensive list of every message you can see in an ingestion report. Your report can also contain XML validation errors generated by one of our validation tools. The wording of those messages varies according to the specific tool used. The messages are less user-friendly and might look like gibberish to a less technical person. If any message in the report has that effect on you, please consult a developer, IT professional, or your Amazon Business Developer Manager to help with the interpretation and required fix. Performing a catalog file validation before you submit the catalog is both a best practice and a way to make the ingestion reports easier to read. See Validating the CDF File Against the Schema for more details on file validation.  Requirements  Who Should Fix These Problems?  Conventions Used in This Document  Errors          Error: Invalid catalog file      Error: ID is not unique      Error: MiniSeriesEpisode references an invalid MiniSeriesID      Error: Referenced MiniSeries not found      Error: Referenced TvSeason not found      Error: Referenced TvShow not found      Error: Title is required and cannot be blank      Error: Too many invalid images      Error: TvEpisode references an invalid SeasonID      Error: TvEpisode references an invalid ShowID      Error: TvSpecial references an invalid ShowID        Warnings          Warning: Aspect ratio should be between %f and %f (%f to %f preferred.)      Warning: Copyright is optional but should not be blank if supplied      Warning: CastMember or CrewMember name should not be blank      Warning: ExternalID is optional but should not be blank if supplied      Warning: Image height must be greater than %d pixels (greater than %d pixels preferred)      Warning: Inconsistent release year information      Warning: Invalid image      Warning: MiniSeries is not associated with any MiniSeriesEpisodes      Warning: Possible invalid string found for optional CastMember Role element      Warning: Quality element in Offer is deprecated in favor of Quality element in LaunchDetails      Warning: ReleaseInfo element is deprecated      Warning: Role (character name) is optional but should not be blank if supplied      Warning: Runtime minutes is not within expected range of 1 to 2880 minutes      Warning: The ShortDescription should not be the same as the Title      Warning: The Synopsis should be longer and more descriptive than the ShortDescription      Warning: The Synopsis should not be the same as the ShortDescription      Warning: The Synopsis should not be the same as the Title      Warning: Text contains characters that are escaped more than once      Warning: TvSeason is not associated with any TvEpisodes      Warning: TvShow is not associated with any TvEpisodes or TvSpecials      Warning: Unsupported image type. Provided image not JPG or PNG format        Suggestions          Suggestion: Aspect ratio should be between %f and %f (%f to %f preferred.)      Suggestion: Image height must be greater than %d pixels (greater than %d pixels preferred)      Suggestion: Invalid image      Suggestion: Provide cast and crew information for better search and browse integration      Suggestion: Provide only one ShortDescription/Synopsis per locale      Suggestion: Provide the Count for CustomerRating for better data quality and user experience        Image-Related Messages          Error: Too many invalid images      Warning/Suggestion: Aspect ratio should be between 1:3 and 3:1 (1:2 to 2:1 preferred.)      Warning: Image height must be greater than 240 pixels (greater than 480 pixels preferred)      Warning: Invalid image      Warning: Invalid image      Warning: Invalid image      Warning: Invalid image      Warning: Unsupported image type. Provided image not JPG or PNG format.      Suggestion: Invalid Image      RequirementsThe information on this page is intended to help less technical users who are asked to address these issues, as well as developers in need of a reference. Readers should have at least a basic knowledge of working in an XML file (you know what elements and attributes are and know to close your tags) and be familiar with the information in receiving-and-understanding-the-catalog-ingestion-report.Who Should Fix These Problems?In general, catalog files are created in one of two ways:  Automatically, with metadata information pulled from a media database. This is accomplished through a script or other code that grabs the data on a preordained schedule, transforms it into a CDF-compliant catalog file, and uploads it to your S3 bucket. This is the preferred method because once it’s working correctly, it will run without the need for human interaction.  Manually, with someone maintaining the catalog file over time.If your company uses the automated method, some fixes and changes must be made in the source database itself rather than the catalog file. Database access is often restricted to database administrators, so work with them to either allow you access or to make the changes for you. You might also have to work with developers to perfect the code that creates the CDF file from the data.If your company maintains your catalog manually, access is probably less restrictive.Be aware that in the case of large catalogs it isn’t unusual to see warnings and suggestions that number in the thousands. Normally they’re only a handful of warnings, just applied to thousands of entries. These don’t tend to be issues that can be fixed through a blanket search-and-replace change. For instance, a suggestion to add cast and crew information to 10,000 entries requires addressing each entry individually. Warnings and suggestions do not prevent your catalog from being used, so if and when you address them depends on your time and resources.Conventions Used in This DocumentThe “CDF file” is the catalog data file you upload to Amazon, upon which the ingestion report is based. It is an XML file that conforms to the catalog data format (CDF) schema. See About the Catalog Data Format for details on the file contents.WorkID is the ID of the work element (Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra) in which the issue was found. For instance, in the case of a movie it refers to the value of an ID element under a movie entry in your CDF file. Each message in the ingestion report expands to show the ID of each work that caused that message.Detail message is the additional text you’ll see for each WorkID when you expand a particular error, warning, or suggestion in the report. It provides more specific information about the message’s cause in relation to that work. Not all messages have detail messages, in which case you only see the WorkID.Nested elements are given using a period notation. For instance, TvEpisode.Credits.CrewMember refers to the CrewMember element that is a child of the Credits element that is in turn a child of the TvEpisode element. Movie.ID is an ID element that is the child of a movie element.Anything in italics not used for emphasis is a placeholder for an actual value; nn for a number, ss for a text string_, url_ for a full URL, etc.Ellipses (…) used in examples indicate that some material not related to the topic was omitted in the interests of brevity and clarity.ErrorsAny message in the Errors section of your ingestion report causes your CDF file to be rejected. Correct all reported errors and then resubmit the CDF file.ErrorsInvalid catalog fileID is not uniqueMiniSeriesEpisode references an invalid MiniSeriesIDReferenced MiniSeries not foundReferenced TvSeason not foundReferenced TvShow not foundTitle is required and cannot be blankToo many invalid imagesTvEpisode references an invalid SeasonIDTvEpisode references an invalid ShowIDTvSpecial references an invalid ShowIDError: Invalid catalog fileDetail message: Unable to parse provided catalogWhat went wrongThe CDF file is invalid. It’s unlikely that you’ll see this message; instead, you’ll see XML validation failure messages.What to doUse a tool such as Xmllint or the validation plug-in for Notepad++ to validate your file and point you to errors. An invalid file can be caused by many things: omitting a closing tag, using an undefined element (which can simply be a typo - and also remember that XML is case-sensitive), putting the elements in the wrong order, or not including a required element or attribute. To avoid this error, you should always validate your file before you submit it.See alsoFire TV Catalog Data Format (CDF) SchemaCatalog Data Format (CDF) XSDDownloadable example CDF filesValidating the CDF File Against the SchemaError: ID is not uniqueDetail message: WorkID nn works have this IDExample: tt123456 6 works have this IDWhat went wrongYour file has at least two entries that have the same ID. Each work (Movie, TvShow, TvSeason, TvEpisode, etc.) in your CDF file must have a unique ID.What to doFind each of the works with this ID (tt123456 in the example) in your CDF file. Change the ID for all but one of them, making sure that you generate unique IDs for those you change. If the source of your CDF file is a database, you might use the work’s database key as part of its ID to ensure uniqueness. Have an ID scheme and stick to it. Note: When you change an ID, you must also change any references to it. For instance, if you change a TvShow.ID, you will also need to change all of that show’s TvSeason.ShowID, TvEpisode.ShowID, TvSpecial.ShowID, or Extra.RelatesToID elements to match.Possible elements involvedWorkType.ID WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Error: MiniSeriesEpisode references an invalid MiniSeriesIDDetail message: WorkIDExample: tt123456 MiniSeriesEpisode references an invalid MiniSeriesIDWhat went wrongThe MiniSeriesEpisode with the given work ID (tt123456 in the example) has a MiniSeriesID element, but it’s blank.What to doIn your CDF file, find the MiniSeries element to which this episode should belong. If it is present, note its ID value. Go to the MiniSeriesEpisode’s entry, locate its MiniSeriesID element, and change the value to match the MiniSeries ID. That is, ensure that MiniSeries.ID = MiniSeriesEpisode.MiniSeriesID.If the MiniSeries element isn’t present and you’re not going to add it, use MiniSeriesEpisode.MiniSeriesTitle instead of MiniSeriesEpisode.MiniSeriesID. MiniSeriesEpisode.MiniSeriesTitle is used as given, without having to match anything. This should be done only in the absence of a MiniSeries element. You might also consider whether this work would be more accurately tagged as a TvSpecial.Elements possibly involvedMiniSeries.ID MiniSeriesEpisode.MiniSeriesID MiniSeriesEpisode.MiniSeriesTitle Error: Referenced MiniSeries not foundDetail message: WorkID MiniSeriesEpisode references a missing MiniSeries with ID of ssExample: tt123456 MiniSeriesEpisode references a missing MiniSeries with ID of nn654321What went wrongThe MiniSeriesEpisode with the given work ID (tt123456 in the example) specifies the ID of its MiniSeries (nn654321 in the example), but there’s no matching MiniSeries in your catalog.What to doIn your CDF file, find the MiniSeries element to which this episode should belong. If it is present, note its ID value. Go to the MiniSeriesEpisode’s entry, locate its MiniSeriesID element, and change the value to match the MiniSeries ID. That is, ensure that MiniSeries.ID = MiniSeriesEpisode.MiniSeriesID.If the MiniSeries element isn’t present and you’re not going to add it, use MiniSeriesEpisode.MiniSeriesTitle instead of MiniSeriesEpisode.MiniSeriesID. MiniSeriesEpisode.MiniSeriesTitle is used as given, without having to match anything. This should be done only in the absence of a MiniSeries element. You might also consider whether this work would be more accurately tagged as a TvSpecial.Elements possibly involvedMiniSeries.ID MiniSeriesEpisode.MiniSeriesID MiniSeriesEpisode.MiniSeriesTitle Error: Referenced TvSeason not foundDetail message: WorkID TvEpisode references a missing TvSeason with ID of ssExample: tt123456 TvEpisode references a missing TvSeason with ID of nn654321What went wrongThe TvEpisode with the given work ID (tt123456 in the example) specifies the ID of its TvSeason (nn654321 in the example), but there’s no matching TvSeason in your catalog.What to doIn your CDF file, find the TvSeason element to which this episode should belong. If the TvSeason is present, note its ID value. Go to the TvEpisode’s entry, locate its SeasonID element, and change the value to match the TvSeason’s ID. That is, ensure that TvSeason.ID = TvEpisode.SeasonID.If the TvSeason isn’t present and you’re not going to add it, use TvEpisode.SeasonInShow instead of TvEpisode.SeasonID. You can also add the optional TvEpisode.SeasonTitle. TvEpisode.SeasonInShow and TvEpisode.SeasonTitle are used as given and are not required to match anything. This should be done only in the absence of a TvSeason element, which only should be absent if you absolutely cannot obtain that information. Note: Some shows weren’t released or organized by season. In those cases, instead of a TvEpisode, consider classifying the work as a TvSpecial associated with a TvShow or a MiniSeriesEpisode associated with a MiniSeries.Elements possibly involvedTvSeason.IDTvEpisode.SeasonIDTvEpisode.SeasonInShowTvEpisode.SeasonTitleError: Referenced TvShow not foundDetail messages:WorkID TvEpisode references a missing TvShow with ID of ssWorkID TvSpecial references a missing TvShow with ID of ssExample: tt123456 TvEpisode references a missing TvShow with ID of nn654321What went wrongThis can happen with either a TvEpisode or a TvSpecial. The episode or special with the given work ID (tt123456 in the example) specifies the ID of its TvShow (nn654321 in the example), but there’s no matching TvShow in your catalog.What to doIn your CDF file, find the TvShow element to which the episode or special should belong. If the TvShow is present, note its ID value. Go to the TvSpecial or TvEpisode entry, locate its ShowID element, and change that value to match the show’s ID. That is, ensure that TvShow.ID = TvEpisode.ShowID, or TvShow.ID = TvSpecial.ShowID.If the TvShow isn’t present and you’re not going to add it, use ShowTitle instead of ShowID. ShowTitle is used as given and is not required to match anything. This should be done only in the absence of a TvShow element, which should raise the question of whether one should be added, or whether this work might be more accurately tagged as a TvSpecial.Elements possibly involvedTvShow.IDTvEpisode.ShowIDTvSpecial.ShowIDTvEpisode.ShowTitleTvSpecial.ShowTitleError: Title is required and cannot be blankDetail message: WorkIDWhat went wrongYour CDF file contains a Title element for the given ID, it just doesn’t contain the title text.What to doFind the work with the given ID in your CDF file, locate its Title element, and provide the text. Here’s an example:Before: &lt;Title locale=\"en-US\"&gt;&lt;/Title&gt; After: &lt;Title locale=\"en-US\"&gt;City Lights&lt;/Title&gt;Possible elements involvedWorkType.Title WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Error: Too many invalid imagesSee Image-Related Messages.Error: TvEpisode references an invalid SeasonIDDetail message: WorkIDExample: tt123456 TvEpisode references an invalid SeasonIDWhat went wrongThe TvEpisode with the given work ID (tt123456 in the example) has a SeasonID element, but it’s blank.What to doIn your CDF file, find the TvSeason element to which this episode should belong. If it is present, note its ID value. Go to the TvEpisode’s entry, locate its SeasonID element, and change the value to match the TvSeason ID. That is, ensure that TvSeason.ID = TvEpisode.SeasonID.If the TvSeason element isn’t present and you’re not going to add it, use TvEpisode.SeasonInShow instead of TvEpisode.SeasonID. TvEpisode.SeasonInShow is just a number, used as given. You can also add the optional TvEpisode.SeasonTitle element, which is also used as given, without having to match anything. This should be done only in the absence of a TvSeason element.Elements possibly involvedTvSeason.IDTvEpisode.SeasonIDTvEpisode.SeasonInSeriesTvEpisode.SeasonTitleError: TvEpisode references an invalid ShowIDDetail message: WorkIDExample: tt123456 TvEpisode references an invalid ShowIDWhat went wrongThe TvEpisode with the given work ID (tt123456 in the example) has a ShowID element, but it’s blank.What to doIn your CDF file, find the TvShow element to which this episode should belong. If it is present, note its ID value. Go to the TvEpisode’s entry, locate its ShowID element, and change the value to match the TvShow ID. That is, ensure that TvShow.ID = TvEpisode.ShowID.If the TvShow isn’t present and you’re not going to add it, use TvEpisode.ShowTitle instead of TvEpisode.ShowID. ShowTitle is used as given and is not required to match anything. This should be done only in the absence of a TvShow element, which should raise the question of whether one should be added, or whether this work might be more accurately tagged as a TvSpecial.Elements possibly involvedTvShow.ID TvEpisode.ShowID TvEpisode.ShowTitle Error: TvSpecial references an invalid ShowIDDetail message: WorkIDExample: tt123456 TvSpecial references an invalid ShowIDWhat went wrongThe TvSpecial with the given work ID (tt123456 in the example) has a ShowID element, but it’s blank.What to doIn your CDF file, find the TvShow element to which this special should belong. If it is present, note its ID value. Go to the TvSpecial’s entry, locate its ShowID element, and change the value to match the TvShow ID. That is, ensure that TvShow.ID = TvSpecial.ShowID.If the TvShow isn’t present and you’re not going to add it, use TvSpecial.ShowTitle instead of TvSpecial.ShowID. ShowTitle is used as given and is not required to match anything. This should be done only in the absence of a TvShow element. Note that this information is optional for a TvSpecial, so ShowID/ShowTitle can be omitted altogether.Elements possibly involvedTvShow.ID TvSpecial.ShowID TvSpecial.ShowTitle WarningsWarnings do not cause the catalog ingestion to fail (except image-related warnings, which can if there are enough of them), but they should be addressed as your resources allow. Deprecation warnings in particular call for attention because they tell you that the CDF schema has changed, which can result in some of your data no longer being used as before.WarningsAspect ratio should be between %f and %f (%f to %f preferred.) Copyright is optional but should not be blank if supplied CastMember or CrewMember name should not be blank ExternalID is optional but should not be blank if supplied Image height must be greater than %d pixels (greater than %d pixels preferred) Inconsistent release year information Invalid image MiniSeries is not associated with any MiniSeriesEpisodes Possible invalid string found for optional CastMember Role element Quality element in Offer is deprecated in favor of Quality element in LaunchDetails ReleaseInfo element is deprecated Role (character name) is optional but should not be blank if supplied Runtime minutes is not within expected range of 1 to 2880 minutes The ShortDescription should not be the same as the Title The Synopsis should be longer and more descriptive than the ShortDescription The Synopsis should not be the same as the ShortDescription The Synopsis should not be the same as the Title Text contains characters that are escaped more than once TvSeason is not associated with any TvEpisodes TvShow is not associated with any TvEpisodes or TvSpecials Unsupported image type. Provided image not JPG or PNG format Warning: Aspect ratio should be between %f and %f (%f to %f preferred.)See Image-Related Messages. Note that this message can appear as either a warning or a suggestion, depending on its severity.Warning: Copyright is optional but should not be blank if suppliedDetail message: WorkIDWhat went wrongThe Copyright element is present under the work with the given ID, but it doesn’t have the copyright information text.What to doBecause the Copyright element is optional, you can delete it altogether if you don’t know the copyright information. Otherwise, find the work element with the given ID in your CDF file, locate its Copyright element, and add the missing information. Here’s an example:Before: &lt;Copyright locale=\"en-US\"&gt;&lt;/Copyright&gt; After: &lt;Copyright locale=\"en-US\"&gt;© 1894 Edison Manufacturing Company&lt;/Copyright&gt; Possible elements involvedWorkType.Copyright WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: CastMember or CrewMember name should not be blankDetail message: WorkIDWhat went wrongThis warning can apply to either a CastMember or a CrewMember. Your CDF file contains the Name element for the person, but it’s missing the person’s name.What to doFind the work element with the given ID in your CDF file. Find that work’s Credits element. Look at each CastMember or CrewMember element in that Credits section, locate any with an empty Name element, and add that information. Here’s an example:Before: &lt;Name locale=\"en-US\"&gt;&lt;/Name&gt;After: &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;Possible elements involvedWorkType.CastMember.Name WorkType.CrewMember.Name WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: ExternalID is optional but should not be blank if suppliedDetail message: WorkIDWhat went wrongYour CDF file contains an ExternalID element, but doesn’t provide the information. An ExternalID is the ID assigned to a work or person by some other source such as IMDb or the UPC code on a DVD box. The ExternalID can apply to a work (Movie, TvShow, etc.), a CastMember, or a CrewMember. With an ExternalID, we can link to or pull in information from that source. For instance, for a member of the cast or crew, their IMDb ExternalID allows their picture and description to be imported.What to doFind the element with the given ID in your CDF file. Find each ExternalID element that it contains—a work can contain as many ExternalID elements as it has CrewMember or CastMember elements, plus one for the work itself. Because the ExternalID element is optional, you can delete it altogether if necessary. Otherwise, add the missing information. Here’s an example for a CastMember:&lt;Movie&gt;    &lt;ID&gt;_WorkID_&lt;/ID&gt;    &lt;ExternalID scheme=\"imdb\"&gt;tt0029843&lt;/ExternalID&gt;    ...    &lt;Credits&gt;        &lt;CastMember&gt;            &lt;Name locale=\"en-US\"&gt;Errol Flynn&lt;/Name&gt;            &lt;ExternalID scheme=\"imdb\"&gt;nm0653028&lt;/ExternalID&gt;Possible elements involvedWorkType.ExternalID WorkType.CastMember.ExternalID WorkType.CrewMember.ExternalID WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Image height must be greater than %d pixels (greater than %d pixels preferred)See Image-Related Messages. Note that this message can appear as either a warning or a suggestion, depending on its severity.Warning: Inconsistent release year informationDetail message: WorkID Provided ReleaseYear yyyy differs from the year yyyy in the ss elementExamples:tt123456 Provided ReleaseYear 1959 differs from the year 1960 in the OriginalAirDate element tt456789 Provided ReleaseYear 1977 differs from the year 1978 in the ReleaseDate element What went wrongThe work specifies its release year in more than one place, but they do not agree. You’ve provided a ReleaseYear plus an OriginalAirDate or ReleaseDate, each of which also include a year. In tracking this down, note that there are two different ReleaseDate elements, one that’s a direct child element of the work and another that’s a child element of the deprecated ReleaseInfo element. ReleaseDate is found only under Movie, TvShow, and MiniSeries elements. The deprecated ReleaseInfo.ReleaseDate is found in all work types. OriginalAirDate is found only under TvEpisode, TvSpecial, and MiniSeriesEpisode elements. Note: Do not use the deprecated ReleaseInfo.ReleaseDate element in any new additions to your catalog. If your catalog predates that element’s deprecation, consider updating the catalog to fit the current schema. See ReleaseInfo element is deprecated below for instructions.What to doFind the element with the given WorkID (tt123456 or tt456789 in the example) in your CDF file. Find its ReleaseYear element, verify that the year is correct, and note the value. Next, find any instance of OriginalAirDate or ReleaseDate under that work and ensure that those strings include the same year. Note that OriginalAirDate and ReleaseDate have strict data forms (for example, 2003-08-08T00:00:00Z) of which the year might be only a portion.Possible elements involvedWorkType.ReleaseYear WorkType.ReleaseDate WorkType.ReleaseInfo.ReleaseDate WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Invalid imageSee Image-Related Messages.Warning: MiniSeries is not associated with any MiniSeriesEpisodesDetail message: WorkIDWhat went wrongYour CDF file contains an entry for a MiniSeries, but it doesn’t have any episodes. This can lead to a bad user experience because they can see and select the mini-series, but then find it empty. There are two possibilities for what caused this. The first is that the MiniSeriesEpisode elements weren’t included in the CDF file. The second is that those episodes are in your CDF file, but they specify the wrong mini-series.What to doFind each expected MiniSeriesEpisode element for that MiniSeries in your CDF file. Are they there?  No: You’ll need to add them.  Yes: How does each identify its MiniSeries; by using the MiniSeriesID or MiniSeriesTitle element?  MiniSeriesID: Ensure that it matches the MiniSeries.ID value (the WorkID in the detail message).  MiniSeriesTitle: Ensure that it matches the MiniSeries.Title value exactly, including case.Possible elements involvedMiniSeries.ID MiniSeries.Title MiniSeriesEpisodes.MiniSeriesID MiniSeriesEpisodes.MiniSeriesTitle Warning: Possible invalid string found for optional CastMember Role elementDetail message: WorkID Please confirm that text is a valid Role (character name)Examples:tt123456 Please confirm that Actor is a valid Role (character name) tt123456 Please confirm that Unknown is a valid Role (character name) What went wrongThis warning is very specific. Currently, it only looks for values of “Unknown” or “Actor” in the CastMember.Role element. The Role element exists to supply the name of the character that the actor played in the work, such as Han Solo. Any entry under CastMember is, by definition, an actor. That said, there are rare instances where “Actor” or “Unknown” could be valid character names. In those cases, to avoid seeing this warning in every report, you might reword those entries somewhat if possible, such as “Actor #1” or “The Unknown”. Note that if you include the Role element but leave it blank, you’ll receive a different warning.What to doFind the work element with the given ID in your CDF file. Find its Credits section. Find any CastMember elements that it contains and locate any with “Actor” or “Unknown” in the Role element. The Role element is optional, so omit it altogether if you don’t know the character’s name. Otherwise, add the character name.Possible elements involvedWorkType.Credits.CastMember.Role WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Quality element in Offer is deprecated in favor of Quality element in LaunchDetailsDetail message: WorkIDWhat went wrongThe CDF schema has changed, but your file still uses elements from an older schema version. In this case, as of CDF version 1.2, the Quality element for each Offer type was moved under the new Offers.OfferType.LaunchDetails element, but is otherwise the same. Your file still places the Quality element directly under Offers.OfferType.What to doTechnically, you don’t have to do anything. Your existing Quality value will continue to be used. However, in the interest of a clean ingestion report, you should update your file as your resources allow.  If your CDF file is automatically generated from your media database: The script or transform that takes the information from your database and puts it into the CDF format will need to be updated. Contact your database administrator (DBA) and tell them that the quality value should now be exported to the Offers.OfferType.LaunchDetails.Quality element rather than to Offers.OfferType.Quality. The DBA can consult the Catalog Data Format (CDF) XSD for the LaunchElement’s proper placement.  If your database has a structure that matches the CDF format: Again, your DBA will need to make this change. In this case, the database itself will need to be slightly redesigned to account for the newer CDF structure.  If you construct the CDF file manually: Find the work with the given ID in your CDF file. Find its Offers element. Do the following for each offer type that currently has an Offers.OfferType.Quality element:          Add a LaunchDetails element. Location matters - it should be the last element in the SubscriptionOffer and FreeOffer types, and should be directly before the PriceType element in the PurchaseOffer and RentalOffer types.      Add a Quality element under the LaunchDetails element. Specify the same value (SD, HD, or UHD) that the original element used.      Delete the original Offers.OfferType.Quality element.      Here’s an example of the change:Before&lt;Movie&gt;    ...    &lt;Offers&gt;|        &lt;FreeOffer&gt;            &lt;Quality&gt;HD&lt;/Quality&gt;            ...        &lt;/FreeOffer&gt;        ...    &lt;/Offers&gt;    ...&lt;/Movie&gt;After&lt;Movie&gt;    ...    &lt;Offers&gt;|        &lt;FreeOffer&gt;            ....            &lt;LaunchDetails&gt;                &lt;Quality&gt;HD&lt;/Quality&gt;            &lt;/LaunchDetails&gt;        &lt;/FreeOffer&gt;        ...    &lt;/Offers&gt;    ...&lt;/Movie&gt;Possible elements involvedWorkType.Offers.OfferType.Quality (deprecated) WorkType.Offers.OfferType.LaunchDetails.Quality WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra OfferType can be SubscriptionOffer, FreeOffer, PurchaseOffer, or RentalOffer Warning: ReleaseInfo element is deprecatedDetail message: WorkID Please use the ReleaseDate / OriginalAirDate / ReleaseYear element instead for WorkTypeExamples:tt123456 Please use the ReleaseDate element instead for ShowType tt45678 Please use the OriginalAirDate element instead for EpisodeTypeWhat went wrongThe CDF schema has changed, but your file still uses elements from an older schema version. In this case, as of CDF version 1.3, the ReleaseInfo element, which applied to all work types, is deprecated in favor of work-type-specific values. ReleaseInfo contained two child elements: ReleaseDate and ReleaseCountry. ReleaseCountry information is no longer used at all. ReleaseDate information is now stored based on the work type: ReleaseDate for the Movie, TvShow, and MiniSeries types; OriginalAirDate for TvEpisode, TvSpecial, and MiniSeriesEpisode types.What to doTechnically, you don’t have to do anything. Your existing ReleaseInfo.ReleaseDate value will continue to be used. However, in the interest of a clean ingestion report, you should update your file as your resources allow.  If your CDF file is automatically generated from your media database: The script or transform that takes the information from your database and puts it into the CDF format will need to be updated. Contact your database administrator (DBA) and tell them the following:          The work’s release date, previously contained in WorkType.ReleaseInfo.ReleaseDate, should now be exported to WorkType.OriginalAirDate for TvEpisode, TvSpecial, and MiniSeriesEpisode types and WorkType.ReleaseDate for Movie, TvShow, and MiniSeries types.      The ReleaseInfo element should be removed. The DBA can consult the Catalog Data Format (CDF) XSD for details.        If your database has a structure that matches the CDF format: Again, your DBA will need to make this change. In this case, the database itself will need to be slightly redesigned to account for the newer CDF structure.  If you construct the CDF file manually: Find the work with the given ID in your CDF file. Find its ReleaseInfo element and note the ReleaseDate value.  If the work type is Movie, TvShow, or MiniSeries: Add a ReleaseDate element, including the value, as the very last thing under the work’s element.  if the work type is TvEpisode, TvSpecial, or MiniSeriesEpisode: Add an OriginalAirDate element, including the value, as the very last thing under the work’s element.  Regardless of work type: Remove the original ReleaseInfo element once the new elements are in place.Elements possibly involvedWorkType.ReleaseInfo (deprecated) WorkType.ReleaseInfo.ReleaseDate (deprecated) WorkType.ReleaseInfo.ReleaseCountry (deprecated) WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Movie.ReleaseDate TvShow.ReleaseDate MiniSeries.ReleaseDate TvEpisode.OriginalAirDate TvSpecial.OriginalAirDate MiniSeriesEpisode.OriginalAirDate Warning: Role (character name) is optional but should not be blank if suppliedDetail message: WorkID Role (character name) for ​person is blankExample: tt123456 Role (character name) for Errol Flynn is blankWhat went wrongThe Role element is present, but it doesn’t provide the information. The Role element exists to supply the name of the character that the actor played in the work, such as Han Solo.What to doFind the work with the given ID in your CDF file (tt123456 in the example). Find its Credits section. Find the CastMember element for the person in question (Errol Flynn in the example), and locate that person’s Role element. Role is optional, so you can either add the character name or, if you don’t know the character name, delete the Role element altogether. Do not use “Unknown” as a character name.Possible elements involvedWorkType.Credits.CastMember.Role WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Runtime minutes is not within expected range of 1 to 2880 minutesDetail message: WorkID Please confirm that nn minutes is the correct runtimeExample: tt123456 Please confirm that 99999999 minutes is the correct runtimeWhat went wrongYour CDF file contains a RuntimeMinutes element with a value that seems unusually large or small. This warning is triggered when the value is less than 1 or greater than 2880 minutes (48 hours!). Few works would legitimately fall outside of that range. This information can be seen by the end user and so should be accurate to avoid a bad user experience.What to doFind the work with the given ID in your CDF file (tt123456 in the example). Find its RuntimeMinutes element. Make sure that the correct value is given. Because this is an optional element, you can delete the RuntimeMinutes element altogether, but for a better user experience this is not recommended.Possible elements involvedWorkType.RuntimeMinutes WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: The ShortDescription should not be the same as the TitleDetail message: WorkIDWhat went wrongThe Title and ShortDescription elements contain identical text, which is a poor user experience. The ShortDescription element is meant to hold a 2-3 line summary of the work to give the user an idea of whether that work is of interest to them. Users already know the title at that point.What to doFind the work with the given ID in your CDF file. Find its ShortDescription element. Replace the work’s name in that element with a brief (2-3 lines) description of its plot or subject. The ShortDescription element is optional; if you don’t have a description, you can delete it altogether, although we recommended that each work has at least a ShortDescription.Possible elements involvedWorkType.ShortDescription WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: The Synopsis should be longer and more descriptive than the ShortDescriptionDetail message: WorkIDWhat went wrongThis CDF file contains both a ShortDescription and a Synopsis for this work. The Synopsis text is shorter than, but not identical to, the ShortDescription text. The Synopsis element is meant to hold a more detailed description of the work than can be given in the 2-3 line ShortDescription.What to doFind the work with the given ID in your CDF file. Find that work’s Synopsis and ShortDescription elements and compare their contents. Adding an expanded Synopsis is the ideal solution for the best user experience. However, if you don’t have any further information on the work, you can omit the Synopsis as it is optional. Although it is also optional, we recommend that you supply at least a shortDescription.Possible elements involvedWorkType.ShortDescription WorkType.Synopsis WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: The Synopsis should not be the same as the ShortDescriptionDetail message: WorkIDWhat went wrongThis CDF file contains both a ShortDescription and a Synopsis for this work, and the two elements contain identical text. The Synopsis element is meant to hold a more detailed description of the work’s content than can be given in the 2-3 line ShortDescription.What to doFind the work with the given ID in your CDF file. Find that work’s Synopsis and ShortDescription elements and compare their contents. If the ShortDescription is more than 2-3 lines, shorten it. If not, then expand the Synopsis for the best user experience. However, if you don’t have any further information on the work, you can omit the Synopsis as it is optional. Although it is also optional, we recommend that you supply at least a ShortDescription.Possible elements involvedWorkType.ShortDescription WorkType.Synopsis WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: The Synopsis should not be the same as the TitleDetail message: WorkIDWhat went wrongThe Title and Synopsis elements contain identical text, which is a poor user experience. The Synopsis element is meant to hold a summary of the content to give the user an idea of what the work is about. They already know the title by that point.What to doFind the work with the given ID in your CDF file. Find its Synopsis element. Replace the work’s name in that element with a description of its plot or subject. The Synopsis element is optional, so if you don’t have a description you can delete it altogether, although this is not ideal.Possible elements involvedWorkType.Synopsis &lt;/br&gt;WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Text contains characters that are escaped more than onceDetail message: WorkID Element contains characters that are escaped more than onceExamples:tt123456 MiniSeriesTitle contains characters that are escaped more than once tt234567 SeasonTitle contains characters that are escaped more than once tt345678 ShortDescription contains characters that are escaped more than once tt456789 ShowTitle contains characters that are escaped more than once tt567890 Title contains characters that are escaped more than once What went wrongAn XML serializer (possibly used in the code that pulls data from your database and converts it into the catalog XML file), has replaced the ampersand (&amp;) in an escaped character with the escaped ampersand (&amp;). An escaped character is present in your text as a code entity; for example, • for an em-dash, and &amp; for an ampersand. The serializer did not expect escaped characters and dealt with them as plain text, escaping all ampersands. This results in “•” becoming “&amp;mdash;” and displaying as “•“. The string “this &amp; that”, which you expect to render as “this &amp; that”, becomes “this &amp;amp; that”, which displays as “this &amp; that”.What to doIn both your CDF file and in your source database, find the work with the given ID and then its text element as specified in the detail message (Title, ShowTitle, SeasonTitle, ShortDescription, or MiniSeriesTitle). If the doubly-escaped characters are only present in your catalog file, the problem lies in the transformation when the catalog file is created. Use non-escaped characters in the original text whenever possible. You might also be able to instruct the serializer to expect an escaped string so that it properly recognizes those characters.Possible elements involvedMiniSeriesEpisode.MiniSeriesTitle TvEpisode.SeasonTitle TvEpisode.ShowTitle TvSeason.ShowTitle TvSpecial.ShowTitle WorkType.ShortDescription WorkType.Title WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: TvSeason is not associated with any TvEpisodesDetail message: WorkIDWhat went wrongYour CDF file contains an entry for a TvSeason, but it doesn’t have any episodes. This can lead to a bad user experience because they can see and select the season, but then find it empty. There are two primary possibilities for what caused this. The first is that the TvEpisode elements weren’t included in the CDF file. The second is that those episodes are in your CDF file, but they specify the wrong season.What to doFind each expected TvEpisode element for that season in your CDF file. Are they there?  No: You’ll need to add them.  Yes: How does each identify its season; by using the SeasonID or SeasonInShow element?  SeasonID: Ensure that it matches the TvSeason.ID value (the WorkID in the detail message).  SeasonInShow: Ensure that it matches the TvSeason.SeasonInShow value.Possible elements involvedTvSeason.ID TvEpisode.SeasonTitle TvEpisode.SeasonID TvEpisode.SeasonInShow Warning: TvShow is not associated with any TvEpisodes or TvSpecialsDetail message: WorkIDWhat went wrongYour CDF file contains an entry for a TvShow, but it doesn’t have any episodes. This can lead to a bad user experience because they can see and select the show, but then find it empty. There are two primary possibilities for what caused this. The first is that the TvEpisode elements weren’t included in the CDF file. The second is that those episodes are in your CDF file, but they specify the wrong show.What to doFind each expected TvEpisode element for that show in your CDF file. Are they there?  No: You’ll need to add them.  Yes: How does each identify its show; by using the ShowID or ShowTitle element?  ShowID: Ensure that it matches the TvShow.ID value (the WorkID in the detail message).  ShowTitle: Ensure that it matches the TvShow.Title value exactly, including case.Possible elements involvedTvShow.ID TvShow.Title TvEpisode.ShowID TvEpisode.ShowTitle Warning: Unsupported image type. Provided image not JPG or PNG formatSee Image-Related Messages.SuggestionsSuggestions other than “Invalid image” do not prevent your catalog from being successfully updated. They are provided to encourage best practices for an improved end user experience.SuggestionsAspect ratio should be between %f and %f (%f to %f preferred.) Image height must be greater than %d pixels (greater than %d pixels preferred) Invalid image Provide cast and crew information for better search and browse integration Provide only one ShortDescription/Synopsis per locale Provide the Count for CustomerRating for better data quality and user experience Suggestion: Aspect ratio should be between %f and %f (%f to %f preferred.)See Image-Related Messages. Note that this message can appear as either a warning or a suggestion, depending on its severity.Suggestion: Image height must be greater than %d pixels (greater than %d pixels preferred)See Image-Related Messages. Note that this message can appear as either a warning or a suggestion, depending on its severity.Suggestion: Invalid imageSee Image-Related Messages.Suggestion: Provide cast and crew information for better search and browse integrationDetail message: WorkIDWhat to doIn your CDF file, this work does not include any cast or crew information. Including this information can make the work easier to find by the user. For instance, the user might want to search for movies that feature the actor Humphrey Bogart, or films directed by Akira Kurosawa. Without at least basic cast and crew information, the work can only be found by searching for its title or coming across it while browsing.Elements involvedWorkType.Credits.CastMember WorkType.Credits.CrewMember WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra&lt;br/.Suggestion: Provide only one ShortDescription/Synopsis per localeDetail message: WorkID There is more than one ShortDescription/Synopsis with locale of ssExamplesWorkID There is more than one ShortDescription with locale of en-us WorkID There is more than one Synopsis with locale of fr What to doYour CDF file contains either multiple entries with the same locale under ShortDescription, multiple entries with the same locale under Synopsis, or both. For a given locale, only one ShortDescription and one Synopsis can be used. Find the work with the given ID in your CDF file. Find its ShortDescription element. If the ShortDescription contains multiple entries, find any with the same locale value. Remove entries as needed to leave a single entry with that locale. Repeat the procedure for the Synopsis element.Elements involvedWorkType.ShortDescription WorkType.Synopsis WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Suggestion: Provide the Count for CustomerRating for better data quality and user experienceDetail message: WorkIDWhat to doThe CustomerRating entry in your CDF file has the option of a Count element. Count is intended to state the number of customers who rated the work. Higher numbers give a rating more credibility, as they tend to balance out the skew that can result from a low sample set. You would need to track that information and update the Count and CustomerRating values each time you update your catalog.Elements involvedWorkType.CustomerRating.Count WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Image-Related MessagesErrors, warnings, and suggestions that concern images interact in a way that the other messages do not. Normally, warnings and suggestions do not cause your catalog to be rejected. However, image-related warnings and suggestions in over 50% of your entries trigger the Too many invalid images error, which does cause a catalog rejection.Many image issues aren’t a problem with the CDF file itself, but rather a problem with one or more images that it references. Solving some image issues can involve graphic design, image editing, or server access rights. You might need to reach out to your graphics or IT department to help you solve these problems.Error-related messagesError: Too many invalid images Warning: Aspect ratio should be between 1:3 and 3:1 (1:2 to 2:1 preferred.) Warning: Image height must be greater than 240 pixels (greater than 480 pixels preferred) Warning: Invalid image We were unable to retrieve an image from url. The HTTP response was empty. We were unable to retrieve an image from url. The HTTP connection was unexpectedly closed. We were unable to retrieve an image from url. The HTTP response was invalid. We were unable to retrieve an image from url. The HTTP response was status code, reason. Warning: Unsupported image type. Provided image not JPG or PNG format. Suggestion: Aspect ratio should be between 1:3 and 3:1 (1:2 to 2:1 preferred.) Suggestion: Image height must be greater than 240 pixels (greater than 480 pixels preferred) Suggestion: Invalid image No image present for item. Please provide image if available. Error: Too many invalid imagesDetail message: nn% invalid images or fewer allowed; nn% found. See the warnings and suggestions section for details.What went wrongA small number of invalid images (missing or unusable) do not cause an ingestion failure—you’ll only see warnings and suggestions in that case. However, enough invalid images were found in this catalog to cause a failure. The threshold is approximately 50%. Note that the lack of an image for a work is considered an invalid image, so at least 50% of the works in your catalog must include valid images.What to doRefer to the Warnings and Suggestions sections of the ingestion report for the specific image-related issues encountered in the ingestion. Find and correct any instances of those warnings and suggestions that you find in the report.Elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning/Suggestion: Aspect ratio should be between 1:3 and 3:1 (1:2 to 2:1 preferred.)Detail message: WorkID Unsupported aspect ratio nn for image url. Please provide acceptably sized image.What went wrongThis is not a problem with your CDF file; it is a problem with an image that it references. The image exceeds our current height-to-width ratio requirements, which is to say that it’s either too skinny or too flat.What you need to knowWe want a width-to-height ratio between 1:2 and 2:1. If your image is between 1:3 and 3:1, we crop it to 1:2 or 2:1 and this message appears as a suggestion. However, if the cropping causes the image height to drop below 240 pixels, the image won’t be used.If your image is outside of 1:3 to 3:1, this message appears as a warning and the image counts toward the total number of invalid images, which can lead to the catalog being rejected.What to doFind the work with the given ID (tt123456 in the example) in your CDF file. Find the ImageUrl tag that it contains. This URL tells you where the image file is located. Provide that URL to your graphics department and let them know that you need the image to have a width-to-height ratio between at least 1:3 and 3:1 (1:2 and 2:1 to avoid cropping), while ensuring that the height is no less than 480 pixels, even after cropping. Once you have a corrected image, ensure that its URL hasn’t changed. If it has, update the ImageUrl value in your CDF file.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Image height must be greater than 240 pixels (greater than 480 pixels preferred)Detail message: WorkID Image height nn is below acceptance criteria for url. Please provide acceptably sized image.What went wrongThis is not a problem with your CDF file, but rather a problem with an image that it references. The image referenced by the work has a proper width-to-height ratio, but it is shorter than the required 480 pixels high. We prefer a height of at least 480 pixels. If your image height is between 240 and 480 pixels, this message appears as a suggestion. If your image height is below 240 pixels, this message appears as a warning and the image counts toward the total number of invalid images, which can lead to the catalog being rejected.What to doFind the element with the given ID in your CDF file. Find the ImageUrl tag that it contains. This URL tells you where the image file is located. Provide that URL to your graphics department and let them know that the image height should be no less than 240 pixels (480 pixels or more preferred) while ensuring that the image retains a width-to-height ratio between 1:3 or 3:1 (between 1:2 and 2:1 to avoid cropping). Once you have a corrected image, ensure that its URL hasn’t changed. If it has, update the ImageUrl value in your CDF file.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Invalid imageDetail message: WorkID We were unable to retrieve an image from url. The HTTP response was empty.What went wrongThe request to provide the image was made to the server where the image is stored, but, while the response code indicated success, the response contained no headers or body, and no image.What to doThis is not a problem with the CDF file, but rather a server communication problem. If the problem persists in subsequent reports, find the work with the given ID in your CDF file and find its ImageUrl tag. Provide the URL to your IT department, let them know that retrieval requests for the image are coming back empty, and ask them to investigate.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Invalid imageDetail message: WorkID We were unable to retrieve an image from url. The HTTP response was unexpectedly closed.What went wrongThe request to provide the image was made to the server where the image is stored, but the server connection closed unexpectedly and the image could not be retreived.What to doThis is not a problem with the CDF file, but rather a server communication problem. In this case, wait for the next report to try to reproduce the issue, which might very well be a one-time problem. If the image request continues to return this warning, provide the image file’s URL to your IT department and let them know that the system is repeatedly not responding to a retrieval request with a valid HTTP response. They should be able to further investigate based on that information.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra &lt;/br&gt;Warning: Invalid imageDetail message: WorkID We were unable to retrieve an image from url. The HTTP response was invalid.What went wrongThe request to provide the image was made to the server where the image is stored, but the response message that came back was garbled in some way.What to doThis is not a problem with the CDF file, but rather a server communication problem. In this case, you might wait for the next report to see if it replicates; it’s entirely possible that it was a one-time problem. If the image request continues to return this warning, provide the image file’s URL to your IT department and let them know that the system is repeatedly not responding to a retrieval request with a valid HTTP response. They should be able to further investigate based on that information.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Warning: Invalid imageDetail message: WorkID We were unable to retrieve an image from url. The HTTP response was status code: reason.What went wrongThe request to provide the image was made to the server where the image is stored, but the response code indicated a problem and did not return an image.What to doThis is not a problem with the CDF file, but rather a server communication problem. Provide the image file’s URL and the response’s status code and reason to your IT department. They should be able to further investigate based on that information. The problem could lie with an invalid request, a server accessibility or firewall issue, a payload size issue, an offline server, or any number of things.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra See alsoHTTP/1.1: Status Code DefinitionsWarning: Unsupported image type. Provided image not JPG or PNG format.Detail message: WorkID Unsupported image type ext for url. Images should be in JPG or PNG format.What went wrongThe CDF file has specified an image file with a format other than JPG or PNG.What to doFind the work with the given ID in the CDF file. Find its ImageUrl element. This URL specifies the image file location. You might need to contact your graphics department to have the image converted to a supported format (JPG or PNG), or you can do it yourself by opening the file in a graphics program and saving it as one of the supported types. Some file type conversions can degrade the image, so compare the original and new versions to ensure that the new image is still acceptable. Replace the image on the server with the new version. You might need to update the ImageUrl element in the CDF file to match the new image name.Possible elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra Suggestion: Invalid ImageDetail message: WorkID No image present for item. Please provide image if available.What went wrongThe CDF file does not specify an image for this work.What to doWhile ImageUrl is optional for any given work, at least 50% of your work entries must provide a valid image through that element. Failure to do so causes the Too many invalid images error to be triggered, which causes your uploaded catalog to be rejected. If you are above the 50% threshold and do not include an image for a work, we will attempt to use an external source for the image, such as IMDb. This requires that you include enough information about the work to allow us to match it to that external source. For lack of any other image, we will provide a generic placeholder, but that is a less than ideal user experience.Elements involvedWorkType.ImageUrl WorkType can be Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, or Extra ",
        "url": "catalog-data-format-ingestion-report-messages.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "catalog-data-format-schema-reference-html": {
        "title": "Fire TV Catalog Data Format (CDF) Schema",
        "tags": "[]",
        "content": "This topic provides a dictionary of the elements available in the Catalog Data Format (CDF) schema, used to construct a catalog of your media content for upload to Amazon Fire TV.For an overview of the structure of a CDF catalog file and how these elements interact, see About the Catalog Data Format (CDF) The catalog examples in the downloadable cdf-examples.zip file also can be very useful in understanding how a catalog file is put together. Download catalog.xsd to examine the XSD directly.To use this information, readers should have a good understanding of XML. The following sections list the CDF schema element definitions.  AdultProduct (deprecated)  AudioLanguage  CastMember  Catalog  Certification  Color  ContentRating  ContentRatings  Copyright  Count  Country  Credits  CrewMember  CustomerRating  Duration  EpisodeInSeason  EpisodeInSeries  ExternalID  Extra  FreeOffer  Genre  Genres  ID  ImageUrl  Job  JP_Require18PlusAgeConfirmation  Language  LaunchDetails  LaunchId  MaxValue  MiniSeries  MiniSeriesEpisode  MiniSeriesID  MiniSeriesTitle  Movie  Name  Offers  OriginalAirDate  Partner  Price  PurchaseOffer  Quality  Rank  Regions  RelatesToExternalID  RelatesToID  ReleaseCountry (deprecated)  ReleaseDate  ReleaseDate (deprecated)  ReleaseInfo (deprecated)  ReleaseYear  RentalOffer  Role  RuntimeMinutes  Score  SeasonID  SeasonInShow  SeasonTitle  ShortDescription  ShowID  ShowTitle  Source  Studio  Studios  SubscriptionOffer  Subtitle  Synopsis  System  Title  TvEpisode  TvSeason  TvShow  TvSpecial  Type  WindowEnd  WindowStart  WorksAdultProduct (deprecated)Deprecated, do not use. Use a ContentRating to convey this information instead. In Japan, you can also use JP_Require18PlusAgeConfirmation (CDF v1.2 and later).Identifies a work as content for adult audiences only.Optional:            Added      CDF version 1.0              Deprecated      CDF version 1.1              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None              Accepted values      true  false      Example:&lt;Movie&gt;false&lt;/Movie&gt;  ...  &lt;AdultProduct&gt;false&lt;/AdultProduct&gt;  ...&lt;/Movie&gt;false&lt;/Movie&gt;AudioLanguageAn audio option for the work when that work has been dubbed into additional languages. You can include as many AudioLanguage elements as needed to specify the work’s available alternatives.Optional:            Added      CDF version 1.0              Parent Elements      LaunchDetails              Child Elements      None              Attributes      None              Accepted values      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Example:&lt;LaunchDetails&gt;  &lt;Quality&gt;SD&lt;/Quality&gt;  &lt;Quality&gt;HD&lt;/Quality&gt;  &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;  &lt;AudioLanguage&gt;es-MX&lt;/AudioLanguage&gt;  &lt;Subtitle&gt;en-US&lt;/Subtitle&gt;  &lt;Subtitle&gt;es-MX&lt;/Subtitle&gt;  &lt;LaunchId&gt;MV123456_HD_es-MX_en&lt;/LaunchId&gt;&lt;/LaunchDetails&gt;CastMemberProvides information about a person in the work’s cast, such as an actor, host, narrator, or voice talent. When present, the optional Credits element must include at least one entry, either a CastMember or a CrewMember. You can include as many CastMember elements as needed.Required if no CrewMember element is present, otherwise optional:            Added      CDF version 1.0              Parent Elements      Credits              Child Elements      Name (required), ExternalID (optional), Role (optional)              Attributes      None      Example:&lt;Credits&gt;  &lt;CastMember&gt;    &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;    &lt;ExternalID scheme=\"imdb\"&gt;tt0000000&lt;/ExternalID&gt;    &lt;Role locale=\"en-US\"&gt;Self&lt;/Role&gt;  &lt;/CastMember&gt;&lt;/Credits&gt;CatalogThe root element of a CDF file. Each catalog file must contain a single Catalog element which contains the rest of the file.Required:            Added      CDF version 1.0                            Parent Elements      None                            Child Elements      Partner (required), Works (required)                            Attributes                                          Attribute      Accepted Values      Description                     xmlns      http://www.amazon.com/ FireTv/2014-04-11/ingestion      Required. The XML namespace.                     SchemaVersion      FireTv-v1.2  FireTv-v1.3      Optional. Added in CDF v1.2. The version of the schema this catalog uses. Refer to the schema “id” to figure out which schema version you are using. Although this attribute is optional for compatibility reasons, we recommend that you provide the version.      Example:&lt;xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;Catalog xmlns=\"http://www.amazon.com/FireTv/2014-04-11/ingestion\" version=\"FireTv-v1.3\"&gt;  &lt;Partner&gt;Everything Ever Made Filmworks&lt;/Partner&gt;  &lt;Works&gt;    ...  &lt;/Works&gt;&lt;Catalog&gt;CertificationThe certification or rating given to the work under a specified certification System. Only one Certification element is allowed for each ContentRating.Required in a ContentRating:            Added      CDF version 1.0              Parent Elements      ContentRating              Child Elements      None              Attributes      None      Example:&lt;ContentRating&gt;  &lt;System&gt;MPAA&lt;/System&gt;  &lt;Certification&gt;PG-13&lt;/Certification&gt;&lt;/ContentRating&gt;ColorSpecifies whether the movie is primarily in color or in black-and-white.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None              Accepted values      color black_and_white      Example:&lt;Movie&gt;  ...  &lt;Color&gt;black_and_white&lt;/Color&gt;  ...&lt;/Movie&gt;ContentRatingContains elements that specify a rating system or organization and the rating they gave the work. When present, the optional ContentRatings must contain at least one ContentRating. You can have as many ContentRating elements as you need, one for each system/rating pair.Required if the optional ContentRatings element is present:            Added      CDF version 1.0              Parent Elements      ContentRatings              Child Elements      System (required), Certification (required)              Attributes      None      Example:&lt;ContentRatings&gt;  &lt;ContentRating&gt;    &lt;System&gt;MPAA&lt;/System&gt;    &lt;Certification&gt;PG-13&lt;/Certification&gt;  &lt;/ContentRating&gt;&lt;/ContentRatings&gt;ContentRatingsContains one or more official ratings for the work, as determined by a specified certifying agency. Only one ContentRatings element is allowed per work.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      ContentRating (at least one required)              Attributes      None      Example:&lt;ContentRatings&gt;  &lt;ContentRating&gt;    &lt;System&gt;MPAA&lt;/System&gt;    &lt;Certification&gt;PG-13&lt;/Certification&gt;  &lt;/ContentRating&gt;  &lt;ContentRating&gt;    &lt;System&gt;Eirin&lt;/System&gt;    &lt;Certification&gt;R15+&lt;/Certification&gt;  &lt;/ContentRating&gt;&lt;/ContentRatings&gt;CopyrightA statement of the work’s copyright.Optional:            Added      CDF version 1.0                            Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description              locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.             Example:&lt;Copyright locale=\"en-US\"&gt;© 2014 Amazon Studios&lt;/Copyright&gt;CountThe number of users that have contributed to a customer rating Score. Only one Count is allowed per CustomerRating.Optional:            Added      CDF version 1.2              Parent Elements      CustomerRating              Child Elements      None              Attributes      None              Accepted values      Any non-negative whole number.      Example:&lt;CustomerRating&gt;  &lt;Score&gt;8.2&lt;/Score&gt;  &lt;MaxValue&gt;10&lt;/MaxValue&gt;  &lt;Count&gt;512&lt;/Count&gt;&lt;/CustomerRating&gt;CountryA country in which a particular offer (subscription, free, purchase, or rental) is available. Each offer can contain as many Country elements as needed.Required:            Added      CDF version 1.0              Parent Elements      Regions              Child Elements      None              Attributes      None              Accepted values      The following subset of ISO 3166-1 country codes: AF AX AL DZ AS AD AO AI AQ AG AR AM AW AU AT AZ BS BH BD BB BY BE BZ BJ BM BT BO BQ BA BW BV BR IO BN BG BF BI KH CM CA CV KY CF TD CL CN CX CC CO KM CG CD CK CR CI HR CU CW CY CZ DK DJ DM DO EC EG SV GQ ER EE ET FK FO FJ FI FR GF PF TF GA GM GE DE GH GI GR GL GD GP GU GT GG GN GW GY HT HM VA HN HK HU IS IN ID IR IQ IE IM IL IT JM JP JE JO KZ KE KI KP KR KW KG LA LV LB LS LR LY LI LT LU MO MK MG MW MY MV ML MT MH MQ MR MU YT MX FM MD MC MN ME MS MA MZ MM NA NR NP NL NC NZ NI NE NG NU NF MP NO OM PK PW PS PA PG PY PE PH PN PL PT PR QA RE RO RU RW BL SH KN LC MF PM VC WS SM ST SA SN RS SC SL SG SX SK SI SB SO ZA GS SS ES LK SD SR SJ SZ SE CH SY TW TJ TZ TH TL TG TK TO TT TN TR TM TC TV UG UA AE GB US UM UY UZ VU VE VN VG VI WF EH YE ZM ZW      Example:&lt;SubscriptionOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;    &lt;Country&gt;CA&lt;/Country&gt;  &lt;/Regions&gt;  ...&lt;/SubscriptionOffer&gt;CreditsContains elements that represent a work’s cast and crew members. The same person can appear as both cast or crew multiple times. Each work can contain only one Credits element. If present, Credits must contain at least one CastMember or CrewMember, though it can contain as many of each of those elements as needed.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      CastMember, CrewMember (at least one of these two is required)              Attributes      None      Example:&lt;Credits&gt;  &lt;CastMember&gt;    &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;    &lt;Role locale=\"en-US\"&gt;Self&lt;/Role&gt;  &lt;/CastMember&gt;&lt;/Credits&gt;CrewMemberContains elements that provide information about a person in the work’s off-screen crew, such as a director, writer, cinematographer, best boy, animator, or grip. When present, the optional Credits must include at least one entry, either a CastMember or a CrewMember. You can include as many CrewMember elements as needed.Required if no CastMember element is present, otherwise optional:            Added      CDF version 1.0              Parent Elements      Credits              Child Elements      Name (required), ExternalID (optional), Job (optional)              Attributes      None      Example:&lt;Credits&gt;  &lt;CrewMember&gt;    &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;    &lt;ExternalID scheme=\"imdb\"&gt;tt0000000&lt;/ExternalID&gt;    &lt;Job locale=\"en-US\"&gt;Director&lt;/Job&gt;  &lt;/CrewMember&gt;&lt;/Credits&gt;CustomerRatingContains elements that provide the average customer rating for a work, the maximum rating value, and the number of ratings that contributed to the score. Each work can contain only one CustomerRating element.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      Score (required), MaxValue (required), Count (optional, CDF v1.2 and later only)              Attributes      None      Example:&lt;CustomerRating&gt;  &lt;Score&gt;8.2&lt;/Score&gt;  &lt;MaxValue&gt;10&lt;/MaxValue&gt;  &lt;Count&gt;512&lt;/Count&gt;&lt;/CustomerRating&gt;DurationDefines how long a work’s rental lasts, measured in hours. A RentalOffer can contain only one Duration element.Required:            Added      CDF version 1.0              Parent Elements      RentalOffer              Child Elements      None              Attributes      None      Example:&lt;RentalOffer&gt;  ...  &lt;Duration&gt;120&lt;/Duration&gt;&lt;/RentalOffer&gt;EpisodeInSeasonA TV episode’s sequence number within its season. Each TvEpisode can contain only one EpisodeInSeason element.Required:            Added      CDF version 1.0              Parent Elements      TvEpisode              Child Elements      None              Attributes      None      Example:&lt;TvEpisode&gt;  ...  &lt;EpisodeInSeason&gt;6&lt;/EpisodeInSeason&gt;  ...&lt;/TvEpisode&gt;EpisodeInSeriesA mini-series episode’s sequence number within its series. Each MiniSeriesEpisode can contain only one EpisodeInSeries element.Required:            Added      CDF version 1.3              Parent Elements      MiniSeriesEpisode              Child Elements      None              Attributes      None              Example             &lt;MiniSeriesEpisode&gt;  ...  &lt;EpisodeInSeries&gt;13&lt;/EpisodeInSeries&gt;  ...&lt;/MiniSeriesEpisode&gt;ExternalIDAn identifier for a work under an external classification, such as IMDb. This value is used in content matching, to compare a work or person against that in another catalog to determine whether they’re the same work or person. It can also be used as the source of external content such as images. Each element that contains an ExternalID can contain as many as needed.Optional:            Added      CDF version 1.0                                   Parent Elements      CastMember, CrewMember, Extra, MiniSeries, MiniSeriesEpisode, Movie, TvEpisode, TvSeason, TvShow, TvSpecial                                   Child Elements      None                                   Attributes      Attribute      Description      Accepted Values                            scheme      Required. The external source that provided this ID.      imdb tmsisaneanupc                     Comments (the values represent these sources)                                                 Value      Description                                   imdb      The Internet Movie Database (IMDb). IDs can be found as part of the URL of a given page.                                   tms      The ID used in the Gracenote™ database.                                   isan      The International Standard Audiovisual Number (ISAN), an alphanumeric strings of 26 characters, usually presented broken by dashes.                                   ean      The International Article Number (EAN), a barcode normally expressed in 13-digits.                                   upc      The Universal Product Code (UPC), a barcode normally expressed in 12-digits.                    Example:&lt;Movie&gt;  &lt;ID&gt;MV123456&lt;/ID&gt;  &lt;ExternalID scheme=\"imdb\"&gt;tt0000000&lt;/ExternalID&gt;  &lt;ExternalID scheme=\"tms\"&gt;MV000000000000&lt;/ExternalID&gt;  &lt;ExternalID scheme=\"isan\"&gt;0000-0000-0F00-0000-X-0000-0000-Y&lt;/ExternalID&gt;  &lt;ExternalID scheme=\"ean\"&gt;0011559514120&lt;/ExternalID&gt;  &lt;ExternalID scheme=\"upc\"&gt;123456789990&lt;/ExternalID&gt;  ...&lt;/Movie&gt;ExtraOne of the basic work types, Extra represents a clip or trailer that can be a standalone work or, more commonly, can be associated with another work (either external or in your catalog). Generally think of these as the equivalent of an extra feature included on a DVD.Optional:            Added      CDF version 1.3              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to Extra      Required: Type  Required: Either RelatesToID or RelatesToExternalID, but not both              Attributes      None      Example:&lt;Extra&gt;  &lt;ID&gt;EXTRA-11111&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;Wishenpoof! Trailer&lt;/Title&gt;  &lt;Offers&gt;    &lt;FreeOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/FreeOffer&gt;  &lt;/Offers&gt;  &lt;Type&gt;trailer&lt;/Type&gt;&lt;/Extra&gt;FreeOfferOne of the four offer types. Under this offer, the work is free to view at any time, optionally only during a given window. If necessary, you can have multiple FreeOffer elements under Offers.Optional, though at least one offer type is required under Offers:            Added      CDF version 1.0              Parent Elements      Offers              Child Elements      Required: Regions  Optional: LaunchDetails, Quality (deprecated), WindowStart, WindowEnd              Attributes      None      Example:&lt;FreeOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;    &lt;Country&gt;CA&lt;/Country&gt;  &lt;/Regions&gt;  &lt;WindowStart&gt;2014-02-06T12:00:00-07:00&lt;/WindowStart&gt;  &lt;WindowEnd&gt;2016-01-01T07:00:00-07:00&lt;/WindowEnd&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;en-US&lt;/Subtitle&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;Subtitle&gt;es&lt;/Subtitle&gt;    &lt;LaunchId&gt;EXTRA-11113_HD_en-US&lt;/LaunchId&gt;  &lt;/LaunchDetails&gt;&lt;/FreeOffer&gt;GenreThe genre of the work, such as comedy, horror, drama, or documentary. A work can be described through multiple Genre elements if necessary. For optimized search and matching, attempt to use standard genre descriptions. Use multiple Genre tags rather than combine several descriptions into a single string.Required if the optional Genres element is present:            Added      CDF version 1.0                            Parent Elements      Movie                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;Genres&gt;  &lt;Genre locale=\"en-US\"&gt;horror&lt;/Genre&gt;  &lt;Genre locale=\"en-US\"&gt;sci-fi&lt;/Genre&gt;&lt;/Genres&gt;GenresContains one or more Genre tags used to describe the category of the work, such as comedy, horror, or documentary.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      Genre (at least one required when Genres is present)              Attributes      None      Example:&lt;Genres&gt;  &lt;Genre locale=\"en-US\"&gt;horror&lt;/Genre&gt;  &lt;Genre locale=\"en-US\"&gt;sci-fi&lt;/Genre&gt;&lt;/Genres&gt;IDAn identifier string for a work. This value must be at least one character long and unique among all other IDs in your catalog. Two works with the same ID will cause your catalog to be rejected by the ingestion system. Devise an ID scheme and use it unfailingly to avoid duplicate IDs. For instance, you could use your Partner ID + the work type + a long identifier such as a GUID, for an ID such as AmazonStudios_ Movie_01152ce2-de7e-44c1-9736-e8f3b15a1ddf. Any scheme that assures unique IDs within your catalog is valid.When you update an existing catalog, the IDs for your works should not change. If an ID disappears from your catalog, we assume that work is no longer available on your service and remove it from our index.Required:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None      Example:&lt;Movie&gt;  &lt;ID&gt;AmazonStudios_Movie_01152ce2-de7e-44c1-9736-e8f3b15a1ddf&lt;/ID&gt;  ...&lt;/Movie&gt;ImageUrlThe URL of an image that represents the work, sometimes called the “box art.” Each work can contain only a single ImageUrl element. If you don’t include ImageUrl, we attempt to use available art from other sources such as IMDb, or we might use a generic placeholder image. See About the CDF for image requirements. Note: Provide a unique image for each work that applies to the work’s content. Do not use a generic placeholder image, such as a logo.Optional (see Comments):            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None              Comments      Any one given ImageUrl element is optional, but at least 50% of your entries must include it and the image it points to must be valid. If more than 50% of the images in your file are determined to be invalid (and simply not having an image is considered an invalidity), your uploaded catalog will be rejected by the ingestion system. An image also helps us in matching this work with the same work from other providers, which improves the customer search experience by bundling all offers for the work into a single search result. That, in turn, improves the discoverability of your particular offer. See About the CDF for image size and height-to-width ratio requirements.      Example:&lt;TvShow&gt;  ...  &lt;ImageUrl&gt;http://amazon.com/images/01152ce2de7e44c1/image.jpg&lt;/ImageUrl&gt;  ...&lt;/TvShow&gt;JobThe position held by a work’s CrewMember, such as director, cinematographer, writer, or animator. A CrewMember can have as many Job elements as needed.Optional:            Added      CDF version 1.0                            Parent Elements      CrewMember                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;CrewMember&gt;  &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;  &lt;ExternalID scheme=\"imdb\"&gt;tt0000000&lt;/ExternalID&gt;  &lt;Job locale=\"en-US\"&gt;Grip&lt;/Job&gt;&lt;/CrewMember&gt;JP_Require18PlusAgeConfirmationMarks content for the Japanese marketplace intended to be viewed only by persons 18 years of age or older. In compliance with Japan’s legal requirements, setting this flag to true requires viewers of this content in Japan to confirm that their age is above 18.Optional:            Added      CDF version 1.2              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None              Accepted values      true  false      Example:&lt;Movie&gt;  ...  &lt;JP_Require18PlusAgeConfirmation&gt;true&lt;/JP_Require18PlusAgeConfirmation&gt;&lt;/Movie&gt;LanguageThe language in which the work was originally produced, which can refer to either the audio or, in the case of a silent work, on-screen text. A work can contain only one Language element. Also use AudioLanguage to specify any dubbed options.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None              Accepted values      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Example:&lt;Movie&gt;  ...  &lt;Language&gt;ja&lt;/Language&gt;  ...&lt;/Movie&gt;LaunchDetailsContains elements that specify a work’s available video quality, audio language, and subtitle options under a particular offer. LaunchDetails also contains an optional LaunchId which allows a direct launch of the work in a specific configuration of quality, language, and subtitle.Optional:            Added      CDF version 1.2              Parent Elements      SubscriptionOffer, FreeOffer, PurchaseOffer, RentalOffer              Child Elements      Quality (optional), AudioLanguage (optional), Subtitle (optional), LaunchId (optional)              Attributes      None      Example:&lt;FreeOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;SD&lt;/Quality&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;AudioLanguage&gt;fr-FR&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;en-US&lt;/Subtitle&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;Subtitle&gt;es&lt;/Subtitle&gt;    &lt;LaunchId&gt;EXTRA-11113_HD_en-US&lt;/LaunchId&gt;  &lt;/LaunchDetails&gt;&lt;/FreeOffer&gt;LaunchIdAn identifier that allows you to launch a work with a specific configuration of video quality, audio language, and subtitles (or any subset of those three). A LaunchId does not have a given format—the format must only be understood by your app’s logic. Each LaunchDetails element can contain only a single LaunchId, so to specify more than one LaunchId, you must include multiple LaunchDetails elements.Optional:            Added      CDF version 1.2              Parent Elements      LaunchDetails              Child Elements      None              Attributes      None      Example:&lt;SubscriptionOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;SD&lt;/Quality&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;AudioLanguage&gt;fr-FR&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;en-US&lt;/Subtitle&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;LaunchId&gt;EXTRA-11113_HD_en-US&lt;/LaunchId&gt;  &lt;/LaunchDetails&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;SD&lt;/Quality&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;AudioLanguage&gt;fr-FR&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;en-US&lt;/Subtitle&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;LaunchId&gt;EXTRA-11113_SD_fr-FR_en-US&lt;/LaunchId&gt;  &lt;/LaunchDetails&gt;&lt;/SubscriptionOffer&gt;MaxValueThe highest possible value for a work’s customer rating. Each CustomerRating can contain only one MaxValue.Required when the optional CustomerRating element is present:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None      Example:&lt;CustomerRating&gt;  &lt;Score&gt;8.2&lt;/Score&gt;  &lt;MaxValue&gt;10&lt;/MaxValue&gt;  &lt;Count&gt;512&lt;/Count&gt;&lt;/CustomerRating&gt;MiniSeriesOne of the basic work types, a MiniSeries is loosely defined as a television show that collects a small number of ordered episodes not presented in seasons. There is no explicit limit on the number of episodes a MiniSeries can contain, but it should be reasonably low.Optional:            Added      CDF version 1.3              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to MiniSeries      ReleaseDate (optional)              Attributes      None      Example:&lt;MiniSeries&gt;  &lt;ID&gt;MS-2329880&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;All the Best People&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;  &lt;ReleaseDate&gt;2005-04-29T20:00:00&lt;/ReleaseDate&gt;&lt;/MiniSeries&gt;MiniSeriesEpisodeOne of the basic work types, a MiniSeriesEpisode is a single episode in a MiniSeries. This content is not associated with a season and is sequenced in the context of the MiniSeries.Optional:            Added      CDF version 1.3              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to MiniSeriesEpisode      Required: EpisodeInSeries  Required: Either MiniSeriesID or MiniSeriesTitle, but not both  Optional: OriginalAirDate              Attributes      None      Example:&lt;MiniSeries&gt;  &lt;ID&gt;MS-123456789&lt;/ID&gt;  ...&lt;/MiniSeries&gt;&lt;MiniSeriesEpisode&gt;  &lt;ID&gt;MSE-2329880&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;The First Steps on a New Planet&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;  &lt;MiniSeriesID&gt;MS-123456789&lt;/MiniSeriesID&gt;  &lt;EpisodeInSeries&gt;1&lt;/EpisodeInSeries&gt;  &lt;OriginalAirDate&gt;2012-07-02T20:00:00&lt;/OriginalAirDate&gt;&lt;/MiniSeriesEpisode&gt;MiniSeriesIDUsed to specify the mini-series that an episode is a part of. The MiniSeries with this ID must be present in the same catalog as this MiniSeriesEpisode. You have the option of using MiniSeriesID or MiniSeriesTitle to specify the mini-series, but not both. MiniSeriesID should always be used when the mini-series is in your catalog. If it is not in your catalog, we advise you to create a MiniSeries entry to use.Required if no MiniSeriesTitle element is present:            Added      CDF version 1.3              Parent Elements      MiniSeriesEpisode              Child Elements      None              Attributes      None      Example:&lt;MiniSeries&gt;  &lt;ID&gt;MS-2329880&lt;/ID&gt;  ...&lt;/MiniSeries&gt;&lt;/MiniSeriesEpisode&gt;  ...  &lt;MiniSeriesID&gt;MS-2329880&lt;/MiniSeriesID&gt;  &lt;EpisodeInSeries&gt;3&lt;/EpisodeInSeries&gt;&lt;/MiniSeriesEpisode&gt;MiniSeriesTitleSpecifies which mini-series an episode is part of when that mini-series is not part of your catalog. MiniSeriesTitle is simply a string for use in the UI and is not required to match any existing title in your catalog. You have the option of using MiniSeriesID or MiniSeriesTitle to specify the mini-series, but not both. Use MiniSeriesTitle only in the absence of MiniSeriesID, which should be a rare occurrance.Required if no MiniSeriesID element is present:            Added      CDF version 1.3              Parent Elements      MiniSeriesEpisode              Child Elements      None              Attributes      None      Example:&lt;/MiniSeriesEpisode&gt;  ...  &lt;MiniSeriesTitle&gt;Cats, The Most Beautiful Creature&lt;/MiniSeriesTitle&gt;  &lt;EpisodeInSeries&gt;3&lt;/EpisodeInSeries&gt;&lt;/MiniSeriesEpisode&gt;MovieOne of the basic work types, Movie generally represents a feature-length film, though it can also be used for short films. This work can be a theatrical release or a made-for-TV movie.Optional:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to Movie      ReleaseDate (optional)              Attributes      None      Example:&lt;Movie&gt;  &lt;ID&gt;MV-123456&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;Chase the Prawns&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;  &lt;ReleaseDate&gt;2013-10-04T00:00:00&lt;/ReleaseDate&gt;&lt;/Movie&gt;NameThe name of a work’s cast or crew member. For a cast member, this is the person’s name and not their character’s name.Required in a CastMember or CrewMember element:            Added      CDF version 1.0                            Parent Elements      CastMember, CrewMember                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;CastMember&gt;  &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;  ...&lt;/CastMember&gt;OffersContains the offers through which a viewer can play a given work: for free, by having a subscription to the service, through rental, or through purchase. Each work type can contain only one Offers element, and that Offers element must contain at least one offer type.Required:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      SubscriptionOffer (optional), FreeOffer (optional), PurchaseOffer (optional), RentalOffer (optional)              Attributes      None      Example:&lt;Offers&gt;  &lt;FreeOffer&gt;    &lt;Regions&gt;      &lt;Country&gt;CA&lt;/Country&gt;    &lt;/Regions&gt;    &lt;WindowStart&gt;2014-02-06T12:00:00-07:00&lt;/WindowStart&gt;    &lt;WindowEnd&gt;2016-01-01T07:00:00-07:00&lt;/WindowEnd&gt;    &lt;LaunchDetails&gt;      &lt;Quality&gt;SD&lt;/Quality&gt;    &lt;/LaunchDetails&gt;  &lt;/FreeOffer&gt;  &lt;SubscriptionOffer&gt;    &lt;Regions&gt;      &lt;Country&gt;CA&lt;/Country&gt;    &lt;/Regions&gt;    &lt;LaunchDetails&gt;      &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;/LaunchDetails&gt;  &lt;/SubscriptionOffer&gt;&lt;/Offers&gt;OriginalAirDateThe date and time when a work was originally televised. The year portion of this value should match the ReleaseYear, if that optional element is present. This information is useful in matching this work to content in other catalogs. A match allows us to show a single listing for a work that shows all of its available sources rather than having multiple search results for same thing.Optional:            Added      CDF version 1.3              Parent Elements      TvEpisode, TvSpecial, MiniSeriesEpisode              Child Elements      None              Attributes      None              Accepted values      An XML dateTime value. This value takes the form YYYY-MM-DDThh:mm:ss where YYYY-MM-DD is the year, month, and date and hh:mm:ss is the hour, minute, and second. The ‘T’ separates the two portions. The entire value is required, from the year down to the second. If the time value is unknown to you, simply use 00:00:00. You can also add an offset from UTC to the end of the value to account for a particular time zone.      Example:&lt;TvSpecial&gt;  ...  &lt;OriginalAirDate&gt;2012-05-13T00:00:00&lt;/OriginalAirDate&gt;&lt;/TvSpecial&gt;PartnerIdentifies you as the provider of this catalog. There is no required format, but it should be human-readable. As a good convention, use your app’s name as it is seen in the Amazon Appstore. You might also use your full provider name. Each catalog file must contain a single Partner element.Required:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements      None              Attributes      None      Example:&lt;Catalog xmlns=\"http://www.amazon.com/FireTv/2014-04-11/ingestion\" version=\"FireTv-v1.3\"&gt;  &lt;Partner&gt;Everything Ever Made Filmworks&lt;/Partner&gt;  ...&lt;Catalog&gt;PriceThe cost to rent or purchase a work.Required in PurchaseOffer and RentalOffer:            Added      CDF version 1.0                            Parent Elements      PurchaseOffer, RentalOffer                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     currency      USD  GBP  JPY  EUR      Required. The currency in which the price is given. Only one currency can be specified per offer type: dollar, pound, yen, or euro.      Example:&lt;PurchaseOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;Price currency=\"USD\"&gt;1.99&lt;/Price&gt;&lt;/PurchaseOffer&gt;PurchaseOfferOne of the four offer types. Under this offer, the work can be purchased for a one-time payment to own and watch anytime. If necessary, you can have multiple PurchaseOffer elements under Offers. Optional, though at least one offer type is required under Offers:            Added      CDF version 1.0              Parent Elements      Offers              Child Elements      Required: Regions, Price  Optional: LaunchDetails, Quality (deprecated), WindowStart, WindowEnd              Attributes      None      Example:&lt;PurchaseOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;Subtitle&gt;es&lt;/Subtitle&gt;  &lt;/LaunchDetails&gt;  &lt;Price currency=\"USD\"&gt;1.99&lt;/Price&gt;&lt;/PurchaseOffer&gt;QualityThe visual quality of the work: standard definition (SD), high definition (HD), and ultra high definition (UHD). A work can be offered with multiple visual quality options. Note: There are two elements named Quality. The first, a direct child of each offer type, was deprecated in CDF v1.2. The second is a child of LaunchDetails, and therefore a grandchild of each offer type. This newer, non-deprecated Quality element is the one we discuss here, although other than their parent elements, the two are identical in form and content.Optional:            Added      CDF version 1.2              Parent Elements      LaunchDetails              Child Elements      None              Attributes      None              Accepted values      SD  HD  UHD      Example:&lt;FreeOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;Quality&gt;UHD&lt;/Quality&gt;  &lt;/LaunchDetails&gt;&lt;/FreeOffer&gt;RankA numerical popularity score relative to the other items in your catalog. The highest rank is defined as 1. How you determine the rankings is up to you, but it is acceptable for multiple items to have the same rank. A work can have only a single Rank element.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None      Example:&lt;TvShow&gt;  ...  &lt;Rank&gt;36&lt;/Rank&gt;  ...&lt;/TvShow&gt;RegionsContains the countries in which a given offer is available. Each offer type can contain only a single Regions element.Required:            Added      CDF version 1.0              Parent Elements      SubscriptionOffer, FreeOffer, PurchaseOffer, RentalOffer              Child Elements      Country (at least one required)              Attributes      None      Example:&lt;FreeOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;    &lt;Country&gt;CA&lt;/Country&gt;    &lt;Country&gt;MX&lt;/Country&gt;  &lt;/Regions&gt;&lt;/FreeOffer&gt;RelatesToExternalIDUsed to specify another work (such as a movie) with which an Extra (such as a trailer for that movie) is associated. RelatesToExternalID specifies an identifier by which that other work (such as the movie) is known in an external classificiation such as IMDb. RelatesToExternalID is used when the associated work is not a part of your catalog. You have the option of using RelatesToID or RelatesToExternalID to specify the association, but not both. Use RelatesToExternalID only in the absence of RelatesToID.Do not confuse RelatesToExternalID with ExternalID. ExternalID refers to the Extra itself, while RelatesToExternalID refers to the work that it’s associated with.Optional:            Added      CDF version 1.3                            Parent Elements      Extra                            Child Elements      None                            Attributes                                          Attribute      Description      Accepted Values                     scheme      Required. The external source that provided this ID.      imdb  tms  isan  ean  upc              Comments (the values represent these sources)                                          Value      Description                            imdb      The Internet Movie Database (IMDb). IDs can be found as part of the URL of a given page.                            tms      The ID used in the Gracenote™ database.                            isan      The International Standard Audiovisual Number (ISAN), an alphanumeric strings of 26 characters, usually presented broken by dashes.                            ean      The International Article Number (EAN), a barcode normally expressed in 13-digits.                            upc      The Universal Product Code (UPC), a barcode normally expressed in 12-digits.             Example:&lt;Extra&gt;  ...  &lt;Type&gt;trailer&lt;/Type&gt;  &lt;RelatesToExternalID scheme=\"imdb\"&gt;tt0000000&lt;/RelatesToExternalID&gt;  &lt;RelatesToExternalID scheme=\"tms\"&gt;MV000000000000&lt;/RelatesToExternalID&gt;  &lt;RelatesToExternalID scheme=\"isan\"&gt;0000-0000-0F00-0000-X-0000-0000-Y&lt;/RelatesToExternalID&gt;  &lt;RelatesToExternalID scheme=\"ean\"&gt;0011559514120&lt;/RelatesToExternalID&gt;  &lt;RelatesToExternalID scheme=\"upc\"&gt;123456789990&lt;/RelatesToExternalID&gt;&lt;/Extra&gt;RelatesToIDUsed to specify another work (such as a movie) with which an Extra (such as a trailer for that movie) is associated. The work with this ID must be present in the same catalog as this Extra. You have the option of using RelatesToID or RelatesToExternalID to specify the associated work, but not both. RelatesToID should always be used when the associated work is in your catalog.Optional:            Added      CDF version 1.3              Parent Elements      Extra              Child Elements      None              Attributes      None      Example:&lt;TvShow&gt;  &lt;ID&gt;TV123456&lt;/ID&gt;  ...&lt;/TvShow&gt;&lt;Extra&gt;  ...  &lt;Type&gt;trailer&lt;/Type&gt;  &lt;RelatesToID&gt;TV123456&lt;/RelatesToID&gt;&lt;/Extra&gt;ReleaseCountry (deprecated)Deprecated, do not use. This element has no replacement.The country that originally released the work.Optional:            Added      CDF version 1.0              Deprecated      CDF version 1.3              Parent Elements      ReleaseInfo (deprecated)              Child Elements      None              Attributes      None              Accepted values      The following subset of ISO 3166 country codes:  AF AX AL DZ AS AD AO AI AQ AG AR AM AW AU AT AZ BS BH BD BB BY BE BZ BJ BM BT BO BQ BA BW BV BR IO BN BG BF BI KH CM CA CV KY CF TD CL CN CX CC CO KM CG CD CK CR CI HR CU CW CY CZ DK DJ DM DO EC EG SV GQ ER EE ET FK FO FJ FI FR GF PF TF GA GM GE DE GH GI GR GL GD GP GU GT GG GN GW GY HT HM VA HN HK HU IS IN ID IR IQ IE IM IL IT JM JP JE JO KZ KE KI KP KR KW KG LA LV LB LS LR LY LI LT LU MO MK MG MW MY MV ML MT MH MQ MR MU YT MX FM MD MC MN ME MS MA MZ MM NA NR NP NL NC NZ NI NE NG NU NF MP NO OM PK PW PS PA PG PY PE PH PN PL PT PR QA RE RO RU RW BL SH KN LC MF PM VC WS SM ST SA SN RS SC SL SG SX SK SI SB SO ZA GS SS ES LK SD SR SJ SZ SE CH SY TW TJ TZ TH TL TG TK TO TT TN TR TM TC TV UG UA AE GB US UM UY UZ VU VE VN VG VI WF EH YE ZM ZW      Example:&lt;TvEpisode&gt;  ...  &lt;ReleaseInfo&gt;    &lt;ReleaseDate&gt;2002-02-20&lt;/ReleaseDate&gt;    &lt;ReleaseCountry&gt;BT&lt;/ReleaseCountry&gt;  &lt;/ReleaseInfo&gt;  ...&lt;/TvEpisode&gt;ReleaseDateThe date and time when the work was originally released to the public, or the first air date in the case of television. The year portion of this value should match the ReleaseYear, if that optional element is present. This information is particularly useful in matching this work to content in other catalogs. A match allows us to show a single listing for a work that shows all of its available sources rather than having multiple search results for same thing. Note: For the deprecated element of the same name, see ReleaseDate (deprecated).Optional:            Added      CDF version 1.3              Parent Elements      Movie, TvShow, MiniSeries              Child Elements      None              Attributes      None              Accepted values      An XML dateTime value. This value takes the form YYYY-MM-DDThh:mm:ss where YYYY-MM-DD is the year, month, and date and hh:mm:ss is the hour, minute, and second. The ‘T’ separates the two portions. The entire value is required, from the year down to the second. If the time value is unknown to you, simply use 00:00:00. You can also add an offset from UTC to the end of the value to account for a particular time zone.      Example:&lt;TvShow&gt;  ...  &lt;ReleaseDate&gt;2012-05-13T00:00:00&lt;/ReleaseDate&gt;&lt;/TvShow&gt;ReleaseDate (deprecated)Deprecated, do not use. Use ReleaseDate (same name, different location and data type) or OriginalAirDate instead.The date when the work was originally released to the public, or the first air date in the case of television. The year portion of this value should match the ReleaseYear, if that optional element is present. This information is particularly useful in matching this work to content in other catalogs. A match allows us to show a single listing for a work that shows all of its available sources rather than having multiple search results for same thing.Required in ReleaseInfo:            Added      CDF version 1.0              Deprecated      CDF version 1.3              Parent Elements      ReleaseInfo (deprecated)              Child Elements      None              Attributes      None              Accepted values      An XML date value. This value takes the form YYYY-MM-DD (year, month, and date).      Example:&lt;TvShow&gt;  ...  &lt;ReleaseInfo&gt;    &lt;ReleaseDate&gt;2012-05-13&lt;/ReleaseDate&gt;  &lt;/ReleaseInfo&gt;&lt;/TvShow&gt;ReleaseInfo (deprecated)Deprecated, do not use. For release date information, use ReleaseDate or OriginalAirDate as appropriate to the work type. Release country information is no longer used.Contains elements that specify a work’s country of release and release date.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      ReleaseDate (required, deprecated), ReleaseCountry (optional, deprecated)              Attributes      None      Example:&lt;TvEpisode&gt;  ...  &lt;ReleaseInfo&gt;    &lt;ReleaseDate&gt;2002-02-20&lt;/ReleaseDate&gt;    &lt;ReleaseCountry&gt;BT&lt;/ReleaseCountry&gt;  &lt;/ReleaseInfo&gt;  ...&lt;/TvEpisode&gt;ReleaseYearThe year in which the work was originally released to the public, or the first air date in the case of television. Note that this value should match the year given in the same work’s ReleaseDate or OriginalAirDate element.Optional, but highly recommended:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None              Comments      While this element is optional, we recommend that you include it. This value is particularly helpful in allowing us to match this work with the same work from other providers, which improves the customer search experience by bundling all offers for the work into a single search result. That, in turn, improves the discoverability of your particular offer.      Example:&lt;TvEpisode&gt;  ...  &lt;ReleaseYear&gt;1959&lt;/Releaseyear&gt;  ...&lt;/TvEpisode&gt;RentalOfferOne of the four offer types. Under this offer, the work can be viewed for a limited amount of time for a one-time payment. If necessary, you can have multiple RentalOffer elements under Offers.Optional, though at least one offer type is required under Offers:            Added      CDF version 1.0              Parent Elements      Offers              Child Elements      Required: Regions, Price, Duration  Optional: LaunchDetails, Quality (deprecated), WindowStart, WindowEnd              Attributes      None      Example:&lt;RentalOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;Subtitle&gt;es&lt;/Subtitle&gt;  &lt;/LaunchDetails&gt;  &lt;Price currency=\"USD\"&gt;1.99&lt;/Price&gt;  &lt;Duration&gt;120&lt;/Duration&gt;&lt;/RentalOffer&gt;RoleThe character’s name in a work, as played by a CastMember. Examples are Robin Hood, Sir Lancelot du Lac, Athena, or Self. Do not use “actor” (all CastMember entries are actors) or “unknown” for this value. A CastMember element can contain multiple Role elements if that person played multiple roles.Optional:            Added      CDF version 1.0                            Parent Elements      CastMember                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;Credits&gt;  &lt;CastMember&gt;    &lt;Name locale=\"en-US\"&gt;Alan Smithee&lt;/Name&gt;    &lt;ExternalID scheme=\"imdb\"&gt;tt0000000&lt;/ExternalID&gt;    &lt;Role locale=\"en-US\"&gt;Robin Hood&lt;/Role&gt;    &lt;Role locale=\"en-US\"&gt;Self&lt;/Role&gt;  &lt;/CastMember&gt;&lt;/Credits&gt;RuntimeMinutesThe overall running time of the content, in minutes. This is a non-negative number and is expected to be less than 2880, though there may be instances that legitimately exceed that value. Each work can have only one RuntimeMinutes element.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      None              Attributes      None      Example:&lt;TvEpisode&gt;  ...  &lt;RuntimeMinutes&gt;37&lt;/RuntimeMinutes&gt;  ...&lt;/TvEpisode&gt;ScoreAn average score (rating) for a work based on customer feedback. How you gather that information is up to you, as well as setting the MaxValue to give a scale to the rating system. You can add an optional Count of how many votes contributed to the Score. A CustomerRating can contain only a single Score.Required in CustomerRating:            Added      CDF version 1.0              Parent Elements      CustomerRating              Child Elements      None              Attributes      None              Example             &lt;CustomerRating&gt;  &lt;Score&gt;8.2&lt;/Score&gt;  &lt;MaxValue&gt;10&lt;/MaxValue&gt;  &lt;Count&gt;512&lt;/Count&gt;&lt;/CustomerRating&gt;SeasonIDThe ID of the season of which a TVEpisode is a part. The TVSeason with this ID must be present in the same catalog as this TvEpisode. You have the option of using SeasonID or SeasonInShow to specify the season, but not both. SeasonID should always be used when the season is in your catalog. If is not in your catalog, consider creating a TvSeason entry.Required if no SeasonInShow element is present:            Added      CDF version 1.0              Parent Elements      TvEpisode              Child Elements      None              Attributes      None              Example             &lt;TvSeason&gt;  &lt;ID&gt;SEA-2329880&lt;/ID&gt;  ...&lt;/TvSeason&gt;&lt;TvEpisode&gt;  ...  &lt;SeasonID&gt;SEA-2329880&lt;/SeasonID&gt;  ...&lt;/TvEpisode&gt;SeasonInShowThe number of a season that a TVEpisode is a part of, when that season is not part of your catalog. SeasonInShow is simply a number for use in the UI and is not required to match anything. You have the option of using SeasonID or SeasonInShow to specify the season, but not both. Use SeasonInShow only in the absence of SeasonID, which should be a rare occurrance.Required if no SeasonID element is present:            Added      CDF version 1.0              Parent Elements      TvEpisode              Child Elements      None              Attributes      None      Example:&lt;TvEpisode&gt;  ...  &lt;SeasonInShow&gt;2&lt;/SeasonInShow&gt;  ...&lt;/TvEpisode&gt;SeasonTitleA title for the season in which a TvEpisode appeared, such as “Season 2”. Note that if the corresponding TvSeason element is included in your catalog, this value is not required to match its Title, though it should. Each TvEpisode can have only one SeasonTitle.Optional:            Added      CDF version 1.0                            Parent Elements      TvEpisode                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;TvEpisode&gt;  ...  &lt;SeasonInShow&gt;2&lt;/SeasonInShow&gt;  &lt;SeasonTitle locale=\"en-US\"&gt;Season 2&lt;/SeasonTitle&gt;  ...&lt;/TvEpisode&gt;ShortDescriptionA two- or three-line description of a work’s content. Do not use information included elsewhere, such as the work’s title, for the ShortDescription. Each work can contain multiple ShortDescription elements for the purpose of providing localized descriptions. To provide a longer, more detailed description, use the Synopsis element.Optional:            Added      CDF version 1.0                            Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s l anguage setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;TvSpecial&gt;  ...  &lt;ShortDescription locale=\"en-US\"&gt;Alan shows us some trees and sings songs about them.&lt;/ShortDescription&gt;  ...&lt;/TvSpecial&gt;ShowIDUsed to tie a TvEpisode, TvSeason, or TvSpecial to a TvShow in your catalog. This value must match the ID value in a TvShow element. You have the option of using ShowID or ShowTitle to specify the show, but not both. Always use ShowID when the TvShow is in your catalog.Required in the absence of ShowTitle for TvEpisode and TvSeason:Optional for TvSpecial:            Added      CDF version 1.0              Parent Elements      TvSeason, TvEpisode, TvSpecial              Child Elements      None              Attributes      None              Accepted values             Example:&lt;TvShow&gt;  &lt;ID&gt;TV-2329880&lt;/ID&gt;  ...&lt;/TvShow&gt;&lt;TvSeason&gt;  ...  &lt;ShowID&gt;TV-2329880&lt;/ShowID&gt;  ...&lt;/TvSeason&gt;&lt;TvEpisode&gt;  ...  &lt;ShowID&gt;TV-2329880&lt;/ShowID&gt;  ...&lt;/TvEpisode&gt;ShowTitleUsed to tie a TvEpisode, TvSeason, or TvSpecial to a TvShow in your catalog. This value is simply a string for use in the UI and is not required to match any title in your catalog. You have the option of using ShowID or ShowTitle to specify the show, but not both. Use ShowTitle only in the absence of ShowID.Required in the absence of ShowID for TvEpisode and TvSeason:Optional for TvSpecial:            Added      CDF version 1.0                            Parent Elements      TvSeason, TvEpisode, TvSpecial                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;TvSeason&gt;  ...  &lt;ShowTitle locale=\"en-US\"&gt;Depth of Field&lt;/ShowTitle&gt;  ...&lt;/TvSeason&gt;SourceWhere the work originated. Each work can have only one Source.Optional:            Added      CDF version 1.0                     Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra                     Child Elements      None                     Attributes      None                     Accepted values      original  licensed  unknown  other                     Comments (the values represent these sources)                                   Value      Description                     original      The provider of this catalog produced or created this content.                     licensed      The provider of this catalog has licensed the work from another party.                     unknown      The source of this content is unknown.                     other      The source of the work is known but is neither original nor licensed.      Example:&lt;MiniSeriesEpisode&gt;  ...  &lt;Source&gt;licensed&lt;/Source&gt;  ...&lt;/MiniSeriesEpisode&gt;StudioThe studio that produced the work. A work can have multiple Studio entries.Required in the optional Studios element:            Added      CDF version 1.0              Parent Elements      Studios              Child Elements      None              Attributes      None              Example             &lt;TvEpisode&gt;  ...  &lt;Studios&gt;    &lt;Studio&gt;Amazon Studios&lt;/Studio&gt;    &lt;Studio&gt;Another Production Company&lt;/Studio&gt;  &lt;/Studios&gt;  ...&lt;/TvEpisode&gt;StudiosContains one or more Studio elements that identify the studio(s) that produced the work.Optional:            Added      CDF version 1.0              Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Child Elements      Studio (at least one required)              Attributes      None      Example:&lt;TvEpisode&gt;  ...  &lt;Studios&gt;    &lt;Studio&gt;Amazon Studios&lt;/Studio&gt;    &lt;Studio&gt;Another Production Company&lt;/Studio&gt;  &lt;/Studios&gt;  ...&lt;/TvEpisode&gt;SubscriptionOfferOne of the four offer types. Under this offer, the work can be watched by subscribers to the provider’s service. If necessary, you can have multiple SubscriptionOffer elements under Offers.Optional, though at least one offer type is required under Offers:            Added      CDF version 1.0              Parent Elements      Offers              Child Elements      Required: Regions  Optional: LaunchDetails, Quality (deprecated), WindowStart, WindowEnd              Attributes      None      Example:&lt;SubscriptionOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;    &lt;Country&gt;CA&lt;/Country&gt;  &lt;/Regions&gt;  &lt;WindowStart&gt;2014-02-06T12:00:00-07:00&lt;/WindowStart&gt;  &lt;WindowEnd&gt;2016-01-01T07:00:00-07:00&lt;/WindowEnd&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;en-US&lt;/Subtitle&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;Subtitle&gt;es&lt;/Subtitle&gt;    &lt;LaunchId&gt;EXTRA-11113_HD_en-US&lt;/LaunchId&gt;  &lt;/LaunchDetails&gt;&lt;/SubscriptionOffer&gt;SubtitleA language option for the work’s subtitles. A work can have multiple subtitle options.Optional:            Added      CDF version 1.2              Parent Elements      LaunchDetails              Child Elements      None              Attributes      None              Accepted values      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Example:&lt;SubscriptionOffer&gt;  &lt;Regions&gt;    &lt;Country&gt;US&lt;/Country&gt;  &lt;/Regions&gt;  &lt;LaunchDetails&gt;    &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;AudioLanguage&gt;en-US&lt;/AudioLanguage&gt;    &lt;Subtitle&gt;fr&lt;/Subtitle&gt;    &lt;Subtitle&gt;es&lt;/Subtitle&gt;  &lt;/LaunchDetails&gt;&lt;/SubscriptionOffer&gt;SynopsisA description of a work’s content. Synopsis is intended to give more detail than ShortDescription. Do not use the ShortDescription or the work’s Title as the Synopsis. Each work can contain multiple Synopsis elements for the purpose of providing localized descriptions.Optional:            Added      CDF version 1.0                            Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;TvSpecial&gt;  ...  &lt;ShortDescription locale=\"en-US\"&gt;Alan shows us some trees and sings songs about them.&lt;/ShortDescription&gt;  &lt;Synopsis locale=\"en-US\"&gt;Alan Smithee, man about town and fervent urban arborist, takes us on a    musical journey around his home town, stopping by some favorite trees to sing about them. As    expected from Mr. Smithee, no path runs straight and his plans meander as he encounters guest    stars and battles a lumberjack with a literal ax to grind.&lt;/Synopsis&gt;  ...&lt;/TvSpecial&gt;SystemThe rating system, normally an official organization, that determined a work’s rating. Each rating can have only one System.Required in ContentRating:            Added      CDF version 1.0              Parent Elements      ContentRating              Child Elements      None              Attributes      None      Example:&lt;ContentRatings&gt;  &lt;ContentRating&gt;    &lt;System&gt;MPAA&lt;/System&gt;    &lt;Certification&gt;G&lt;/Certification&gt;  &lt;/ContentRating&gt;&lt;/ContentRatings&gt;TitleA work’s title. Each work can contain multiple Title elements for the purpose of providing localized titles.Required:            Added      CDF version 1.0                            Parent Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra                            Child Elements      None                            Attributes                                          Attribute      Accepted Values      Description                     locale      Standard XML/HTML language codes, such as en, en-US, fr, or fr-FR      Required. The device or software’s language setting under which to use this string.                     pronunciation      String      Optional. Used when the element’s text is given in kanji. The expected sort order in Japanese is based on pronunciation (which cannot be determined from the kanji) rather than characters. The pronunciation attribute provides that information, typically using hiragana.      Example:&lt;TvShow&gt;  &lt;ID&gt;TV123456&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;Office Factor&lt;/Title&gt;  ...&lt;/TvShow&gt;TvEpisodeOne of the basic work types, a TvEpisode is a single episode of a TvShow, normally also associated with a TvSeason.Optional:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to TvEpisode      Required: ShowID or ShowTitle, but not both  Required: SeasonID or SeasonInShow, but not both  Required: EpisodeInSeason  Optional: SeasonTitle, OriginalAirDate              Attributes      None      Example:&lt;TvShow&gt;  &lt;ID&gt;ABC-123457&lt;/ID&gt;  ...&lt;/TvShow&gt;&lt;TvSeason&gt;  &lt;ID&gt;TVS-987654&lt;/ID&gt;  ...&lt;/TvSeason&gt;&lt;TvEpisode&gt;  &lt;ID&gt;TVE2329880&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;What's in a Name?&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;  &lt;ShowID&gt;ABC-123457&lt;/ShowID&gt;  &lt;SeasonID&gt;TVS-987654&lt;/SeasonInShow&gt;  &lt;EpisodeInSeason&gt;5&lt;/EpisodeInSeason&gt;&lt;/TvEpisode&gt;TvSeasonOne of the basic work types, a TvSeason is a single season of a TvShow. When a TvEpisode’s SeasonID value is the same as the TvSeason’s ID, that episode declares itself part of the season.Optional:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to TvSeason      Required: ShowID or ShowTitle, but not both  Required: SeasonInShow              Attributes      None      Example:&lt;TvShow&gt;  &lt;ID&gt;ABC-123457&lt;/ID&gt;  ...&lt;/TvShow&gt;&lt;TvSeason&gt;  &lt;ID&gt;TVS2329880&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;Season Five&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;  &lt;ShowID&gt;ABC-123457&lt;/ShowID&gt;  &lt;SeasonInShow&gt;5&lt;/SeasonInShow&gt;&lt;/TvSeason&gt;&lt;TvEpisode&gt;  ...  &lt;ShowID&gt;ABC-123457&lt;/ShowID&gt;  &lt;SeasonID&gt;TVS2329880&lt;/SeasonID&gt;  ...&lt;/TvEpisode&gt;TvShowOne of the basic work types, a TvShow is a televised series made up of seasons and episodes. It can also have associated specials outside of the regular sequence of episodes. When a TvSeason, TvEpisode, or TvSpecial’s ShowID value is the same as the TvShow’s ID, that season, episode, or special declares itself part of the show.Optional:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to TvShow      ReleaseDate (optional)              Attributes      None      Example:&lt;TvShow&gt;  &lt;ID&gt;RS-2329880&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;Office Factor&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;&lt;/TvShow&gt;&lt;TvSeason&gt;  &lt;ID&gt;TVS2329880&lt;/ID&gt;  ...  &lt;ShowID&gt;RS-2329880&lt;/ShowID&gt;  ...&lt;/TvSeason&gt;&lt;TvEpisode&gt;  ...  &lt;ShowID&gt;RS-2329880&lt;/ShowID&gt;  &lt;SeasonID&gt;TVS2329880&lt;/SeasonID&gt;  ...&lt;/TvEpisode&gt;TvSpecialOne of the basic work types, TvSpecial is used for televised events that don’t belong to the traditional show-season-episode television hierarchy. These can be one-time events such as a holiday special, or they can account for programs in which each episode has a unique airdate rather than an episode number (news programs, for instance). A TvSpecial can be associated with a TvShow (though not a TvSeason) or it can be a standalone event. Some other examples are awards programs, televised concerts, and retrospectives.Optional:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements Common to All Work Types      Required: ID, Offers, Title  Optional: AdultProduct (deprecated), Color, ContentRatings, JP_Require18PlusAgeConfirmation, Copyright, Credits, CustomerRating, ExternalID, Genres, ImageUrl, Language, Rank, ReleaseInfo (deprecated), ShortDescription, ReleaseYear, RuntimeMinutes, Source, Studios, Synopsis              Child Elements Specific to TvShow      Required: OriginalAirDate (added in CDF v1.3)              Optional: ShowID or ShowTitle, but not both (added in CDF v1.3)                     Attributes      None      Example:&lt;TvSpecial&gt;  &lt;ID&gt;SP-2329880&lt;/ID&gt;  &lt;Title locale=\"en-US\"&gt;Cheese: Friend or Enemy?&lt;/Title&gt;  &lt;Offers&gt;    &lt;SubscriptionOffer&gt;      &lt;Regions&gt;        &lt;Country&gt;US&lt;/Country&gt;      &lt;/Regions&gt;    &lt;/SubscriptionOffer&gt;  &lt;/Offers&gt;  &lt;OriginalAirDate&gt;2005-04-29T20:00:00&lt;/OriginalAirDate&gt;&lt;/TvSpecial&gt;TypeSpecifies an Extra as a trailer (preview) or a clip. You can regard anything that isn’t a trailer as a clip, though it might be something as extensive as a making-of documentary about the Extra’s associated Movie. Each Extra can have only one Type.Required:            Added      CDF version 1.3              Parent Elements      Extra              Child Elements      None              Attributes      None              Accepted values      clip  trailer      Example:&lt;Extra&gt;  ..  &lt;Type&gt;trailer&lt;/Type&gt;  ...&lt;/Extra&gt;WindowEndThe date and time after which the work will no longer be available under a particular offer. Each offer can have only one WindowEnd. Using WindowStart and WindowEnd, you can declare an offer to be available only for a specific window of time. After the time specified by WindowEnd, the offer is no longer presented to the viewer. If all offers have expired, the work itself is not shown to the viewer.Optional:            Added      CDF version 1.0              Parent Elements      SubscriptionOffer, FreeOffer, PurchaseOffer, RentalOffer              Child Elements      None              Attributes      None              Accepted values      An XML dateTime value. This value takes the form YYYY-MM-DDThh:mm:ss where YYYY-MM-DD is the year, month, and date and hh:mm:ss is the hour, minute, and second. The ‘T’ separates the two portions. The entire value is required, from the year down to the second. You can also add an offset from UTC to the end of the value to account for a particular time zone.              Comments      WindowsStart and WindowsEnd can be used together or separately to control a work’s availablility under an offer. • WindowsStart only: The work is available indefinitely from that time forward unless it is removed from the catalog. • WindowsEnd only: The work is available immediately, but only until that time. • WindowsStart + WindowsEnd: The work is available only in that window of time. • Neither WindowsStart nor WindowsEnd: The work is immediately available and always will be unless it is removed from the catalog      Example:&lt;FreeOffer&gt;  ...  &lt;WindowStart&gt;2014-02-06T12:00:00-07:00&lt;/WindowStart&gt;  &lt;WindowEnd&gt;2016-01-01T07:00:00-07:00&lt;/WindowEnd&gt;  ...&lt;/FreeOffer&gt;WindowStartThe date and time after which the work becomes available under a particular offer. Using WindowStart and WindowEnd, you can declare an offer to be available only for a specific window of time. Before and after that window, that offer is not shown to the viewer. If no offer is available at the time, the work itself is not shown to the viewer. Each offer can have only one WindowStart.Optional:            Added      CDF version 1.0              Parent Elements      SubscriptionOffer, FreeOffer, PurchaseOffer, RentalOffer              Child Elements      None              Attributes      None              Accepted values      An XML dateTime value. This value takes the form YYYY-MM-DDThh:mm:ss where YYYY-MM-DD is the year, month, and date and hh:mm:ss is the hour, minute, and second. The ‘T’ separates the two portions. The entire value is required, from the year down to the second. You can also add an offset from UTC to the end of the value to account for a particular time zone.              Comments      WindowsStart and WindowsEnd can be used together or separately to control a work’s availablility under an offer. • WindowsStart only: The work is available indefinitely after that time unless it is removed from the catalog. • WindowsEnd only: The work is available immediately, but only until that time • WindowsStart + WindowsEnd: The work is available only in that window of time • Neither WindowsStart nor WindowsEnd: The work is available immediately and always will be unless it is removed from the catalog      Example:&lt;FreeOffer&gt;  ...  &lt;WindowStart&gt;2014-02-06T12:00:00-07:00&lt;/WindowStart&gt;  &lt;WindowEnd&gt;2016-01-01T07:00:00-07:00&lt;/WindowEnd&gt;  ...&lt;/FreeOffer&gt;WorksContains all of the individual entriesin your catalog: movies, TV shows, seasons, specials, mini-series, episodes, and extras. Each catalog file must contain a single Works element. The Works element can contain as many work entries as needed, and as many of each type as needed. Note: In CDF v1.0 to v1.2, the Works element was required to contain at least a single work. As of CDF v1.3, it can be empty. This will have the effect of removing your catalog’s contents from Amazon Fire TV’s universal browse and search.Required:            Added      CDF version 1.0              Parent Elements      Catalog              Child Elements      Movie, TvShow, TvSeason, TvEpisode, TvSpecial, MiniSeries, MiniSeriesEpisode, Extra              Attributes      None              Accepted values             Example:&lt;Catalog&gt;  &lt;Partner&gt;Everything Ever Made Filmworks&lt;/Partner&gt;  &lt;Works&gt;    ...  &lt;/Works&gt;&lt;/Catalog&gt;",
        "url": "catalog-data-format-schema-reference.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "fire-tv-catalog-integration-faqs-html": {
        "title": "Fire TV Catalog Integration Frequently Asked Questions (FAQs)",
        "tags": "[]",
        "content": "This page contains some of the most Frequently Asked Questions (FAQs) related to Fire TV Catalog Integration (sometimes called Universal Browse and Search).  Getting Started with Fire TV Catalog Ingestion  User Experience  Creating the CDF file  Uploading and Publishing Your CDF File  Seasons, Episodes, and Other Content Types  Ingestion ReportsGetting Started with Fire TV Catalog Ingestion  Q: What is Fire TV catalog integration?  A: Catalog integration enables your catalog metadata to be included with other catalog data on the Fire TV platform. When a user searches for media or browses to a specific item in the Fire TV user interface, your content appears alongside the content from Amazon and from other providers and can be played directly. Catalog integration makes your content easier to find and more available to your viewers.  Q: What is the typical process for integrating my catalog with Fire TV?  A: Most apps typically use the following process for integrating their catalogs with Fire TV:          Export your data from a database and transform the data to a valid XML file that is formatted using our Catalog Data Format (CDF) schema. See About the Catalog Data Format, Fire TV Catalog Data Format (CDF) Schema, and download the XSD schema file: CDF Schema Definition. (If for whatever reason, you are unable to programmatically generate your CDF file, you can still create the XML file by hand, using the CDF schema as a template to help create your file. If your organization needs to create its CDF files by hand, Amazon recommends that you assign this task to a person within your org who is familiar and comfortable working with XML.)      Upload your CDF XML file to Amazon’s AWS S3 service. See Uploading Your Catalog.      Configure Fire TV’s home screen launcher to work with your uploaded catalog. This step also involves making a few changes to your app. See Integrating Your App with the Fire TV Home Screen Launcher. You can Testing Launcher Integration with ADB or Testing Fire TV Launcher Integration with the Integration Test App.        Q: How often should we go through this process of updating our catalog?  A: As a best practice, Amazon recommends resourcing an engineer or developer to automate the catalog export and upload process. Once automated, set the process to run weekly, regardless of whether there have been any catalog updates.  Q: Some of this sounds pretty technical. Who in my org should be handling this process?  A: Preferably, an engineer or IT professional will be handling the creation of and uploading of your CDF file. Amazon highly recommends having an engineer automate this process. If an engineer is unavailable, Amazon strongly recommends that the person creating and uploading the CDF file be comfortable working with XML and be comfortable executing commands using a command line interface.User Experience  Q: How does catalog integration drive traffic to my app?  A: Integrating your app’s catalog with Fire TV can drive traffic to your app in several ways:          Encourage new users to download your app and enroll in a free trial subscription (if applicable).      Increased opportunities to surface your content through browse and search.      Retaining existing customers through prioritized browse and search results that favor current subscribers.        For more benefits of catalog integration, see Understanding Fire TV Catalog Integration.    Q: When a user selects an episode or series through browse or search, where should playback start from?  A: For a good user experience, playback should start by deep linking directly to the episode or series from the search or browse result. The user should not be routed to your app’s home screen or anywhere else.  Q: When a user selects an episode or series, how immediately should playback begin?  A: Playback time can vary by app depending on buffering and other factors; however playback should begin directly after selection without any intermediate steps.Users should not be redirected to your app’s home screen or elsewhere before beginning playback.  Q: When playback completes, where should the user land?  A: Users should land in the same place that they would expect to land if they had reached the content through your app as opposed to from an integrated catalog. For some apps, the next episode begins playing automatically. For other apps, users are taken to their personal recommendations. Just keep your user experience consistent whether they access your content through Fire TV or from within your app.Creating the CDF file  Q: How do I create my CDF file?  A: Ideally, you would create this file programmatically by exporting your metadata to an XML file that fits the CDF format. To learn more about creating your CDF file, see Getting Started with Fire TV Catalog Integration and the About the Catalog Data Format.  Q: Ok, I’ve created my CDF file. Now what? Can I just upload it to AWS S3?  A: Amazon strongly recommends validating the XML in your CDF file before uploading it to AWS S3. If your CDF contains any poorly formed or invalid XML, the file will be rejected by Amazon.  Q: How do I validate my XML? Do you provide any utility that I can use to check my file before uploading?  A: Amazon does not provide a utility for validating CDF files; however, many of these utilities are easily available. If you are on a Mac or Linux, use xmllint to validate your CDF file. This utility should be pre-installed with your OS. (If you are on a Windows machine, you can use the Google project version of xmllint.Uploading and Publishing Your CDF File  Q: How do I upload my validated CDF file to Amazon?  A: To upload your CDF file, see Uploading Your Catalog to Amazon.  Q: What’s the maximum frequency at which we can publish a CDF file to our AWS S3 bucket?  A: Amazon does not have limits on publishing frequency; we adjust our ingestion pipeline as appropriate for the volume of uploaded files.  Q: After uploading it to my S3 buck, how soon can I expect my CDF file to be ingested?  A: Amazon retrieves new catalog uploads from partner S3 buckets every four hours. If your CDF file can be successfully ingested, it will be ingested at this time. If your CDF file fails ingestion, you’ll need to fix your file, re-upload, and wait for the next four hour pickup window. If your catalog update must be faster than this, please discuss this with your Amazon representative. Note that this four hour pickup window is subject to change.  Q: What is the delay between a CDF file upload and the content being available on the Fire TV device?  A: Typically content will be available to customers within 2-4 hours after the catalog is ingested; however, due to possible caching and other conditions, content may take as long as 72 hours to become available for some apps.  Q: Do we need to upload a full CDF file every time we update? Can we upload a CDF file that only includes new and updated data?  A: You need to provide the full CDF file with each upload. Amazon uses the full file to calculate what needs to be deleted. Additionally, having the full file helps ensure that Amazon’s catalog will not diverge from yours over time.  Q: What if we send several CDF updates within quick succession of each other? What happens if we produce CDF updates faster than Amazon can process them?  A: If you upload your CDF files faster than Amazon can process them, Amazon will just ignore the older copies and use the most recent file version. In other words, you cannot overload Amazon’s system by uploading an abundance of catalogs to the S3 system.  Q: Does Amazon provide any tools to test my catalog integration?  A: You can test your app’s integration with Amazon’s home screen launcher using the Android Debug Bridge (ADB). See Testing Launcher Integration with ADB. You can also download and Test Your Amazon’s test app, which simulates the requests made by Amazon’s home screen launcher and can be used to test your app’s integration with the launcher. See Testing Fire TV Launcher Integration with the Integration Test App. Additionally, to assist you with testing, we can whitelist specific Fire TV devices on request.  Q: Do I need to rename my CDF file every time that I upload a new version of it to S3? How does Amazon determine which CDF file to use if my S3 bucket contains multiple files?  A: Amazon uses timestamps to determine the newest version of your CDF file and will always ingest and use the most recent version.Seasons, Episodes, and Other Content Types  Q: I have a TV show with seasons and episodes. What content types should I use to categorize my show?  A: Use TVShow, TVSeason, and TVEpisode.  Q: I have a TV show with episodes that are sequential, but that do not have seasons. What content type should I use?  A: Use the MiniSeries and MiniSeriesEpisode types. You will need to specify values for EpisodeInSeries to represent the episode sequence.  Q: I have a TV show with sequential episodes, but that don’t have a sequence number. Instead of sequence number, these episodes are ordered by their air-date. Can I still use MiniSeries as my type? If not, which content type should I use?  A: Use the TVShow and TVSpecial types. In the TVSpecial, link it to the TVShow using the ShowID or ShowTitle fields, and include the mandatory air date.  Q: I have a news-type content where the episodes do not have seasons but do have an air date. What content type should I use?  A: Use the TVShow and TVSpecial types. In the TVSpecial, link it to the TVShow using the ShowID or ShowTitle fields, and include the mandatory air date.  Q: I have a show with seasons, but I do not have the actual values for the seasons. What should I do?  A: You are required to include season values for a show with seasons, which prevents a bad user experience. To obtain season information, try looking at  an authority catalog such as IMDb. Amazon usually recommends excluding season-based content that lacks season values, as opposed to trying to make the show fit into another content type. Omitting this content should help preserve a positive viewer experience for your users.  Q: We don’t have season or episode information for our series. What should I do? Should I just make up fake values?  A: Do not provide fake Season numbers and Episode numbers in your catalog. Instead, replace the TvEpisode entry type with TvSpecial. Continue to map the entries (TvSpecials) to the TVShow, so that they are associated with one another through the TvShow. However, note that in TvSpecials, OriginalAirDate is a required field. This allows us to better match (and use other sources to identify what the Season number and Episode number are) and to properly order the episodes in the TvShow.  Q: These all seem like an awful lot of rules to remember. How can I tell what to do without having to memorize every little nuance?  A: Generally, go by what your customers would expect. For example, if you have a TV series that is a talk show that airs nightly, your customers probably will not tend to think of that series as having seasons. In this case, air date is more important. However, if you have a popular series that tends to be binge-watched by users, season and episode number will likely be much more important to that viewer base.Ingestion Reports  Q: What is an ingestion report?  A: This report tells you whether your catalog was successfully integrated into Fire TV’s universal browse and search, and if not, why. After you upload your latest catalog, a new copy of the report is added to your S3 bucket as report.html, normally within four hours. You can use this report to troubleshoot issues in your catalog file. It contains the ingestion (integration) success or failure status plus any errors, warnings, and suggestions. See Receiving and Understanding the Fire TV Catalog Ingestion Report.  Q: How do I know if my uploaded catalog file was integrated into the system?  A: You can receive the ingestion results through an opt-in email, which also includes a link to download the full report.  Q: How do I get added to the email distribution list for my catalog’s ingestion results?  A: Send mail to p11-catalog-subscriptions@amazon.com asking to be added. Because the success and failure mail reports are separate email lists, ask to be added to both lists.  Q: My catalog ingestion failed. What do I do next?  A: Look at your ingestion report for the specific errors that caused the failure. Explanations and follow-up instructions for each error are given in the ingestion report documentation. If necessary, your Amazon Business Development Manager can help you work through problems with your catalog. See Catalog Data Format (CDF) Ingestion Report Messages.",
        "url": "fire-tv-catalog-integration-faqs.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "getting-started-catalog-integration-html": {
        "title": "Getting Started with Catalog Integration",
        "tags": "[]",
        "content": "This page provides an end-to-end walkthrough of the process for creating the catalog file required for Fire TV integration, submitting the file to Amazon, and making the required changes to your app for catalog integration.  Before You Begin  Integration Process Overview          Catalog Creation and Upload      Integration with the Amazon Fire TV Home Screen Launcher        Step 1: Creating Your CDF File          Creating the CDF file via Exporting and Transforming Your Data      Manually Creating your CDF File        Step 2: Validating Your CDF File  Step 3: Uploading Your CDF File to AWS S3  Step 4: Verifying the Uploaded CDF File  Step 5: Integrating Your App with the Fire TV Home Screen Launcher  Step 6: Testing Your App’s Integration with the Fire TV Home Screen LauncherBefore You BeginIf you aren’t familiar with the basic concepts of Fire TV Catalog Integration, see Understanding Fire TV Catalog Integration.Before starting the Catalog Integration process, make sure that you have or can easily obtain the following requirements:  Easy access to your app’s metadata: Most apps have someone export their metadata from a database; if you cannot export your metadata from a database, you will need to manually create your catalog file by hand.  An Amazon Web Services (AWS) account: You or someone in your organization will need an AWS account and familiarity with the AWS S3 tools or a willingness to learn about the AWS S3 tools. You will need to execute several AWS commands using the Command Line Interface (CLI) to upload your catalog file to AWS, so that Fire TV can obtain your catalog for integration. Amazon recommends using the AWS SDK to automate this process.  Access to your app’s source code: You will need to make a few small changes to your app’s source code to integrate your app and its content with the Fire TV home screen launcher. The person making the changes to your app’s source code should have a basic understanding of Android development.  Onboarding process and setup: It takes two weeks to set up our systems to provide you with a sandbox to test the catalog integration. Your Amazon business contact will also need to onboard you with the integration process. If you do not know who your Amazon business contact is, contact us.  Minimal fields for matching: To provide metadata for matching, you must supply some required and additional fields. The Title field is required. Additional fields (a minimum of 2 but ideally 3 or more) are also required. The additional fields can include the following:          ReleaseYear      Credits (Actor and Director)      RuntimeMinutes      SeasonInShow or SeasonID (the SeasonID must reference a valid season)      ShowTitle or ShowID      Integration Process OverviewCatalog Integration has two main components:  Catalog creation and upload  Integration of your app with the Amazon Fire TV Home Screen LauncherThe catalog creation and upload component is a multi-step process that can be simplified using automation. Consider allocating a developer resource to help script and set up a cron job to automate and simplify this process for your organization. You will need a second developer, preferably someone with Android development experience, to help integrate your app with the Amazon Home Screen Launcher.Development work on these two processes can take place in parallel. One component is not dependent on the other, although completion of both pieces is required for successful catalog integration.Catalog Creation and UploadThe following diagram shows the high-level steps for creating your media catalog file and uploading that file to AWS S3 storage:The catalog creation and upload process is as follows:  Create an XML file in Catalog Data Format (CDF) for your catalog metadata.  Validate your CDF file against the CDF schema (XSD) file.    Upload the CDF file to the Amazon Web Services (AWS) S3 catalog bucket that Amazon creates for you.  Review the Amazon-generated ingestion report to confirm that your CDF file was successfully ingested or to help troubleshoot an ingestion failure.Integration with the Amazon Fire TV Home Screen LauncherThe following diagram shows the high-level steps for integrating your app with the Amazon Fire TV Home Screen Launcher and testing that integration:  Modify your app’s code to integrate your app with the Amazon Fire TV home screen launcher.  Test your app’s integration with the launcher.Step 1: Creating Your CDF FileTo start, you will need to create a Catalog Definition Format (CDF) file that contains the metadata for your app’s content catalog. A CDF file is an XML file that adheres to the format defined by Amazon’s CDF schema.For information about the structure of the catalog file, see About the Catalog Data Format the Catalog Data Format Schema Reference, or download the CDF XSD file.You have two options for creating this file:  Use an automated process to create the file by exporting your data from a database, then transform that data to a compliant CDF XML file.  Manually create the CDF file.Creating the CDF file via Exporting and Transforming Your DataMost apps that integrate with Fire TV will be able to use an automated process to create the CDF file for the app’s catalog data.To use an automated process to create your CDF file:  Export your metadata from your app’s database. If necessary, ask a database administrator or support person within your org for help exporting the data. The fields that you export should be roughly equivalent to those defined by the CDF schema (see the About the CDF and Catalog Data Format Schema Reference.  Consulting the CDF documentation, write an XSLT transform to copy the exported data into an XML file that conforms to the CDF schema. Ask a developer for help, if necessary.Manually Creating your CDF FileIf your content catalog’s metadata is not stored in a database, or if for any reason, you cannot export and transform that data to an XML file, you will need to manually create your CDF file.To manually create your CDF file:  Familiarize yourself with XML and its concepts, if you are not already comfortable working with XML.  Download the CDF schema XSD file, which you can use as a template for your CDF file: CDF XSD file download.  Consulting the CDF documentation and using an XML editor (many are available for download from various sources), compose the CDF file for your app’s catalog data.Step 2: Validating Your CDF FileAmazon highly recommends validating your CDF file before uploading the file to AWS. Validating your file locally can help catch errors that would prevent the file from being successfully ingested and integrated with the Fire TV catalog. Validate your CDF file against the schema provided in Amazon’s CDF XSD file: CDF XSD file.Note that XML validation tools can only check that your XML is well-formed (for example, no broken or missing tags) and valid against the CDF schema (for example, no incorrectly nested elements). While XML validation should catch the most common errors in your CDF file, your CDF file could still contain errors that are not caught until the file is uploaded to AWS.Use an XML validation tool to validate your CDF file. While Amazon does not provide a CDF validation tool, you can easily obtain one at no cost from a variety of sources:  If you created or edited your CDF file using an IDE, your IDE might have a built-in XML validation tool.  On a Mac or Linux, use the xmllint utility. Your Mac or Linux computer should come with these utilities already installed as part of the OS.  On Windows, a number of free XML validation tools are available for download.To use xmllint to validate your CDF file:  Download the CDF XSD file and copy or move this file to the same directory as the CDF file that you previously created.  Open a terminal window (or a command window in Windows) to access your computer’s command line interface.      At the shell prompt, type the following command:    $ xmllint --schema catalog.xsd --noout &lt;cdf_file_name&gt;.xml        The $ represents the shell prompt. Replace &lt;cdf_file_name&gt; with the actual name of your CDF file. The --noout option suppresses extra output as xmllint traverses your XML file. When finished, xmllint will report any errors that it found in your file or will report that your XML file is valid against the specified schema.     Note: If you copy-and-paste any of the commands from these examples, make sure that the double hyphens (“--”) are not being auto-corrected to n-dashes by your browser or terminal editor.  Step 3: Uploading Your CDF File to AWS S3Once you have verified that your CDF file is valid, you can upload the CDF file to the S3 bucket that Amazon set up for your catalog using the following command:$ aws s3api put-object --body &lt;catalog_file_name.xml&gt; --bucket &lt;s3_bucket_name&gt; --key catalogs/catalog.xml --acl bucket-owner-full-control Note: Make sure that if you copy-and-paste this command into a terminal window that the “--” characters paste as double-dashes and not as an n-dash. Replace the text in angle brackets (&lt; &gt;) with the actual values for your file name and bucket.For detailed instructions, see Uploading Your Catalog to Amazon.Step 4: Verifying the Uploaded CDF FileAmazon posts a report to your catalog bucket indicating success or failure for the import of your catalog data each time that you upload a new CDF file. To learn more about this report and how to use it to troubleshoot CDF upload failures, see Receiving and Understanding the Catalog Ingestion Report.Step 5: Integrating Your App with the Fire TV Home Screen LauncherOnce you have a valid catalog that has been ingested by Amazon, you will need to make a few changes to your app’s source code to integrate your app with the Fire TV home screen launcher. The home screen launcher handles the following types of capabilities:  User sign-in  Universal browse and search  Playback of contentFor more detailed steps and examples for launcher integration, see Integrating Your App with the Fire TV Home Screen Launcher.To integrate your app with the Fire TV home screen launcher:  In your app’s source code, set up an Intent that contains the user’s subscription status and other information about your app:          In your app’s source code, construct a standard Android Intent that your app can use to broadcast your its capabilities.      Make sure that the app broadcasts the Intent any time that the app starts up, when the Intent is requested by the Fire TV launcher, or if your users’ subscription status changes.      Send the Intent using your app’s context.        In your code, add a class to receive capability requests from the Fire TV launcher.  Implement an Activity in your app to receive and handle playback and sign-in Intents from the Fire TV launcher.  Add the following elements to your app’s Android manifest:          An &lt;intent-filter&gt; element for playback and sign-in activities to recieve intents from the Fire TV launcher.      A &lt;receiver&gt; element with an android:name attribute that specifies the name of your BroadcastReceiver class and containing a child element of an &lt;intent-filter&gt; for the com.amazon.device.REQUEST_CAPABILITIES action.      A &lt;uses-permissions&gt; element to ensure that the Fire TV launcher accepts your Intents.      Step 6: Testing Your App’s Integration with the Fire TV Home Screen LauncherUse the test cases described in Test Cases for Verifying Fire TV Deep Links to formulate a test plan for your integrated app. Execute these step-by-step procedures to help verify your launcher integration.You have two options to test your app’s integration with Fire TV. Use these options to verify that you have made the correct changes to your app for Catalog Integration with Fire TV to function as expected:  Testing Launcher Integration with ADB: Use the Android Debug Bridge (ADB) utility to sideload your app onto a Fire TV device, and verify that your app responds correctly to sign-in and playback intents. Use this option when your app is fully developed and you have implemented the code to respond to launcher Intents for playback (see Integrating Your App with the Fire TV Home Screen Launcher. You can also use this option to verify content playback from your app.  Testing Fire TV Launcher Integration with the Integration Test App: Download and use the Test App provided by Amazon to test your app and verify that your app responds correctly to sign-in and playback intents. Use this option when you have not yet completed development on your app or have not yet implemented the code to respond to Intents from the launcher (see Integrating Your App with the Fire TV Home Screen Launcher).",
        "url": "getting-started-catalog-integration.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "integrating-your-catalog-with-fire-tv-html": {
        "title": "Integrating Your Catalog with Fire TV",
        "tags": "[]",
        "content": "Integrating your media catalog with Amazon Fire TV allows your content to be discovered and launched from the Fire TV home screen. Catalog Integration has two major components:  A catalog file that specifies the movies and TV shows that you offer through your app.  Integration between your app and the Fire TV Home Screen Launcher, which enables users to play your content directly from search and browse results.Catalog Integration allows your content to be included in the results of a search performed from the Fire TV home screen. It also allows a user to find your content while browsing Fire TV outside of your app, such as when browsing by genre (also known as “universal browse and search”). Regardless of where in the Fire TV UI users find your content, they can play it directly without needing to open your app first. Note: The information on these pages provides an introduction to Amazon’s catalog integration process. To begin your catalog integration with our platform, please contact us for further information. If your content qualifies for integration into the catalog, it takes two weeks to set up our systems to provide you with a sandbox to test the integration.  Resources in This Section  Changes to the Catalog Data Format (CDF) XML Schema          What’s New (10/2015): CDF v1.3      What’s New (5/27/2015) CDF v1.2        Older ResourcesResources in This SectionThese topics will teach you about Fire TV catalog and launcher integration. If you’re new to this, reading these topics in the given order is recommended.  Understanding Fire TV Catalog Integration: Introduction to Catalog Integration concepts.  Getting Started with Fire TV Catalog Integration: A quick-start guide to Fire TV catalog integration.  About the Catalog Data Format (CDF): An overview of the Catalog Data Format (CDF) catalog file that contains your content’s metadata.  Setting Up Your AWS Account for Fire TV Catalog Integration: One-time setup instructions for AWS.  Uploading Your Catalog to Amazon: Learn the process for configuring AWS and uploading your CDF file to our service.  Receiving and Understanding the Fire TV Catalog Ingestion Report: Learn about the reports on your catalog’s ingestion results.  Integrating Your App with the Fire TV Home Screen Launcher: How to modify your app to integrate subscription and playback information into the Amazon Fire TV launcher.  Test Cases for Verifying Fire TV Deep Links: Recommended test cases to run for testing launcher integration.  Testing Launcher Integration with ADB: Using the Android Debug Bridge to test your app’s integration with the launcher.  Testing Fire TV Launcher Integration with the Integration Test App: We provide a simple app with which you can test your app’s integration with the launcher.  Fire TV Catalog Integration Frequently Asked Questions: Frequently asked questions about Catalog Integration.Read these topics as needed:  Catalog Data Format (CDF) Ingestion Report Messages: Interpret the messages contained in the ingestion report and troubleshoot your CDF file.  Migrating a Catalog Data Format (CDF) File to the Latest Version: Step-by-Step instructions to adapt your catalog file to the latest CDF schema version.These documents can be used as a reference once you have a grasp of the overall catalog and launcher integration concepts.  Fire TV Catalog Data Format (CDF) Schema: Overall reference documentation for the Catalog Data Format XML schema definition (XSD).  Catalog Data Format (CDF) Schema Definition: The XSD file that defines the current CDF.  Catalog Data Format (CDF) Examples: Download a zip file that contains examples of CDF XML examples of individual media types as well as a full catalog, and examples showing how to tie shows, seasons, specials, extras, and episodes together.Changes to the Catalog Data Format (CDF) XML SchemaFrom time to time, the CDF schema, on which your catalog file is based, is updated to add new features. In rare cases, existing elements might be removed or altered. Check here for a summary of the latest changes. See Migrating a Catalog Data Format (CDF) File to the Latest Version) for more detailed information and instructions on how to use new elements.What’s New (10/2015): CDF v1.3  New tags &lt;MiniSeries&gt; and &lt;MiniSeriesEpisode&gt; for use with episode-like content that does not belong to the &lt;TVEpisode&gt; type. Amazon considers episodes that belong to both a &lt;TvSeason&gt; and &lt;TvShow&gt; as valid &lt;TVEpisode&gt; types. &lt;MiniSeriesEpisode&gt; is used for sequential, episodic content that doesn’t belong to a &lt;TvSeason&gt;. &lt;MiniSeriesEpisode&gt; entries need to have an order and you must provide sequence numbers for those episodes.  New tag &lt;TVSpecial&gt; for non-sequential or one-off episodes that might or might not belong to a &lt;TvShow&gt;. Each &lt;TVSpecial&gt; entry requires an &lt;OriginalAirDate&gt;, which Amazon uses to order the &lt;TVSpecial&gt; in relation to other entries. A &lt;TVSpecial&gt; can be linked to a &lt;TVShow&gt; without also having to link to a &lt;TVSeason&gt;.  New tag &lt;Extra&gt; to include trailers and clips. Trailers and clips can be associated with other content.  The &lt;ReleaseInfo&gt; element, containing the &lt;ReleaseDate&gt; and &lt;ReleaseCountry&gt; elements, is now deprecated. The &lt;ReleaseCountry&gt; information is no longer used. The &lt;ReleaseDate&gt; information is now specific to each work type. &lt;Movie&gt;, &lt;TvShow&gt;, and &lt;MiniSeries&gt; have a new &lt;ReleaseDate&gt; element. &lt;TvEpisode&gt;, &lt;TvSpecial&gt;, and &lt;MiniSeriesEpisode&gt; use &lt;OriginalAirDate&gt;. &lt;Extra&gt; does not have release date information.What’s New (5/27/2015) CDF v1.2  New tag &lt;JP_Require18PlusAgeConfirmation&gt; to indicate adult content in the Japanese marketplace.  New tag &lt;Count&gt; in RatingType to indicate the number of users who have contributed a rating.  The &lt;Role&gt; tag in ActorType is now optional.  The &lt;Quality&gt; element in each Offer type is now deprecated. Use the &lt;Quality&gt; element in &lt;LaunchDetails&gt; instead.  New tag &lt;LaunchDetails&gt; provides new content metadata that can be used by the Fire TV launcher, including &lt;Quality&gt;, &lt;AudioLanguage&gt; (for dubbed options), &lt;Subtitle&gt; (for alternate language subtitles), and &lt;LaunchId&gt; for a custom launch ID that includes these metadata.Older Resources  Catalog Data Format (CDF) Reference (version 1.2): Overall reference documentation for the Catalog Data Format XML schema definition (XSD).  Catalog Data Format (CDF) Schema Definition (version 1.2): The XSD file that defines the CDF format.  Catalog Data Format (CDF) Reference (version 1.1): Overall reference documentation for the Catalog Data Format XML schema definition (XSD).  Catalog Data Format (CDF) Schema Definition (version 1.1): The XSD file that defines the CDF format.  Catalog Data Format (CDF) Reference (version 1.0): Overall reference documentation for the Catalog Data Format XML schema definition (XSD).  Catalog Data Format (CDF) Schema Definition (version 1.0): The XSD file that defines the CDF format.",
        "url": "integrating-your-catalog-with-fire-tv.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "launcher-integration-html": {
        "title": "Integrating Your App with the Fire TV Home Screen Launcher",
        "tags": "[]",
        "content": "Modifying your app to be used with Amazon Fire TV’s home screen launcher integrates your media content and your users’ subscription statuses with other content in the Amazon Fire TV user interface. This process is also known as “deep linking” Amazon Fire TV’s content to your content. This deep linking is the other major piece (in addition to uploading your catalog) in integrating your app’s catalog with Fire TV.This page describes the required app changes to integrate your catalog with the Fire TV home screen launcher. After you have modified your app, test your integration before re-publishing your app. See Testing Launcher Integration with ADB and Testing Fire TV Launcher Integration with the Integration Test App for information.  Process Overview  Step 1: Broadcast An Intent From Your App Containing Its Capabilities          Types of Intents: Playback and Sign-in Intents      Building and Sending an Intent      Intent Extras      Examples        Step 2: Receive Capability Requests from the Launcher  Step 3: Handling Playback and Sign In Intents from the Launcher  Step 4: Add Error-handling Code to Deal with Sync Issues Between Your Catalog and Available Content  Step 5: Configure the Android Manifest          Add Intent Filters for Playback and Sign in      Add a Receiver for Launcher Requests      Add Permissions        Step 6: Test Your Launcher IntegrationProcess OverviewThere are five steps to integrate your app with the home screen launcher:  Broadcast an Android Intent that contains the user’s subscription status and other information about your app’s capabilities.  Receive capability requests from the launcher and respond with the same information in Step 1.  Receive playback or sign in requests from the launcher.  Add error-handling code to deal with sync issues between your catalog and available content.  Configure your Android manifest to handle all of these changes.  Validate your launcher integration.  Re-publish your updated app to make your changes available to your user base.Your app is still responsible for:  Playback and sign-in Activities and behavior.  Management of users’ subscription status with your service.Step 1: Broadcast An Intent From Your App Containing Its CapabilitiesTo play your content, the Fire TV home screen launcher needs user information from your app to be able to later play your content or to request that the user sign in to your service. Your app must send this information as an Android broadcast Intent at these times:  Each time your app starts up.  When the launcher requests it (see Step 2).  When your user’s subscription status changes, for example, if they sign into or out of your service.Types of Intents: Playback and Sign-in IntentsFor Fire TV Launcher integration and deep-linking, create two different types of Android Intents, which your app will need to broadcast:  Sign-In Intents: Broadcast a sign-in Intent if the current user is not signed in to your app.  Playback Intents: Broadcast a playback Intent if the current user is already signed in to your app, such as when a user has just signed in to or activates your app.Use these two Intent types to communicate your app’s capabilities to Amazon Fire TV.Building and Sending an IntentTo broadcast your app’s capabilities, build a standard Android Intent, and send it to the app’s context with the sendBroadcast() method. When you construct your Intent:  Name the Intent package com.amazon.tv.launcher.  Set the Intent action to com.amazon.device.CAPABILITIES.  Specify all other Intent information as Intent extras.The following example shows a sample BroadcastCapabilities() method that broadcasts different Intent extras based on a Boolean userIsSignedIn variable. All values in this example are sample data and must be replaced with your own values.public void BroadcastCapabilities(Context context){    Intent intent = new Intent();    intent.setPackage(\"com.amazon.tv.launcher\");    intent.setAction(\"com.amazon.device.CAPABILITIES\");    if (userIsSignedIn) {        intent.putExtra(\"amazon.intent.extra.PLAY_INTENT_ACTION\",\"android.intent.action.VIEW\");        intent.putExtra(\"amazon.intent.extra.PLAY_INTENT_PACKAGE\",\"com.contentcompany.player\");        intent.putExtra(\"amazon.intent.extra.PLAY_INTENT_CLASS\",\"com.contentcompany.player.PlayActivity\");        intent.putExtra(\"amazon.intent.extra.PLAY_INTENT_FLAGS\", Intent.FLAG_ACTIVITY_NEW_TASK | Intent.MORE_FLAGS);    } else {        intent.putExtra(\"amazon.intent.extra.SIGNIN_INTENT_ACTION\",\"android.intent.action.VIEW\");        intent.putExtra(\"amazon.intent.extra.SIGNIN_INTENT_PACKAGE\",\"com.contentcompany.player\");        intent.putExtra(\"amazon.intent.extra.SIGNIN_INTENT_CLASS\",\"com.contentcompany.player.SignInActivity\");        intent.putExtra(\"amazon.intent.extra.SIGNIN_INTENT_FLAGS\", Intent.FLAG_ACTIVITY_NEW_TASK | Intent.MORE_FLAGS);    }    intent.putExtra(\"amazon.intent.extra.PARTNER_ID\",\"contentcompany\");    //Send the intent to the Launcher    context.sendBroadcast(intent);}Intent ExtrasSpecify the capabilities of your app in the keys and values of the extras field, using the Intent.putExtra() method. All of the Intent extras have a prefix package of amazon.intent.extra.The following table shows the all required Intent extras and the specific extras for playback and sign-in. All of the Intent extra values are prefixed with amazon.intent.extra.            PARTNER_ID      Always      Your Partner ID (supplied by Amazon) is the same ID that you use for catalog integration in the Partner field of your CDF file. Note that this ID is unique to your app, not to an individual or organization; if you or your organization has multiple Fire TV apps, each app will all have different Partner IDs.              DATA_EXTRA_NAME      Conditional      The name of the extra containing the content ID for your data, for example, titleData. Specify this value only if your content ID is not described by a URI. If your content ID is not in URI format (for example, 123456), use DATA_EXTRA_NAME to indicate the name of the Intent extra the launcher should use for that ID. See Step 3 for more information. Access that content ID with the Intent.getStringExtra() method.              PLAY_INTENT_ACTION      If user is signed in      For playback Intents, the Intent action the launcher sends, usually android.intent.action.VIEW.              PLAY_INTENT_PACKAGE      If user is signed in      For playback Intents, the package for your app, for example com.contentcompany.player.              PLAY_INTENT_CLASS      If user is signed in      For playback Intents, the full package and class name of your app, for example, com.contentcompany.player.PlayActivity.              PLAY_INTENT_FLAGS      If user is signed in      For playback Intents, any flags your app needs from the Intent, as an integer. See the Android reference guide for Intent for possible flag values.              SIGNIN_INTENT_ACTION      If user is signed out      For sign in Intents, the Intent action the launcher sends, usually android.intent.action.VIEW.              SIGNIN_INTENT_PACKAGE      If user is signed out      For sign in Intents, the package for your app, for example com.contentcompany.player.              SIGNIN_INTENT_CLASS      If user is signed out      For sign in Intents, the class name of your app, for example, SignInActivity.              SIGNIN_INTENT_FLAGS      If user is signed out      For sign in Intents, any flags your app needs from the Intent, as an integer. See the Android reference guide for Intent for possible flag values.      Two extras are always required:  Your Amazon-provided partner ID (PARTNER_ID). This is the same ID you use for catalog integration.  The display name of your app (DISPLAY_NAME). The display name is used by the launcher to label the playback or sign in button on a given title.The remainder of the Intent extras vary based on whether or not the user is authorized to play your content (they are signed in), or if they need to sign in before proceeding.  If the user is signed in, extras with the PLAY_ prefix are required.  If the user is not signed in, extras with the SIGNIN_ prefix are required.ExamplesFor example, when a user signs in or activates your app, send an Intent with the following extras:  PARTNER_ID  DISPLAY_NAME  PLAY_INTENT_ACTION  PLAY_INTENT_PACKAGE  PLAY_INTENT_CLASS  PLAY_INTENT_FLAGSIn another example, if the launcher requests your app’s capabilities, and the user is not signed in, send an Intent with the following extras:  PARTNER_ID  DISPLAY_NAME  SIGNIN_INTENT_ACTION  SIGNIN_INTENT_PACKAGE  SIGNIN_INTENT_CLASS  SIGNIN_INTENT_FLAGSDo not provide both sets of Intent extras at once; the launcher assumes that the existence of PLAY_ keys means that the user is authorized to view your content.If your app has multiple subscription levels (for example, free, basic, premium), you can provide multiple sets of broadcast Intents for each level with different values of PARTNER_ID and DISPLAY_NAME.Step 2: Receive Capability Requests from the LauncherAmazon Fire TV’s home screen launcher occasionally requests your app’s capabilities and the subscription status of the user. The launcher requests this information with an Android broadcast Intent, whose action is com.amazon.device.REQUEST_CAPABILITIES. Your app must respond to this request with the same Intent that you previously created in Step 1. Note: Do not wait for the launcher to make a request. As described in Step 1, you must send your app’s capabilities information each time your app starts up and if the user’s subscription status changes.The following example shows a simple class to handle the launcher’s broadcast Intent. The capability information you send to the launcher is the same information you send in Step 1, so you can use the same method (here, broadcastCapabilities()) to manage both those tasks.public class CapabilityRequestReceiver extends BroadcastReceiver{   @Override public void onReceive(Context context, Intent intent)   {      broadcastCapabilities(); //the method you use to broadcast your app's information to the launcher   }}Step 3: Handling Playback and Sign In Intents from the LauncherWhen the user views the details for your content in the Fire TV user interface, Fire TV shows different options based on the user’s status with your service:  If the user is logged into your service (you provided PLAY_ intent extras in the capabilities broadcast), a button labeled with the display name of your app appears (for example, “MyCompany Player”). If the user chooses that button, the launcher sends a playback intent to your app.  If the user is not logged in (you provided SIGNIN_ intent extras) a button labeled “Launch” with the display name of your app appears (“Launch MyCompany Player”). If the user chooses that button, the launcher sends a sign in intent to your app.In both cases, the launcher uses the information you provided in the capabilities broadcast to construct both playback and sign in intents it sends your app.To handle either playback or signin intents, implement an activity in your app to receive and handle those intents and to play the requested content. Note: In handling these intents, your app must begin playback immediately (or immediately after the user signs in). Do not display an additional details page or other type of landing page in your app.This code shows the skeleton of a playback activity:public class PlayActivity extends Activity {   @Override   public void onCreate(Bundle bundle) {      super.onCreate(bundle);      Uri data = getIntent().getData();      //Play the content specified by 'data'      // OR      String data = getIntent.getStringExtra(\"titleExtra\");      //Play the content specified by the extra you indicated in DATA_EXTRA_NAME   }}Both the playback and signin intents include the ID of the requested content to enable your app to play that content immediately (playback intents) or after the user signs in (sign in). You specify the IDs and the ID format in your media catalog as part of catalog integration.If your content IDs are in URI format (for example, myapp://Media/123456), the launcher sends that URI as part of the intent data (Intent.getData()). If your content ID is not in URI format (for example, 123456), the launcher sends that ID in the extra you specified in DATA_EXTRA_NAME as part of the capabilities broadcast. You can access that content ID with the Intent.getStringExtra() method. Note: The launcher only sends the data that you specify in your CDF catalog, and we do not require that ID to be in any specific format. Make sure that the IDs you specify in your catalog are in the same format that your app expects for playback, or in a format your app can use.If users press the Back button consecutively (usually 3 times if starting from a media playback scenario), the app should ultimately return users to the last location where the users entered the application. In this case, the Search Results in the Launcher.Step 4: Add Error-handling Code to Deal with Sync Issues Between Your Catalog and Available ContentOne common issue that many Fire TV-integrated apps face is the occasional issue of their catalogs becoming out-of-sync with the actual content that is available. If a user selects a content item via search or browse, and that items is not actually available to play, the user will be taken to a black screen with no clear way to navigate out. This experience can be very frustrating for users and reflect negatively on accessing your app through Fire TV.This syncing issue can happen for several reasons:  You just uploaded a new catalog and it was successfully ingested in the window of a few hours before the actual content was available to play.  You rotated out some of your content, and an updated catalog reflecting these changes has not been uploaded/ingested yet.To prevent users from encountering the black screen after selecting an unavailable piece of content, Amazon recommends implementing error-handling code in your app. This code should address the use case where a user tries to select unavailable content, provides a meaningful error message to the user, and re-directs them to an appropriate location. This type of graceful failure should lead to a more positive user experience for your customers.Step 5: Configure the Android ManifestConfigure your Android manifest to handle broadcast Intents from the launcher. Specifically, you’ll need to add three things:  Add Intent filters to handle playback and sign-in Intents.  Add a receiver for the launcher’s capabilities to request Intent.  Add a permission to enable your Intents to be sent with the right permissions. Note: Declaring the broadcast in your manifest is mandatory for Fire TV to detect that the app has catalog integration enabled.Add Intent Filters for Playback and Sign inAdd Intent filters for your playback and sign in activities to receive Intents from the launcher. This example uses a playback activity named PlayActivity:&lt;activity    android:name=\".PlayActivity\"    android:label=\"Playback Activity\"&gt;    ...    &lt;intent-filter&gt;        &lt;action android:name=\"com.contentcompany.player.PlayActivity\"&gt;        &lt;category android:name=\"android.intent.category.DEFAULT\"&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;Add a Receiver for Launcher RequestsAdd a receiver element to the manifest with the name of your BroadcastReceiver class, and an intent-filter for the action com.amazon.device.REQUEST_CAPABILITIES. In this example the receiver class is CapabilityRequestReceiver:&lt;receiver android:name=\"CapabilityRequestReceiver\" &gt;    &lt;intent-filter&gt;    &lt;action android:name=\"com.amazon.device.REQUEST_CAPABILITIES\" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;Add PermissionsAdd a uses-permission element to your manifest to ensure that the launcher accepts your intents:&lt;uses-permission android:name=\"com.amazon.device.permission.COMRADE_CAPABILITIES\" /&gt;Step 6: Test Your Launcher IntegrationOnce you have integrated your app with Fire TV’s Home Screen Launcher, you will need to validate your launcher integration before submitting your app to the Amazon Appstore:See Test Cases for Verifying Fire TV Deep Links for a flow of test cases to run through before submitting your app.",
        "url": "launcher-integration.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "migrating-a-cdf-file-to-the-latest-version-html": {
        "title": "Migrating a Catalog Data Format (CDF) File to the Latest Version",
        "tags": "[]",
        "content": "This page describes changes involved in each version of the Fire TV CDF schema beginning with v1.0, and gives a series of steps to follow to update a catalog file to the latest version.  Migration Overview  Migrating from CDF v1.0 to v1.1          To update a CDF file from v1.0 to v1.1        Migrating from CDF v1.1 to v1.2          To update a CDF file from v1.1 to v1.2        Migrating from CDF v1.2 to v1.3Migration OverviewAmazon Fire TV occasionally updates its Catalog Data Format (CDF) XML schema to accept new metadata, remove unused information, or clarify the catalog structure. These changes do not cause existing CDF files to become invalid, but some data in older tags might be ignored or used in new ways, and deprecation warnings will appear in the [ingestion report][receiving-and-understanding-the-catalog-ingestion-report].In the future, Amazon could potentially stop supporting older schemas. For the best customer experience, Amazon recommends always creating your catalog file against the latest CDF schema version.How and where you make these changes depends on how you create your catalog file. If you have code that pulls the information from a database and transforms it into a CDF file, you’ll need to change the transformation code. If your database is structured to match the CDF, you’ll need to alter the fields of the database itself.Upgrade your CDF file in stages (v1.0 to v1.1, v1.1 to v1.2, etc.), accounting for each version change in turn. It is a linear progression that varies only in where you start. If you don’t know which CDF version your file uses, start from the beginning. The changes between versions are mostly additions of new optional elements, so simply adapting your current file as-is to a new schema version requires very few alterations, generally just one or two per version.Some XML elements must be placed in your catalog file in a specific order defined by the CDF XSD file. An element that’s out of order makes the catalog file invalid. Refer to the appropriate XSD file if you have any question about element order.  CDF XSD Version 1.0  CDF XSD Version 1.1  CDF XSD Version 1.2  CDF XSD Version 1.3Also look at the downloadable example CDF files (ZIP).This topic assumes that you are familiar with XML and the [CDF schema][about-the-cdf].Migrating from CDF v1.0 to v1.1Here are the differences between CDF v1.0 and v1.1:                      Item      Type      Change      Notes                  WorkType.Source      Element      Added      Optional. Specifies the origin of the work. Accepted values are:       original: A work produced by your company. For example, Amazon would specify this value for the Amazon original series Transparent.      licensed: A work that your company licensed from another source.      other: The original source is known, but can’t be classified as original or licensed.      unknown: The original source is not known.                    WorkType.AdultProduct      Element      Deprecated      This value is no longer used and the element should be removed. Adult content can be identified through the ContentRatings element. In Japan, you can use the JP_Require18PlusAgeConfirmation element added in v1.2.      To update a CDF file from v1.0 to v1.1  Remove all instances of WorkType.AdultProduct.  Optional: Add the Source element to all work elements (Movie, TvShow, TvEpisode, TvSpecial, TvSeason, MiniSeries, MiniSeriesEpisode, and Extra). Placement of the Source element varies by work type; see the XSD for correct placement.Migrating from CDF v1.1 to v1.2Here are the differences between CDF v1.1 and v1.2:                      Item      Type      Change      Notes              Catalog.version      Attribute      Added      Optional. Use this attribute so that others who work with the file will know which CDF version it was created against. Accepted values are FireTv-v1.2 and FireTv-v1.3              OfferType.LaunchDetails      Element      Added      Optional. Includes these child elements in the given order.            Quality: Optional. This is the new location of the OfferType.Quality element used to specify video quality. It is otherwise identical to the older version. Accepted values are SD, HD, and UHD.       AudioLanguage: Optional. A language option for the work’s original or dubbed audio.      Subtitle: Optional. A language option for the work’s subtitles.       LaunchId: Optional. An identifier used to launch this content with a specified quality, audio, and subtitle combination. This lets you use a single identifier for content that differs in audio encoding (dubbing), visual quality, and subtitle language, but otherwise shares the same metadata. There is no specific format to this string; it only needs to be understood by your app. Each instance of LaunchDetails can contain as many Quality, AudioLanguage, and Subtitle elements as necessary, but only one LaunchId. To specify a different LaunchId, create another copy of the LaunchDetails element. See the example below.                    OfferType.Quality      Element      Deprecated/Moved      This element is now a child element of OfferType.LaunchDetails (see above). It can be moved to the new location otherwise unchanged.              CustomerRating.Count      Element      Added      Optional. Allows you to specify the number of ratings from which the final rating was averaged. Placed as the last element under CustomerRating.              JP_Require18PlusAgeConfirmation      Element      Added      Optional. Only used by Japanese content providers. Accepted values are true and false. When true, viewers of this content in Japan are presented with a dialog in which they must confirm that their age is 18 or above, in accordance with Japanese law. This element should, at a minimum, be added it to those works that Japanese regulators regard as not to be viewed by anyone under 18. This element’s placement depends on the work type.              CastMember.Role      Element      Now optional      This element, which specifies the name of the character played by the cast member, was required in v1.1 but can now be omitted.      To update a CDF file from v1.1 to v1.2  For any SubscriptionOffer, FreeOffer, PurchaseOffer, or RentalOffer that includes a Quality element:          Add a LaunchDetails element as the last element in each offer.              Move the Quality element from its current location to the LaunchDetails element.        Example:        Before        &lt;FreeOffer&gt;   &lt;Quality&gt;HD&lt;/Quality&gt;        ... &lt;/FreeOffer&gt;                After        &lt;FreeOffer&gt;     ...   &lt;LaunchDetails&gt;      &lt;Quality&gt;HD&lt;/Quality&gt;    &lt;/LaunchDetails&gt; &lt;/FreeOffer&gt;                          Optional. For any SubscriptionOffer, FreeOffer, PurchaseOffer, or RentalOffer that didn’t include a Quality element, add a LaunchDetails element as the last element for each. Add as much of the optional Quality, AudioLanguage, Subtitle, and LaunchId information as you have.    Example:    &lt;FreeOffer&gt;        ...        &lt;LaunchDetails&gt;            &lt;Quality&gt;HD&lt;/Quality&gt;            &lt;AudioLanguage&gt;en-us&lt;/AudioLanguage&gt;            &lt;Subtitle&gt;en&lt;/Subtitle&gt;            &lt;Subtitle&gt;es&lt;/Subtitle&gt;            &lt;LaunchId&gt;tt123456_HD_en-us&lt;/LaunchId&gt;        &lt;/LaunchDetails&gt;        &lt;LaunchDetails&gt;            &lt;Quality&gt;HD&lt;/Quality&gt;            &lt;AudioLanguage&gt;es-mx&lt;/AudioLanguage&gt;            &lt;Subtitle&gt;en&lt;/Subtitle&gt;            &lt;Subtitle&gt;es&lt;/Subtitle&gt;            &lt;LaunchId&gt;tt123456_HD_es-mx&lt;/LaunchId&gt;        &lt;/LaunchDetails&gt;    &lt;/FreeOffer&gt;            Optional, but recommended. Add the version attribute, set to FireTv-v1.2, to the existing Catalog element at the top of your CDF file.    Example:    &lt;Catalog xmlns=\"http://www.amazon.com/FireTv/2014-04-11/ingestion\" version=\"FireTv-v1.2\"&gt;        Optional. If you have CustomerRating elements in your catalog, add a Count element as the last element in CustomerRating. This value should be updated whenever you update the CustomerRating.Score value. How you collect and track that information is up to you.      Optional for providers of content to Fire TV in Japan. Add a JP_Require18PlusAgeConfirmation element to at least those works for which it is set to true. Consult the XSD file for the element’s placement, as it varies by work type.    Example:    &lt;Movie&gt;    ...    &lt;JP_Require18PlusAgeConfirmation&gt;true&lt;/JP_Require18PlusAgeConfirmation&gt;    &lt;ReleaseDate&gt;1959-05-13T04:36:00&lt;/ReleaseDate&gt;&lt;/Movie&gt;      Migrating from CDF v1.2 to v1.3Here are the differences between CDF v1.2 and v1.3                      Item      Type      Change      Notes                  MiniSeries&lt;/td&gt;      Element      Added      A mini-series is loosely defined as a TV show limited to a small number of ordered episodes, without seasons.    &lt;/tr&gt;          MiniSeriesEpisode&lt;/td&gt;      Element      Added      An individual episode in a mini-series, used in the same manner as a TvEpisode in relation to a TvShow.    &lt;/tr&gt;          Extra&lt;/td&gt;      Element      Added      Supplementary material, often to accompany a work. Accepted values are: clip: This can be anything from a short scene from the work to a documentary about the work’s cinematographer. Think of it as an bonus feature on a DVD. trailer: An official preview of the work or an associated work.&lt;/td&gt;    &lt;/tr&gt;          ReleaseInfo      Element      Deprecated/Moved      This element contained two child elements:            ReleaseCountry: This information is no longer used       ReleaseDate: This information has been moved to these locations:  WorkType.ReleaseDate (for Movie, TvShow, and MiniSeries), and WorkType.OriginalAirDate (for TvEpisode, TvSpecial, and MiniSeriesEpisode). Note that the original value was in the XML date format (YYYY-MM-DD) while the new values are in the dateTime format (YYYY-MM-DDThh:mm:ss). You cannot simply move the element into its new location; you must also update each value. Also, while ReleaseInfo.ReleaseDate was optional, OriginalAirDate for TvSpecial is required. The others remain optional.                    Movie.ReleaseDate      Element      Added      Optional. This is the new location of the deprecated Movie.ReleaseInfo.ReleaseDate. See the ReleaseInfo entry above for details.              TvShow.ReleaseDate      Element      Added      Optional. This is the new location of the deprecated TvShow.ReleaseInfo.ReleaseDate. See the ReleaseInfo entry above for details.              TvEpisode.OriginalAirDate      Element      Added      Optional. This is the new location of the deprecated TvEpisode.ReleaseInfo.ReleaseDate. See the ReleaseInfo entry above for details.&lt;/td&gt;    &lt;/tr&gt;          TvSpecial.OriginalAirDate      Element      Added      Required. This is the new location of the deprecated TvSpecial.ReleaseInfo.ReleaseDate. See the ReleaseInfo entry above for details.              TvSpecial.ShowID      Element      Added      Optional. This element allows you to attach a special to a specific show, in the situation where the special was an event outside of the regular run of a series. This value must match a TvShow.ID value in your catalog. You cannot include both this value and TvSpecial.ShowTitle.              TvSpecial.ShowTitle      Element      Added      Optional. This element allows you to attach a special to a show not included in your catalog. The ShowTitle string isn’t required to match any title in your catalog. It is used to create the illusion of an attachment without the underlying structure. Use this value only when you cannot use ShowID.              Works      Element      Can now be empty      Previously this would have caused your catalog to be invalid. Now, an empty Works element has the effect of removing all of your content from Amazon Fire TV’s universal browse and search.              WorkType.ID      Element      Must now be at least one character in length      The element itself (a unique identifier for each work) was always required, but now it requires a value as well. Given that this is an extremely important piece of information, used in everything from tying episodes to seasons and shows to reporting where to find an error in the file, it should always be present and unique.      &lt;/tbody&gt;&lt;/table&gt;### To update a CDF file from v1.2 to v1.31.  Move the _WorkType_.ReleaseInfo.ReleaseDate element for all works to their new location. Change each date value to the [XML _dateTime_ format](http://www.w3schools.com/schema/schema_dtypes_date.asp) (YYYY-MM-DDThh:mm:ss). If you don't know the specific time that a work was released or aired, you can just use T00:00:00 for that portion of the string. The target ReleaseDate and OriginalAirDate elements are the last elements in their respective work types.    *   Movie.ReleaseInfo.ReleaseDate moves to Movie.ReleaseDate    *   TvShow.ReleaseInfo.ReleaseDate moves to TvShow.ReleaseDate    *   TvEpisode.ReleaseInfo.ReleaseDate moves to TvEpisode.OriginalAirDate    *   TvSpecial.ReleaseInfo.ReleaseDate moves to TvSpecial.OriginalAirDate    *   TvSeason.ReleaseInfo.ReleaseDate is no longer used so it requires no move        Example:        **Before**        ```xml                            ...                            1959-05-13                        ...                     ...                            ...                                    1959-05-13                                ...                    ```                 **After**        ```xml                    ...            1959-05-13T00:00:00                ...                    ...            1959-05-13T00:00:00                ```2.  Delete all instances of the `ReleaseInfo` element, including any `ReleaseDate` and `ReleaseCountry` elements that they contain.3.  Ensure that you don't have any empty `WorkType.ID` elements (it's unlikely). If you do, assign those works a unique ID.    Example:    **Before**    ```xml                    ...        ```    **After**    ```xml          ts-123456      ...         ```4.  Optional. If you have existing content that would be more accurately described as a `MiniSeries`, move that information into the new `MiniSeries` and `MiniSeriesEpisode` work types.5.  Optional. If you have existing content that would be more accurately described as an `Extra`, move that information into the new `Extra` work type.6.  Optional, but recommended. Add or update the `version` attribute found in the Catalog element at the top of your CDF file to `FireTv-v1.3`.    Example:    ```xml        ```7.  Optional, but recommended where applicable. Add either a `ShowID` (preferred) or `ShowTitle` element to each `TvSpecial` to connect that special to a show. For those specials that are standalone works, these elements can be omitted.8.  Optional. Add an OriginalAirDate element and value for each `TvSpecial` or `TvEpisode` that didn't have a `ReleaseInfo.ReleaseDate` element.9.  Optional. Add a `ReleaseDate` element and value for each Movie or TvShow that didn't have a `ReleaseInfo.ReleaseDate` element.[getting-started-developing-apps-and-games-for-amazon-fire-tv]: getting-started-developing-apps-and-games-for-amazon-fire-tv.html[device-and-platform-specifications]: device-and-platform-specifications.html[fire-tv-development-framework-comparison]: fire-tv-development-framework-comparison.html[amazon-fire-tv-differences-from-android-tv-development]: amazon-fire-tv-differences-from-android-tv-development.html[design-and-user-experience-guidelines]: design-and-user-experience-guidelines.html[fire-tv-fire-os-overview]: fire-tv-fire-os-overview.html[whats-new-in-the-fire-tv-sdk]: whats-new-in-the-fire-tv-sdk.html[amazon-fire-tv-sdk-frequently-asked-questions]: amazon-fire-tv-sdk-frequently-asked-questions.html[submitting-your-fire-tv-app-to-the-amazon-appstore]: submitting-your-fire-tv-app-to-the-amazon-appstore.html[setting-up-your-development-environment]: setting-up-your-development-environment.html[connecting-adb-to-fire-tv-device]: connecting-adb-to-fire-tv-device.html[connecting-adb-to-fire-tv-device#addadbpath]: connecting-adb-to-fire-tv-device.html#addadbpath[installing-and-running-your-app]: installing-and-running-your-app.html[supporting-controllers-on-amazon-fire-tv]: supporting-controllers-on-amazon-fire-tv.html[amazon-fire-tv-remote-input]: amazon-fire-tv-remote-input.html[amazon-fire-game-controller-input]: amazon-fire-game-controller-input.html[controller-input-with-unity]: controller-input-with-unity.html[identifying-controllers]: identifying-controllers.html[controller-behavior-guidelines]: controller-behavior-guidelines.html[controller-image-assets]: controller-image-assets.html[customizing-mouse-pointer]: customizing-mouse-pointer.html[display-and-layout]: display-and-layout.html[user-agent-strings]: user-agent-strings.html[managing-audio-focus]: managing-audio-focus.html[managing-audio-focus#audiofocusvoice]: managing-audio-focus.html#audiofocusvoice[fire-tv-media-players]: fire-tv-media-players.html[fire-tv-media-players#exoplayer]: fire-tv-media-players.html#exoplayer[amazon-fire-tv-dolby-integration-guidelines]: amazon-fire-tv-dolby-integration-guidelines.html[identifying-amazon-fire-tv-devices]: identifying-amazon-fire-tv-devices.html[fire-tv-handling-hdmi-events]: fire-tv-handling-hdmi-events.html[fire-tv-4k-ultra-hd]: fire-tv-4k-ultra-hd.html[user-interface]: user-interface.html[dial-integration]: dial-integration.html[implementing-search-fire-tv]: implementing-search-fire-tv.html[implementing-search-fire-tv#voicesearch]: implementing-search-fire-tv.html#voicesearch[notifications-for-amazon-fire-tv]: notifications-for-amazon-fire-tv.html[specifying-installation-location]: specifying-installation-location.html[fire-tv-advertising-id]: fire-tv-advertising-id.html[fire-tv-international-locales]: fire-tv-international-locales.html[fire-tv-system-xray-developer-tools]: fire-tv-system-xray-developer-tools.html[fire-tv-system-xray]: fire-tv-system-xray.html[fire-tv-system-xray-customized-metrics]: fire-tv-system-xray-customized-metrics.html[fire-tv-assistive-technologies]: fire-tv-assistive-technologies.html[fire-tv-accessibility]: fire-tv-accessibility.html[fire-tv-preview-future-voiceview-accessibility-features]: fire-tv-preview-future-voiceview-accessibility-features.html[fire-tv-recommendations-overview]: fire-tv-recommendations-overview.html[fire-tv-recommendations-send-recommendations]: fire-tv-recommendations-send-recommendations.html[fire-tv-recommendations-send-recommendations#amazon-enhancements]: fire-tv-recommendations-send-recommendations.html#amazon-enhancements[fire-tv-recommendations-testing]: fire-tv-recommendations-testing.html[fire-tv-recommendations-best-practices]: fire-tv-recommendations-best-practices.html[getting-started-with-web-apps-for-fire-tv]: getting-started-with-web-apps-for-fire-tv.html[getting-started-with-web-apps-for-fire-tv#resolution_scaling]: getting-started-with-web-apps-for-fire-tv.html#resolution_scaling[getting-started-with-web-apps-for-fire-tv#focus_changes]: getting-started-with-web-apps-for-fire-tv.html#focus_changes[supporting-controllers-in-web-apps]: supporting-controllers-in-web-apps.html[supporting-controllers-in-web-apps#using_input]: supporting-controllers-in-web-apps.html#using_input[the-web-app-starter-kit-for-fire-tv]: the-web-app-starter-kit-for-fire-tv.html[customizing-your-fire-tv-web-app]: customizing-your-fire-tv-web-app.html[migrating-your-web-app-to-fire-tv]: migrating-your-web-app-to-fire-tv.html[fire-tv-web-app-faq]: fire-tv-web-app-faq.html[fire-tv-web-app-faq#unchanging_duration]: fire-tv-web-app-faq.html#unchanging_duration[fire-tv-web-app-faq#close_webapp]: fire-tv-web-app-faq.html#close_webapp[fire-tv-web-app-faq#customize_back]: fire-tv-web-app-faq.html#customize_back[fire-app-builder-overview]: fire-app-builder-overview.html[fire-app-builder-overview#requirements]: fire-app-builder-overview.html#requirements[fire-app-builder-release-notes]: fire-app-builder-release-notes.html[fire-app-builder-release-notes#known_issues]: fire-app-builder-release-notes.html#known_issues[fire-app-builder-end-to-end-process]: fire-app-builder-end-to-end-process.html[fire-app-builder-questions-and-answers]: fire-app-builder-questions-and-answers.html[fire-app-builder-questions-and-answers#translator]: fire-app-builder-questions-and-answers.html#translator[fire-app-builder-download-and-build]: fire-app-builder-download-and-build.html[fire-app-builder-download-and-build#customize]: fire-app-builder-download-and-build.html#customize[fire-app-builder-connecting-adb-to-fire-tv]: fire-app-builder-connecting-adb-to-fire-tv.html[fire-app-builder-app-tour]: fire-app-builder-app-tour.html[fire-app-builder-load-media-feed]: fire-app-builder-load-media-feed.html[fire-app-builder-set-up-recipes-overview]: fire-app-builder-set-up-recipes-overview.html[fire-app-builder-set-up-recipes-categories]: fire-app-builder-set-up-recipes-categories.html[fire-app-builder-set-up-recipes-categories#matchlistparameter]: fire-app-builder-set-up-recipes-categories.html#matchlistparameter[fire-app-builder-set-up-recipes-content]: fire-app-builder-set-up-recipes-content.html[fire-app-builder-set-up-recipes-content#matchlistparameter]: fire-app-builder-set-up-recipes-content.html#matchlistparameter[fire-app-builder-set-up-recipes-content#tags]: fire-app-builder-set-up-recipes-content.html#tags[fire-app-builder-configure-navigator]: fire-app-builder-configure-navigator.html[fire-app-builder-configure-navigator-token-feeds]: fire-app-builder-configure-navigator-token-feeds.html[fire-app-builder-configure-navigator-open-feeds]: fire-app-builder-configure-navigator-open-feeds.html[fire-app-builder-configure-navigator-open-feeds#hardcodingcategories]: fire-app-builder-configure-navigator-open-feeds.html#hardcodingcategories[fire-app-builder-customize-look-and-feel]: fire-app-builder-customize-look-and-feel.html[fire-app-builder-customize-look-and-feel#recommendations]: fire-app-builder-customize-look-and-feel.html#recommendations[fire-app-builder-interfaces-and-components]: fire-app-builder-interfaces-and-components.html[fire-app-builder-interfaces-and-components#componentgroups]: fire-app-builder-interfaces-and-components.html#componentgroups[fire-app-builder-load-a-component]: fire-app-builder-load-a-component.html[fire-app-builder-load-a-component#removeacomponent]: fire-app-builder-load-a-component.html#removeacomponent[fire-app-builder-create-a-new-component]: fire-app-builder-create-a-new-component.html[fire-app-builder-freewheel-ads-component]: fire-app-builder-freewheel-ads-component.html[fire-app-builder-vast-ads-component]: fire-app-builder-vast-ads-component.html[fire-app-builder-crashlytics-component]: fire-app-builder-crashlytics-component.html[fire-app-builder-flurry-analytics-component]: fire-app-builder-flurry-analytics-component.html[fire-app-builder-google-analytics-component]: fire-app-builder-google-analytics-component.html[fire-app-builder-omniture-analytics-component]: fire-app-builder-omniture-analytics-component.html[fire-app-builder-adobe-pass-auth-component]: fire-app-builder-adobe-pass-auth-component.html[fire-app-builder-facebook-auth-component]: fire-app-builder-facebook-auth-component.html[fire-app-builder-login-with-amazon-component]: fire-app-builder-login-with-amazon-component.html[fire-app-builder-amazon-in-app-purchase-component]: fire-app-builder-amazon-in-app-purchase-component.html[fire-app-builder-amazon-media-player-component]: fire-app-builder-amazon-media-player-component.html[fire-app-builder-pulling-updates-from-github]: fire-app-builder-pulling-updates-from-github.html[fire-app-builder-live-stream-configuration]: fire-app-builder-live-stream-configuration.html[fire-app-builder-catalog-integration]: fire-app-builder-catalog-integration.html[fire-app-builder-use-an-android-tv-emulator]: fire-app-builder-use-an-android-tv-emulator.html[fire-app-builder-querying-json]: fire-app-builder-querying-json.html[fire-app-builder-querying-xml]: fire-app-builder-querying-xml.html[fire-app-builder-troubleshooting]: fire-app-builder-troubleshooting.html[integrating-your-catalog-with-fire-tv]: integrating-your-catalog-with-fire-tv.html[understanding-fire-tv-catalog-integration]: understanding-fire-tv-catalog-integration.html[understanding-fire-tv-catalog-integration#matching]: understanding-fire-tv-catalog-integration.html#matching[getting-started-catalog-integration]: getting-started-catalog-integration.html[getting-started-catalog-integration#beforeyoubegin]: getting-started-catalog-integration.html#beforeyoubegin[about-the-cdf]: about-the-cdf.html[about-the-cdf#validating]: about-the-cdf.html#validating[setting-up-your-aws-account-for-fire-tv-catalog-integration]: setting-up-your-aws-account-for-fire-tv-catalog-integration.html[fire-tv-catalog-integration-faqs]: fire-tv-catalog-integration-faqs.html[uploading-your-catalog]: uploading-your-catalog.html[receiving-and-understanding-the-catalog-ingestion-report]: receiving-and-understanding-the-catalog-ingestion-report.html[launcher-integration]: launcher-integration.html[test-cases-for-verifying-deep-links-from-your-fire-tv-catalog]: test-cases-for-verifying-deep-links-from-your-fire-tv-catalog.html[testing-launcher-integration-with-adb]: testing-launcher-integration-with-adb.html[testing-launcher-integration-with-the-test-app]: testing-launcher-integration-with-the-test-app.html[catalog-data-format-ingestion-report-messages]: catalog-data-format-ingestion-report-messages.html[migrating-a-cdf-file-to-the-latest-version]: migrating-a-cdf-file-to-the-latest-version.html[catalog-data-format-schema-reference]: catalog-data-format-schema-reference.html[catalog-data-format-schema-reference#AdultProduct]: catalog-data-format-schema-reference.html#AdultProduct[catalog-data-format-schema-reference#FreeOffer]: catalog-data-format-schema-reference.html#FreeOffer[catalog-data-format-schema-reference#Partner]: catalog-data-format-schema-reference.html#Partner[catalog-data-format-schema-reference#ShortDescription]: catalog-data-format-schema-reference.html#ShortDescription[catalog-data-format-schema-reference#AudioLanguage]: catalog-data-format-schema-reference.html#AudioLanguage[catalog-data-format-schema-reference#Genre]: catalog-data-format-schema-reference.html#Genre[catalog-data-format-schema-reference#Price]: catalog-data-format-schema-reference.html#Price[catalog-data-format-schema-reference#ShowID]: catalog-data-format-schema-reference.html#ShowID[catalog-data-format-schema-reference#CastMember]: catalog-data-format-schema-reference.html#CastMember[catalog-data-format-schema-reference#Genres]: catalog-data-format-schema-reference.html#Genres[catalog-data-format-schema-reference#PurchaseOffer]: catalog-data-format-schema-reference.html#PurchaseOffer[catalog-data-format-schema-reference#ShowTitle]: catalog-data-format-schema-reference.html#ShowTitle[catalog-data-format-schema-reference#Catalog]: catalog-data-format-schema-reference.html#Catalog[catalog-data-format-schema-reference#ID]: catalog-data-format-schema-reference.html#ID[catalog-data-format-schema-reference#Quality]: catalog-data-format-schema-reference.html#Quality[catalog-data-format-schema-reference#Source]: catalog-data-format-schema-reference.html#Source[catalog-data-format-schema-reference#Certification]: catalog-data-format-schema-reference.html#Certification[catalog-data-format-schema-reference#Regions]: catalog-data-format-schema-reference.html#Regions[catalog-data-format-schema-reference#Rank]: catalog-data-format-schema-reference.html#Rank[catalog-data-format-schema-reference#ImageUrl]: catalog-data-format-schema-reference.html#ImageUrl[catalog-data-format-schema-reference#Studio]: catalog-data-format-schema-reference.html#Studio[catalog-data-format-schema-reference#Color]: catalog-data-format-schema-reference.html#Color[catalog-data-format-schema-reference#Job]: catalog-data-format-schema-reference.html#Job[catalog-data-format-schema-reference#Studios]: catalog-data-format-schema-reference.html#Studios[catalog-data-format-schema-reference#ContentRating]: catalog-data-format-schema-reference.html#ContentRating[catalog-data-format-schema-reference#JP_Require18PlusAgeConfirmation]: catalog-data-format-schema-reference.html#JP_Require18PlusAgeConfirmation[catalog-data-format-schema-reference#RelatesToExternalID]: catalog-data-format-schema-reference.html#RelatesToExternalID[catalog-data-format-schema-reference#SubscriptionOffer]: catalog-data-format-schema-reference.html#SubscriptionOffer[catalog-data-format-schema-reference#ContentRatings]: catalog-data-format-schema-reference.html#ContentRatings[catalog-data-format-schema-reference#Language]: catalog-data-format-schema-reference.html#Language[catalog-data-format-schema-reference#RelatesToID]: catalog-data-format-schema-reference.html#RelatesToID[catalog-data-format-schema-reference#Subtitle]: catalog-data-format-schema-reference.html#Subtitle[catalog-data-format-schema-reference#Copyright]: catalog-data-format-schema-reference.html#Copyright[catalog-data-format-schema-reference#LaunchDetails]: catalog-data-format-schema-reference.html#LaunchDetails[catalog-data-format-schema-reference#ReleaseCountry]: catalog-data-format-schema-reference.html#ReleaseCountry[catalog-data-format-schema-reference#LaunchId]: catalog-data-format-schema-reference.html#LaunchId[catalog-data-format-schema-reference#Synopsis]: catalog-data-format-schema-reference.html#Synopsis[catalog-data-format-schema-reference#Count]: catalog-data-format-schema-reference.html#Count[catalog-data-format-schema-reference#ReleaseDate]: catalog-data-format-schema-reference.html#ReleaseDate[catalog-data-format-schema-reference#System]: catalog-data-format-schema-reference.html#System[catalog-data-format-schema-reference#Country]: catalog-data-format-schema-reference.html#Country[catalog-data-format-schema-reference#MaxValue]: catalog-data-format-schema-reference.html#MaxValue[catalog-data-format-schema-reference#ReleaseInfo]: catalog-data-format-schema-reference.html#ReleaseInfo[catalog-data-format-schema-reference#Title]: catalog-data-format-schema-reference.html#Title[catalog-data-format-schema-reference#Credits]: catalog-data-format-schema-reference.html#Credits[catalog-data-format-schema-reference#MiniSeries]: catalog-data-format-schema-reference.html#MiniSeries[catalog-data-format-schema-reference#ReleaseYear]: catalog-data-format-schema-reference.html#ReleaseYear[catalog-data-format-schema-reference#TvEpisode]: catalog-data-format-schema-reference.html#TvEpisode[catalog-data-format-schema-reference#CrewMember]: catalog-data-format-schema-reference.html#CrewMember[catalog-data-format-schema-reference#MiniSeriesEpisode]: catalog-data-format-schema-reference.html#MiniSeriesEpisode[catalog-data-format-schema-reference#RentalOffer]: catalog-data-format-schema-reference.html#RentalOffer[catalog-data-format-schema-reference#TvSeason]: catalog-data-format-schema-reference.html#TvSeason[catalog-data-format-schema-reference#CustomerRating]: catalog-data-format-schema-reference.html#CustomerRating[catalog-data-format-schema-reference#MiniSeriesID]: catalog-data-format-schema-reference.html#MiniSeriesID[catalog-data-format-schema-reference#Role]: catalog-data-format-schema-reference.html#Role[catalog-data-format-schema-reference#TvShow]: catalog-data-format-schema-reference.html#TvShow[catalog-data-format-schema-reference#Duration]: catalog-data-format-schema-reference.html#Duration[catalog-data-format-schema-reference#MiniSeriesTitle]: catalog-data-format-schema-reference.html#MiniSeriesTitle[catalog-data-format-schema-reference#RuntimeMinutes]: catalog-data-format-schema-reference.html#RuntimeMinutes[catalog-data-format-schema-reference#TvSpecial]: catalog-data-format-schema-reference.html#TvSpecial[catalog-data-format-schema-reference#EpisodeInSeason]: catalog-data-format-schema-reference.html#EpisodeInSeason[catalog-data-format-schema-reference#Movie]: catalog-data-format-schema-reference.html#Movie[catalog-data-format-schema-reference#Score]: catalog-data-format-schema-reference.html#Score[catalog-data-format-schema-reference#EpisodeInSeries]: catalog-data-format-schema-reference.html#EpisodeInSeries[catalog-data-format-schema-reference#Name]: catalog-data-format-schema-reference.html#Name[catalog-data-format-schema-reference#SeasonID]: catalog-data-format-schema-reference.html#SeasonID[catalog-data-format-schema-reference#WindowEnd]: catalog-data-format-schema-reference.html#WindowEnd[catalog-data-format-schema-reference#ExternalID]: catalog-data-format-schema-reference.html#ExternalID[catalog-data-format-schema-reference#Offers]: catalog-data-format-schema-reference.html#Offers[catalog-data-format-schema-reference#SeasonInShow]: catalog-data-format-schema-reference.html#SeasonInShow[catalog-data-format-schema-reference#WindowStart]: catalog-data-format-schema-reference.html#WindowStart[catalog-data-format-schema-reference#Extra]: catalog-data-format-schema-reference.html#Extra[catalog-data-format-schema-reference#OriginalAirDate]: catalog-data-format-schema-reference.html#OriginalAirDate[catalog-data-format-schema-reference#SeasonTitle]: catalog-data-format-schema-reference.html#SeasonTitle[catalog-data-format-schema-reference#SeasonTitle]: catalog-data-format-schema-reference.html#SeasonTitle[catalog-data-format-schema-reference#Type]: catalog-data-format-schema-reference.html#Type[catalog-data-format-schema-reference#Works]: catalog-data-format-schema-reference.html#Works[catalog-data-format-schema-definition]: https://s3.amazonaws.com/com.amazon.aftb.cdf/catalog.xsd[catalog-data-format-examples]: https://s3.amazonaws.com/com.amazon.aftb.cdf/cdf-examples.zip[understanding-the-amazon-fling-service]: understanding-the-amazon-fling-service.html[download-the-fling-sdk]: https://developer.amazon.com/public/resources/development-tools/sdk[amazon-fling-frequently-asked-questions]: amazon-fling-frequently-asked-questions.html[setting-up-your-amazon-fling-development-environment-for-android]: setting-up-your-amazon-fling-development-environment-for-android.html[setting-up-your-amazon-fling-development-environment-for-ios]: setting-up-your-amazon-fling-development-environment-for-ios.html[integrating-amazon-fling-into-your-android-app]: integrating-amazon-fling-into-your-android-app.html[integrating-amazon-fling-into-your-ios-app]: integrating-amazon-fling-into-your-ios-app.html[integrating-amazon-fling-into-your-fire-tv-app]: integrating-amazon-fling-into-your-fire-tv-app.html[using-amazon-fling-with-android-mediarouter]: using-amazon-fling-with-android-mediarouter.html[working-with-built-in-receiver-on-fire-tv]: working-with-built-in-receiver-on-fire-tv.html[integrating-amazon-fling-with-cast]: integrating-amazon-fling-with-cast.html[integrating-amazon-fling-with-an-existing-android-cast-app]: integrating-amazon-fling-with-an-existing-android-cast-app.html[integrating-amazon-fling-with-an-existing-ios-cast-app]: integrating-amazon-fling-with-an-existing-ios-cast-app.html[designing-amazon-fling-ux]: designing-amazon-fling-ux.html[remote-install]: remote-install.html[android-remote-install]: android-remote-install.html[ios-remote-install]: ios-remote-install.html[unity-controller-plugin]: unity-controller-plugin.html[unity-player-plugin]: unity-player-plugin.html[fling-android-api-docs]: https://developer.amazon.com/public/binaries/content/assets/javadoc/whisperplay/javadocs/reference/packages.html[fling-ios-api-docs]: https://developer.amazon.com/public/binaries/content/assets/javadoc/whisperplay/objc-apidocs/index.html[appstore-presubmission-checklist]: appstore-presubmission-checklist.html[appstore-understanding-submission]: appstore-understanding-submission.html[appstore-migrate-existing-app]: appstore-migrate-existing-app.html[appstore-avoid-compile-errors]: appstore-avoid-compile-errors.html[taking-screenshots]: taking-screenshots.html[taking-screenshots#firetv]: taking-screenshots.html#firetv[taking-screenshots#firetablets]: taking-screenshots.html#firetablets[appstore-avoid-compile-errors]: appstore-avoid-compile-errors.html[appstore-ssl-validation]: appstore-ssl-validation.html[appstore-content-policy]: appstore-content-policy.html[appstore-content-policy#faq]: appstore-content-policy.html#faq[appstore-coppa-policy]: appstore-coppa-policy.html[appstore-coppa-policy#faq]: appstore-coppa-policy.html#faq[asset-guidelines-for-app-submission]: asset-guidelines-for-app-submission.html[asset-guidelines-for-app-submission#firetvassets]: asset-guidelines-for-app-submission.html#firetvassets[appstore-test-criteria]: appstore-test-criteria.html[getting-started-with-device-targeting]: getting-started-with-device-targeting.html[getting-started-with-device-targeting#build_apks]: getting-started-with-device-targeting.html#build_apks[targeting-amazon-devices-with-your-android-manifest]: targeting-amazon-devices-with-your-android-manifest.html[supported-filters-on-the-amazon-appstore]: supported-filters-on-the-amazon-appstore.html[troubleshooting-android-manifest-and-device-targeting]: troubleshooting-android-manifest-and-device-targeting.html[manifest-filter]: https://developer.amazon.com/public/binaries/content/assets/xls/manifest-filter-reference-for-fire-devices---2016-feb-26.xlsx[testing-your-app]: testing-your-app.html[getting-started-with-live-app-testing]: getting-started-with-live-app-testing.html[app-testing-service-understanding]: app-testing-service-understanding.html[submitting-your-app]: submitting-your-app.html[submitting-apps-to-amazon-appstore]: submitting-apps-to-amazon-appstore.html[submitting-apps-to-amazon-appstore#APK]: submitting-apps-to-amazon-appstore.html#APK[submitting-apps-to-amazon-appstore#SecurityProfile]: submitting-apps-to-amazon-appstore.html#SecurityProfile[viewing-app-submission-status]: viewing-app-submission-status.html[appstore-user-permissions]: appstore-user-permissions.html[update-published-app]: update-published-app.html[appstore-unlist-app]: appstore-unlist-app.html[faq]: faq.html[faq#policy_intellectual_property]: faq.html#policy_intellectual_property[faq#policy_guidelines]: faq.html#policy_guidelines[faq#account_permissions]: faq.html#account_permissions[faq#web_apps]: faq.html#web_apps[faq#pc_mac_software]: faq.html#pc_mac_software[faq#international_distribution]: faq.html#international_distribution[payments-understanding]: payments-understanding.html[payments-tax]: payments-tax.html[payments-reports]: payments-reports.html[IAP-whatsnew]: whats-new-in-in-app-purchasing.html[understanding-iap]: understanding-in-app-purchasing.html[faqs-iap]: iap-faqs.html[ui-and-ux-design-guidelines]: best-practices-ui-and-ux-design-guidelines.html[deep-linking-to-the-amazon-client]: deep-linking-to-the-amazon-client.html[submitting-iap-items]: submitting-iap-items.html[getting-started-with-iap]: getting-started-with-iap.html[implementing-iap]: implementing-iap.html[obfuscating-the-code]: obfuscating-the-code.html[migrate-from-iapv1-to-iapv2]: migrate-iapv1-apps-to-iapv2.html[migrate-from-iab-to-iapv2]: migrating-from-googles-iab-to-amazons-iap.html[testing-iap]: testing-iap.html[installing-and-configuring-app-tester]: installing-and-configuring-app-tester.html[app-tester-ug]: app-tester-user-guide.html[test-cases-for-iap]: test-cases-for-iap.html[rvs-iap]: verifying-receipts-in-iap.html[iap-api-for-webapps-overview]: iap-api-for-webapps-overview.html[iap-consumables-webapps]: iap-consumables-webapps.html[iap-entitlements-webapps]: iap-entitlements-webapps.html[iap-subscriptions-webapps]: iap-subscriptions-webapps.html[iap-sdk-tester-for-webapps]: iap-sdk-tester-for-webapps.html[rvs-iap-webapps]: verifying-receipts-in-iap-webapp.html[IAP-2.0-api-ref]: in-app-purchasing-2.0-api-reference.html[adm-understanding]: adm-understanding.html[adm-obtaining-credentials]: adm-obtaining-credentials.html[adm-setting-up]: adm-setting-up[adm-integrating-your-app]: adm-integrating-your-app.html[adm-requesting-access-token]: adm-requesting-access-token.html[adm-sending-message]: adm-sending-message.html[adm-faq]: adm-faq.html",
        "url": "migrating-a-cdf-file-to-the-latest-version.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "receiving-and-understanding-the-catalog-ingestion-report-html": {
        "title": "Receiving and Understanding the Fire TV Catalog Ingestion Report",
        "tags": "[]",
        "content": "After you’ve uploaded your catalog data to the Amazon Simple Storage Service (S3) bucket for integration into the Amazon Fire TV universal browse and search, the catalog integration system generates an ingestion report within four hours to tell you whether the catalog file could be used. The report gives an overall success or failure status, identifies any problems found in the file, and provides details about each problem. Note: The ingestion report system is a beta release. Opting in to receive ingestion status notification emails is strictly voluntary at this time. Until you feel comfortable making any necessary changes or fixes to your catalog file, your Amazon Business Developer Manager will notify you if there are problems and will help you understand and resolve them.  Retrieving Your Ingestion Report          How to Receive Ingestion Status Notification Emails      How to Use the Information in the Email        What’s in the Ingestion Report?          The Summary      Errors, Warnings, and Suggestions      Counts        Acting on the Ingestion ReportRetrieving Your Ingestion ReportThe ingestion report, named report.html, is an HTML file placed in the same S3 bucket as your uploaded catalog file. You can opt to receive an email telling you that the new report is ready, providing a basic summary of its contents and giving you a command with which you can download the full report. How to Receive Ingestion Status Notification EmailsTo receive your ingestion report summary emails, send a email to p11-catalog-subscriptions@amazon.com asking to be added to the distribution list for your catalog. Amazon will verify your request and add you to the list.Success and failure emails are sent separately, so if you want to receive both, ask to be included on both lists. A report is generated once per upload or when the ingestion status changes.How to Use the Information in the EmailThe email that you receive provides the ingestion’s success or failure status. If the ingestion fails, the errors are listed in the full report (rather than in the email). The email also contains an Amazon Web Services (AWS) command to retrieve the full report.To use that AWS command, you must first install the Amazon Web Services Command Line Interface (CLI) tool, after which you can use AWS commands in a normal command or terminal window. This ensures that your proprietary catalog information remains protected, because only someone with access rights to your S3 bucket can retrieve the report using that command.Here’s an example of the AWS command to retrieve the report. Copy the line from the email and paste it into your command or terminal window.aws s3api get-object --bucket cdf-test --key reports/report.html --version-id FciuqMvVh2oWFv726L6Ytf8ECLbO6Kj0 report.htmlWhen run successfully, this command downloads the report to your current folder. The downloaded file has the name _report.html_. (If you’re curious about what that command is doing, see the AWS CLI Command Reference get-object page.)In addition to the AWS CLI command, the email will also contain a link to access the report directly. This link is valid for 7 days. Note that anyone with this link can access the full report, so be aware of this when forwarding the email.What’s in the Ingestion Report?An ingestion report has three sections:  The summary, including the success or failure status  Errors, warnings, and suggestions  Counts of catalog entries added, removed, updated, or unchanged.The SummaryHere is an example of the summary section of an ingestion report:Example ingestion report summary sectionThe summary includes a unique ID given to each ingestion attempt, the catalog that was used, when the ingestion attempt was made, and the result. There are two possible results:      Success: No errors were found in the catalog, although there still may be actionable warnings and suggestions. The catalog information was integrated into Fire TV’s universal browse and search.     Note: You should still look at the Counts section to ensure that the results are as you expected. For instance, you could accidentally delete a big portion of your catalog and still have a successful ingestion as long as there are no errors in what remains. Only by reading beyond the Success glyph to notice that the number of entries removed was unexpectedly high would you suspect that something wasn’t right.        Failure: Errors prevented the catalog from being used. Your last successfully ingested catalog remains the active catalog. The Errors, Warnings, and Suggestions section of the report will give you specific information about what went wrong.  The ingestion in the example above failed due to nine errors. Many warnings and suggestions were also generated, but messages in these categories generally do not trigger a failure (image-related warnings and suggestions are the exception). Counts for added, removed, and updated are all 0 because the ingestion failed and the uploaded catalog was not used. The unchanged count of 0 indicates that there is no previous catalog to change.Clicking on any of those boxes takes you to that section of the report.Errors, Warnings, and SuggestionsThis portion of the report is where you’ll find the information that you’ll need to fix any problems. Clicking the Details button for a section expands that section to list its individual messages. At the end of each message is the number of entries that generated it. Clicking on the plus sign next to each message displays the IDs of the works that generated the message, and, in some cases, an additional message with more details. Here is an example with two expanded errors:Expanded errors showing detailsIssues found in the Errors section cause an ingestion to fail; warnings and suggestions generally do not. Therefore, a successful ingestion report can still contain plenty of warnings and suggestions that you should examine.CountsThe last section in the report provides specifics on the changes to your catalog due to the ingestion. Clicking the Details button in each category again shows the IDs of the works in each. If you have a list of expected changes, you can compare it against these lists as a final check.If the ingestion failed, then the uploaded catalog was not used so the Added, Removed, and Updated values will be 0. The Unchanged value shows the number of catalog entries in your last successfully ingested catalog.If the ingestion was successful, the Added, Removed, Updated, and Unchanged numbers should reflect your expected results. As mentioned above, the counts in this section can indicate that there’s a problem with your catalog even when the ingestion is successful by all other measures.Acting on the Ingestion ReportWhat you do next depends on the ingestion status.  Success: As long as the counts of pages added, removed, updated, and unchanged are as you expected, there is no further action required. However, consider addressing any warnings and suggestions. See catalog-data-format-ingestion-report-messages for an explanation and course of action for each.  Failure: Refer to catalog-data-format-ingestion-report-messages for an explanation and course of action for each entry in the Error section. If you still have trouble understanding what needs to be done or how to do it, please contact your Amazon Business Developer Manager.",
        "url": "receiving-and-understanding-the-catalog-ingestion-report.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "setting-up-your-aws-account-for-fire-tv-catalog-integration-html": {
        "title": "Setting Up Your AWS Account for Fire TV Catalog Integration",
        "tags": "[]",
        "content": "Fire TV Catalog Integration uses Amazon Web Services (AWS) tools for uploading your catalog and managing the users who have access to the tool used to store your catalog. Before uploading your catalog file, you will need to set up your AWS account and exchange account information with your Amazon Fire TV representative.  Procedure Overview  Step 1: Sign In or Sign Up for an AWS Account (New AWS Users)  Step 2: Send Your 12-Digit AWS Account ID and Your Canonical User ID to Your Amazon Representative  Step 3: Obtain the S3 bucket information for your app from your Amazon Fire TV representative  Step 4: Grant permission to an Identity and Access Management (IAM) AWS user to upload files to your Fire TV S3 catalog bucket          Creating a new IAM User      Giving IAM Users Access to Your Amazon S3 Bucket        Step 5: Test Your IAM User Policy  Step 6: Set up the AWS Command Line Interface (CLI) (if necessary)Procedure OverviewSetting up your AWS account is a one-time process that you will need to complete before you can start uploading catalog files to Amazon. To set up and test your AWS account:  Sign in or sign up for an AWS account.  Send your 12-digit AWS Account ID (this is different than an IAM User ID) and your Canonical User ID to your Amazon Fire TV representative.  Obtain the S3 bucket information for your app from your Amazon Fire TV representative.  Grant permission to an Identity and Access Management (IAM) AWS user to upload files to your Fire TV S3 catalog bucket.  Test your IAM user policy.  Set up the AWS CLI (if necessary).  Test the catalog upload using a sample CDF file with with the AWS Command Line Interface (CLI) to verify that you can upload catalog files.Step 1: Sign In or Sign Up for an AWS Account (New AWS Users)To upload your catalog file to our service on Amazon S3, you must have an Amazon Web Services (AWS) account. If you have an AWS account, sign in to that account. If you do not already have an account with AWS, you will need to create one:To create an AWS Account:  Go to the AWS home page: http://aws.amazon.com/  Click the Sign in to the Console button, which takes you to the login screen.  Type your email address or mobile telephone number.  Choose the I am a new user option.  Click the Sign in using our secure server button.  Follow the prompts to create your account.Step 2: Send Your 12-Digit AWS Account ID and Your Canonical User ID to Your Amazon RepresentativeFor the Fire TV service to grant access to the S3 catalog bucket that Amazon creates for you, send the 12-digit Account ID of your AWS account to your Amazon Fire TV representative using a secure method.Note that your AWS Account ID is different from an Access Key ID or Secret Access Key, which are specific to IAM users.To find your AWS Account ID:      For account owners (root account users), the AWS account ID is on the Security Credentials page, under the Account Identifiers tab.            For IAM or federated users, the AWS account ID is shown in the Support Center, in the upper right corner. (If you have not yet set up your IAM users, the next section describes how to do so. Note that you will need the name of the S3 bucket from your Amazon Fire TV representative to set up the security policy for your IAM users.)      Additionally, make sure to send your Canonical User ID to your Amazon Fire TV representative. This ID is located just below the AWS account ID for account owners:Step 3: Obtain the S3 bucket information for your app from your Amazon Fire TV representativeOnce you send your AWS Account ID to your Amazon Fire TV representative, your representative will send you an S3 bucket name. This catalog bucket is unique to your account and may only be accessed by your account. No other Catalog Integration partner can see or access your S3 catalog bucket.Step 4: Grant permission to an Identity and Access Management (IAM) AWS user to upload files to your Fire TV S3 catalog bucketConfigure an Identity and Access Management (IAM) AWS user with at least the “S3 PutObject” permission to all of S3 or at least your Fire TV S3 catalog bucket. This permission will allow that user to upload files to your S3 bucket.Although you can use your AWS root credentials to access Amazon S3 and your catalog bucket, the AWS best practice is to create separate Identity and Access Management (IAM) users and use those credentials to interact with AWS. For example, you can create an IAM user that has full administrator access to S3 but to no other AWS services or create a limited-access IAM user who can only upload catalog data but not access any other part of the account. Set up an IAM user for your AWS account for each person in your organization who will need access to your S3 bucket. Having separate IAM users for different members of your organization will allow you to enable only the necessary permissions for each user.Creating a new IAM UserTo create a new IAM user:  Go to the main AWS console: https://console.aws.amazon.com/.  Under Security &amp; Identity, click Identity and Access Management to display the Welcome to Identity and Access Management page.  Under Security Status, click Create individual IAM users to expand that menu item, then click Manage Users to view the list of IAM users associated with your AWS account.  Click the Create New Users button to create your new users:          Under Enter User Names, type your choice of user names for up to five new users.      Check the Generate an access key for each user box.      Click Create.        As prompted, download or otherwise save the security credentials for the new user.The security credentials contain two access keys: an Access Key ID and a Secret Access Key. The secret access key is only available when you create an IAM user, although you can generate a new one at any time. Find the access key ID on the IAM Users page under the Security Credentials tab.Any user who is going to access the Catalog Integration S3 bucket will need the access keys for that IAM user.Giving IAM Users Access to Your Amazon S3 BucketIf you have already set up IAM users, you will need to give them access to your S3 bucket. Before you start this procedure, you will need the name of your S3 bucket as provided by your Amazon Fire TV representative.To give existing IAM users access to your Amazon S3 bucket:  Go to the main AWS console:  https://console.aws.amazon.com/.  Under Security &amp; Identity, click Identity and Access Management to display the Welcome to Identity and Access Management page.  On the left pane, click Users to view the list of IAM users associated with your account.  From the list of users, select the user who you would like to grant access to your S3 bucket to.  On the user’s details page, click the Permissions tab to set up the security policy for the user. Two different setups are commonly used for permissions:          Option 1: If you are comfortable with the user having full access to all S3 functionality for the account, apply the “AmazonS3FullAccess” policy:                  On the Permissions tab, under Managed Policies, click Attach Policy to go to the Attach Policy screen.          In the Filter box, type “AmazonS3FullAccess” to show the AmazonS3FullAccess policy.          Check the box next to the AmazonS3FullAccess policy and click Attach Policy.                    Option 2: Set up a new custom policy for your bucket, which restricts that user access to only your catalog bucket:                  On the Permissions tab, go to Inline Policies, and click the link to create a new inline policy, which will take you to a Set Permissions page.          On the Set Permissions page, select Custom Policy, and click Select to go to the Review Policy page.          On the Review Policy page, enter the following information:                          Policy Name: Type a unique name for the policy. This name can be anything that you choose.              Policy Document: Copy and paste the following line into the Policy Document field. Substitute the actual name of your S3 bucket for the &lt;Bucket_Name&gt; placeholder.                        {\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"s3:*\",\"Resource\":\"arn:aws:s3:::*&lt;Bucket_Name&gt;\"}]}                                Click Validate Policy.You will see a status message either telling you that the policy is valid or an error message with instructions to fix the policy.          Click Apply Policy to apply the policy to the user.                    Step 5: Test Your IAM User PolicyTo make sure that you have correctly set up your IAM users and their security policies, you can use AWS’s Policy Simulator tool. To verify a policy using the Policy Simulator:  In your web browser, navigate to the Policy Simulator: https://policysim.aws.amazon.com/home/index.jsp?#  On the left pane, select the user whose policy you are verifying.  On the right pane, select S3 from the Select Service drop-down list.  From the Select action drop-down list, select PutObject.  Click the toggle arrow just to the left of the Amazon S3 entry in the Service column to expand the simulation settings.  Copy and paste “arn:aws:s3:::/catalogs/*\" into the **ARN** field, replacing the  placeholder with the name of your S3 catalog bucket.  Click Run Simulation to run the simulation.If the policy is valid, the simulator will display an “allowed” message; otherwise, it will display “denied” with an explanation of the issue.Step 6: Set up the AWS Command Line Interface (CLI) (if necessary)To interact with Amazon S3 and your catalog bucket, you can use any available tools for interacting with Amazon S3, including the following:  The AWS Command Line Interface (CLI). See Getting Set Up with the AWS Command Line Interface for information.  One of the AWS SDKs to implement catalog upload with the programming language of your choice. For example, the AWS SDK for Java provides an S3 Client, with sample code. See Start Developing with Amazon Web Services for more information on the AWS developer tools.Any S3 access tool you use, including your own implementation, must be initially configured with the Access Key ID and Secret Access Key for your IAM user. For example, to configure the AWS CLI, use the aws configure command. The following example shows both the aws configure command syntax and the prompts that follow as you configure the CLI:$ aws configureAWS Access Key ID [None]: AAAAAAAAAAAAAEXAMPLEAWS Secret Access Key [None]: aAaaaAAaaAAA/A1AAAAA/aAaAaaAAEXAMPLEKEYDefault region name [None]: us-west-2Default output format [None]: jsonSee Configuring the AWS Command Line Interface for information on configuring the AWS CLI.",
        "url": "setting-up-your-aws-account-for-fire-tv-catalog-integration.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "test-cases-for-verifying-deep-links-from-your-fire-tv-catalog-html": {
        "title": "Test Cases for Verifying Fire TV Deep Links",
        "tags": "[]",
        "content": "This page provides a list of test cases to execute for your Fire TV apps before submitting your app to the Amazon Appstore. Performing the test workflow as described will help facilitate your app’s acceptance to the Amazon Appstore when submitted. Note that these test cases apply to apps that have been integrated with Fire TV and whose media catalogs have been integrated with and uploaded to Amazon. See understanding-fire-tv-catalog-integration).  Introduction of the Recommended Testing Process  Step 1: Verify that the Amazon Home Screen Launcher and Your App Are Functioning as Expected          Test Case: Your app is currently available on Amazon Appstore      Test Case: Your app is not yet published to the Amazon Appstore        Step 2: Verify Playback of Selected Content  Step 3: Verify Launcher Updates when Your App is Uninstalled          Test Case: Your App Does Not Require Any Login Credentials      Test Case: Your App Requires Login Credentials        Sending an Invalid Content IDIntroduction of the Recommended Testing ProcessThe following flowchart gives an overview of the recommended testing process for verifying that you have correctly integrated your app with the Fire TV Home Screen Launcher. Depending on the state (published or unpublished) and conditions of your app (login required or not, free trial or not), you will only need to perform the steps that apply to your app.Follow each set of steps below, as it pertains to your app. Use the flowchart as a guide to help you keep track of where you are in the overall testing process.Step 1: Verify that the Amazon Home Screen Launcher and Your App Are Functioning as ExpectedDepending on whether or not your app is currently available from the Amazon Appstore, choose from one of the following two test cases, and execute those steps as described. These steps test the following functionality:  The Amazon Home Screen Launcher is working correctly with your app.  Your app provides the correct UX for customers.Test Case: Your app is currently available on Amazon AppstoreTo verify launcher and app functionality for an app that is currently available from the Amazon Appstore:      Without the app installed, locate one of your content items that is not also available on Prime, and navigate to the provider line in the More Ways To Watch (MWTW) button:                      If there is no MWTW button, this is likely content that is not available with any other provider (including Prime or Amazon Instant Video).        In this instance, on the Episode/Movie detail page of the content, locate the Watch Now with [App Name] – Open App button. Note that if your app has a free trial version, this button should be labeled Watch with [Provider] – [X time] Free Trial.                        If there is a MWTW button, click that button, and you should see Also Available with [App Name] to the right of your app name.            Select the app name from the MWTW list (or the action button from the Movie/Episode detail page, if there is no MWTW button).    The app detail page should display, with an option to purchase/download the app.        Purchase/download the app.  Open the app, but do not sign in. (Finishes with activation screen for app.)  Go to Step 2 of the testing process (below) and execute the appropriate testing steps for your app.Test Case: Your app is not yet published to the Amazon AppstoreTo verify launcher and app functionality for an app that has not yet been published to the Amazon Appstore:  Sideload the APK onto a Fire TV device. (See Installing and Running Your Fire TV App.)      Locate one of your content items that is not also available on Prime, and navigate to the provider line in the More Ways To Watch (MWTW) button.              If there is no MWTW button, this is likely content that is not available with any other provider (including Prime or Amazon Instant Video).In this instance, on the Episode/Movie detail page of the content you should see a button that says Watch with [Provider] – Open App or Watch with [Provider] – [X time] Free Trial.                  If there is a MWTW button, to the right of your app name it should say Open App.        Select the app name from the MWTW list (or the action button from the Movie/Episode detail page, if there is no MWTW button).The app detail page should display, with a button to open the app. The Fire TV system will know that the app is already installed because it was sideloaded.  Open the app, but do not sign in.You should see the activation screen for your app.  Go to Step 2 of the testing process (below) and execute the appropriate testing steps for your app.Step 2: Verify Playback of Selected ContentThis test case verifies that playback of content selected by a user begins playback directly from within Fire TV, without re-routing the user to your app as an intermediate step.To test playback of selected content from within Fire TV:  Activate your Fire TV device, if needed. This is a one-time setup step for new devices. If your device has not yet been activated, you will see prompts that you can follow to complete the activation.  If your app requires login credentials and an active subscription, go through the process of signing in to your app and activating a subscription, if you have not already done so.  Navigate to a content item that is available from your app:          Back out of your app via the BACK button on the remote and return to the app detail page.      Back out of this page to return to the Movie/Episode detail page.        The Buy Box button should be updated to say Watch Now with [Provider].  Select and start playback of your content:          Click the MWTW button (if present).      Within the MWTW menu, your app should appear at the top of the list with nothing next to it.      Select the Buy Box button (or app name within MWTW).Selecting this button should launch the app and attempt to start playback of the content you had selected.      Confirm that playback of the content that you selected has started.        While you are still in the app, or even during video playback, repeat steps 3-5 of this section for at least one additional content item.Step 3: Verify Launcher Updates when Your App is UninstalledThe next two test cases test a deep link to a content item when your app is currently not installed on a Fire TV device. Choose the appropriate set of steps depending on whether your app requires login credentials.Test Case: Your App Does Not Require Any Login CredentialsTo verify a deep link for an uninstalled app that does not require login credentials:  Press and hold the HOME button for your Fire TV device. The HUD should appear.  Select Settings from the HUD popup  Navigate right to Applications &gt; Manage Installed Applications.  Uninstall your app.  Locate the content you used in your previous deep link test.  Confirm that the Buy Box button has reverted to its un-activated state; it should no longer say Watch Now with [Provider].Test Case: Your App Requires Login CredentialsTo verify a deep link for an uninstalled link that does require login credentials:  Sign out of your credentials from within the app, if you have not already done so.  Back out of your app, and navigate to the content page that you previously used to test the deep link to your content item.  Confirm that the Buy Box button has reverted to its un-activated state; it should no longer say Watch Now with [Provider].  Sign back in, or reactivate the subscription within the app.  Confirm that the Buy Box button is updated to say Watch Now with [Provider].      Uninstall your app:          Press and hold the HOME button.        The Heads Up Display (HUD) appears.          Select Settings from the HUD popup menu.      Navigate right to Applications &gt; Manage Installed Applications.      Uninstall your app.        Locate the content that you previously used in the deep link test.  Confirm that the Buy Box button has reverted to its un-activated state; it should no longer say Watch Now with [Provider].Sending an Invalid Content IDAnother test case that you should execute is sending an Invalid Content ID to your app to make sure that your app handles this condition gracefully. If your app does not handle this condition gracefully, re-visit your error handling code and make changes as appropriate.To test sending an Invalid Content ID to your app:  Download or sideload your app to your Fire TV device.  Sign-in and/or activate a subscription to your app, if necessary.  Use either the Test App (see testing-launcher-integration-with-the-test-app) or ADB commands (see testing-launcher-integration-with-adb) to send an invalid ID to your app. For more information on integrating your app with the Fire TV Home Screen launcher, see launcher-integration).  Send a valid ID first to make sure the content launches properly.  Test the following invalid ID conditions:          Send an invalid ID using numerals.      Send an invalid ID using alphabetical characters.      Send an invalid ID using a mix of numbers and letters.        Verify when sending invalid IDs that the app handles the intent gracefully.The app should launch, and leave the user on the main screen within the app. If the user is not taken to the main screen within the app, modify your error handling code to do so.",
        "url": "test-cases-for-verifying-deep-links-from-your-fire-tv-catalog.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "testing-launcher-integration-with-adb-html": {
        "title": "Testing Launcher Integration with ADB",
        "tags": "[]",
        "content": "After integrating your app with the Fire TV Home Screen Launcher (see Integrating Your App with the Fire TV Home Screen Launcher), you can use Android Debug Bridge (ADB) to test your app and ensure that it responds correctly to sign in and playback intents.Use this testing option when you have not yet completed development on your app or have not yet implemented the code to respond to Intents from the launcher (see Integrating Your App with the Fire TV Home Screen Launcher). You will also need a Fire TV device to be able to test your app’s launcher integration.If you want to test launcher integration but haven’t completed your app yet or at least haven’t implemented the code to respond to Intents, use the Test App option. See Testing Fire TV Launcher Integration with the Integration Test App. Note: ADB is provided by the Android Open Source Project, not by Amazon. Any links to ADB reference materials re-direct you to the Android developer website.  Process Overview  Step 1: Install Your App to a Fire TV Device using ADB  Step 2: Testing Sign In Requests          Command Options      Examples        Step 3: Testing Playback Requests          Command Options      Examples      Process OverviewUse the following high-level process to test your Fire TV launcher integration using ADB:  Install your app to a Fire TV device using ADB.  Test your sign-in requests for your app.  Test playback requests for your app.Step 1: Install Your App to a Fire TV Device using ADBBefore you can test your app, you will need to install your app to a Fire TV device.To install your app to a Fire TV Device:  Use ADB to connect the Fire TV device to your development computer. (See Connecting ADB to Your Fire TV Device.)  Sideload your app onto the device for testing. (See Installing and Running Your App).All of the adb commands on this page use the Android activity manager (am) to send Intents to your app. For more information on the syntax and options for am, see Android Debug Bridge on the Android developer website.Step 2: Testing Sign In RequestsSign-in requests from the Fire TV Launcher include both the request itself and a reference to the requested content, which should play immediately after the user signs in. The content reference may be a URI or a data extra name/value pair, depending on your implementation.To test sign-in requests:  On the computer that you have connected to the Fire TV device via ADB, open a terminal window so that you can access the command line.  At the shell prompt (indicated by the “$”), type one of the following commands:                  If your content is specified by URI, enter:        $ adb shell am start -a &lt;signin_intent_action&gt;  -n &lt;signin_component&gt; -f &lt;signin_intent_flags&gt; -d &lt;content_uri&gt;                            If your content is specified by a data extra, enter:        $ adb shell am start -a &lt;signin_intent_action&gt;  -n &lt;signin_component&gt; -f &lt;signin_intent_flags&gt; -e &lt;data_extra_name&gt; &lt;content_id&gt;                    Command OptionsThe following table describes the available options for these two commands. Replace the text in the  with the correct values for your app:            -a &lt;signin_intent_action&gt;      Your sign-in Intent action, from the SIGNIN_INTENT_ACTION extra. Example: com.yourcompany.player.SIGN_IN              -n &lt;signin_component&gt;      The full component name of your sign-in Activity, which consists of the package and class names separated by a slash. These values are from the SIGNIN_INTENT_PACKAGE and SIGNIN_INTENT_CLASS extras, respectively. Example: com.yourcompany.player/com.yourcompany.player.MainActivity              -f &lt;signin_intent_flags&gt;      The Intent flags that you specified in the SIGNIN_INTENT_FLAGS extraas a decimal value and combined with the appropriate default launcher flags. By default, the launcher sends the following flags: • Intent.FLAG_ACTIVITY_NEW_TASK • Intent.FLAG_INCLUDE_STOPPED_PACKAGES • Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED Example decimal: 270532640              -d &lt;content_uri&gt;      URI, if the link to your content is specified by URI. Do not use the -e option if you use the -d option.              -e &lt;data_extra_name&gt;&lt;content_id&gt;      If the link to your content is specified in a way other than a URI, this is the key/value pair for that content. The key is from the DATA_EXTRA_NAME extra. Do not use the -d option if you use the -e option.      ExamplesThe following example shows the command that you might type for a sign-in Intent if your content is specified by URI:$ adb shell am start -a com.yourcompany.player.SIGN_IN  -n com.yourcompany.player/com.yourcompany.player.MainActivity -f 270532640 -d myplayer://content/12345`The following command shows the command that you might type for a sign-in Intent if your content is specified in some way other than by URI:$ adb shell am start -a com.yourcompany.player.SIGN_IN  -n com.yourcompany.player/com.yourcompany.player.MainActivity -f 270532640 -e content_id 12345`Step 3: Testing Playback RequestsAs with sign-in requests, playback requests use the data you supply to the launcher during the capability exchange. Playback requests include a content reference, which may either be a URI or a data extra name/value pair, depending on your implementation.To playback requests:  On the computer that you have connected to the Fire TV device via ADB, open a terminal window so that you can access the command line.  At the shell prompt (indicated by the “$”), type one of the following commands:                  If your content is specified by URI, enter:        adb shell am start -a &lt;playback_intent_action&gt;  -n &lt;playback_component&gt; -f &lt;playback_intent_flags&gt; -d &lt;content_uri&gt;                            If your content is specified by a data extra key/value pair, enter:        adb shell am start -a &lt;playback_intent_action&gt;  -n &lt;playback_component&gt; -f &lt;playback_intent_flags&gt; -e &lt;data_extra_name&gt; &lt;content_id&gt;`                    Command OptionsThe following table describes the available options for these two commands. Replace the text in the  with the correct values for your app:            &lt;playback_intent_action&gt;      Your playback Intent action, from the PLAY_INTENT_ACTION extra.  Example: com.yourcompany.player.PLAY              &lt;playback_component&gt;      The full component name of your playback Activity, which consists of package and class names separated by a slash. These values are from the PLAY_INTENT_PACKAGE and PLAY_INTENT_CLASS extras, respectively.  Example: com.yourcompany.player/com.yourcompany.player.MainActivity              &lt;playback_intent_flags&gt;      The Intent flags that you specified in the PLAYBACK_INTENT_FLAGS extra as a decimal value and combined with the appropriate default launcher flags. By default, the launcher sends the following flags: • Intent.FLAG_ACTIVITY_NEW_TASK • Intent.FLAG_INCLUDE_STOPPED_PACKAGES • Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED  Example decimal: 270532640.              &lt;content_uri&gt;      URI, if the link to your content is specified by URI. Do not use the -e option if you use the -d option.              &lt;data_extra_name&gt;&lt;content_id&gt;      If the link to your content is specified in a way other than a URI, this is the key/value pair for that content. The key is from the DATA_EXTRA_NAME extra. Do not use the -d option if you use the -e option.      ExamplesThe following example shows the command that you might type for a playback Intent if your content is specified by URI:$ adb shell am start -a com.yourcompany.player.PLAY  -n com.yourcompany.player/com.yourcompany.player.MainActivity -f 270532640 -d myplayer://content/12345The following command shows the command that you might type for a playback Intent if your content is specified in some way other than by URI:$ adb shell am start -a com.yourcompany.player.PLAY  -n com.yourcompany.player/com.yourcompany.player.MainActivity -f 270532640 -e content_id 12345`",
        "url": "testing-launcher-integration-with-adb.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "testing-launcher-integration-with-the-test-app-html": {
        "title": "Testing Fire TV Launcher Integration with the Integration Test App",
        "tags": "[]",
        "content": "After integrating your app with the Fire TV Home Screen Launcher (see Integrating Your App with the Fire TV Home Screen Launcher), use Amazon’s Integration Test app to ensure that your app responds correctly to capability requests as well as sign in and playback intents.This test app mimics the requests the launcher makes, and is the easiest way to ensure that you have implemented launcher integration correctly in your own app. (Note that this topic applies to Fire TV apps whose media catalogs are integrated with Fire TV.)Use this testing option when you have completed development on your app and have already implemented the code to respond to Intents from the launcher (see Integrating Your App with the Fire TV Home Screen Launcher). You will also need a Fire TV device to be able to test your app’s integration with the Integration Test App.To test a fully functional app or to specifically test sign-in and playback intents use the Android Debug Bridge (ADB) option. (See Testing Launcher Integration with ADB.)  Process Overview  Step 1: Download the Integration Test App  Step 2: Modify Your App for Testing  Step 3: Install Both Your App and the Fire TV Integration Test App to a Fire TV Device  Step 4: Test Your App with IntegrationTestProcess OverviewUse the following high-level process to test your Fire TV launcher integration with Amazon’s Fire TV Integration Test App:  Download the Integration Test App.  Update your own app to use the correct Intent package to work with the Integration Test App.  Install both your app and the Fire TV Integration Test App to a Fire TV device.  Test your app with the Fire TV Integration Test App.Step 1: Download the Integration Test AppBefore you can start testing, download the Fire TV Integration Test App to your computer:Download AppStep 2: Modify Your App for TestingYou will need to modify your app to work with the Fire TV Integration Test App.To perform this modification, make the following changes to your app:  If you have not already done so, make the changes to your app described in Integrating Your App with the Fire TV Home Screen Launcher.  Inside of your broadcast capabilities method, change the name of the com.amazon.tv.launcher to com.amazon.tv.integrationtestonly. For example, intent.setPackage(“com.amazon.tv.launcher”) should become intent.setPackage(“com.amazon.tv.integrationtestonly”). Note: The integrationtestonly intent package is only for testing. When you are finished testing, make sure to rename the Intent package back to its original name of com.amazon.tv.launcher before you submit your app to the Amazon Appstore.Step 3: Install Both Your App and the Fire TV Integration Test App to a Fire TV DeviceBoth your app and the Integration Test App will need to be installed to a Fire TV Device before you can start testing.To install your app and the Fire TV Integration Test App to a Fire TV device:  Using a network connection or USB cable, connect the Fire TV device to your computer using ADB. See Connecting to Fire TV Through ADB).  Sideload both your app and the integration tester app onto the device. See Installing and Running Your App).Step 4: Test Your App with IntegrationTestNow that both your app and the Integration Test App are available on your Fire TV device, you can start testing.To test your app:  Launch the Integration Test App:          From the Fire TV main menu, go to Settings &gt; Applications &gt; Manage All Installed Applications, and select the IntegrationTest app.      Select Launch Application.            Click Request Capabilities.    The IntegrationTest app sends a broadcast Intent to request capabilities from your app. If your app responds to that request, and includes all the required elements, the test app displays a success message and the values for each capability from your app.     Note: A successful result means only that your app responded to the broadcast. This test does not verify the correctness of any data provided by you.        Verify that capability values from your app are correct.    If the capability exchange was successful, Fire TV displays a text entry box and a Send Intent button.        Enter a content URL or ID, and click Send Intent.    The content reference may be a URI or a data extra name/ value pair, depending on your implementation. Enter a content reference that your app recognizes. If the content reference and your implementation is correct, your app launches and handles the Intent and the content reference.    After you finish testing your app, remember to change the broadcast intent package back to com.amazon.tv.launcher.  ",
        "url": "testing-launcher-integration-with-the-test-app.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "understanding-fire-tv-catalog-integration-html": {
        "title": "Understanding Fire TV Catalog Integration",
        "tags": "[]",
        "content": "Integrating your media catalog with Amazon Fire TV allows your content to be discovered and launched from the Fire TV home screen. Catalog Integration has two major components:  A catalog file that specifies the movies and TV shows that you offer through your app.  Integration between your app and the Fire TV Home Screen Launcher, which enables users to play your content directly from search and browse results.Catalog Integration allows your content to be included in the results of a search performed from the Fire TV home screen. It also allows a user to find your content while browsing Fire TV outside of your app, such as when browsing by genre (also known as “universal browse and search”). Regardless of where in the Fire TV UI users find your content, they can play it directly without needing to open your app first. Note: To begin your catalog integration with our platform, please contact Amazon for further information.  Benefits of Integrating Your Catalog with Fire TV          Universal Browse and Search Results Across Content Providers      Drive New Customer Acquisition      Retain Existing Customers      Inclusion in Featured Movies and TV        Components of Catalog Integration  Content Matching  Guidelines and Expectations for Fire TV Catalog Integration          Guidelines for Uploading Catalogs      Wait Times for Content Availability after Upload      User Experience (UX) Guidelines for Catalog Integration      Benefits of Integrating Your Catalog with Fire TVCatalog Integration allows users to seamlessly view, browse, and search for your content alongside content from Amazon and other streaming media providers within Fire TV. It provides these benefits:  Includes your content in universal browse and search results across content providers  Drives new customers to download and use your app  Retains existing customers through prioritized search results and ease of use  Qualifies content to be promoted through “Featured Movies and TV” on the Fire TV home screenUniversal Browse and Search Results Across Content ProvidersCatalog Integration allows a consolidated customer search and browse experience, regardless of which apps provide the content. For example, consider a Fire TV customer who wants to watch the fictional movie “Argoneum 2” and searches for “Argoneum” from the Fire TV home screen. Fire TV would return the following search results:The search results show all items found across all content providers with an integrated catalog, as well as consolidating multiple results for a work into a single result (see Content Matching below).If a customer ran the same search, but you had not submitted your catalog for integration while others had, the search results would include only offerings from Amazon and those providers with integrated catalogs. Customers would have to explicitly launch your app and search within it to find that you also offered that movie.Drive New Customer AcquisitionCatalog integration can drive new customers to download and use your app. When your catalog is integrated, your content is shown in Fire TV home screen search results even if a user has not downloaded your app or is not yet a subscriber to your service. If you offer a free trial subscription to new users and allow users to sign up through a Fire TV device, your version of the content can be presented in the highlighted Watch Now with.. box, depending on other available offers. (Note that these prioritization rules are subject to change without notice.)For example, the fictional TV series “Office Factor” is available to subscribers of the fictional streaming service Enyo Xtra. When a user who is not already an Enyo Xtra subscriber searches for “Office Factor”, Fire TV displays both the series information and a prompt to start a free trial with the Enyo Xtra service.When the user clicks the “Free Trial” button, Fire TV displays a screen that prompts the user to download the Enyo Xtra app to begin the free trial. Retain Existing CustomersThe detail page for a movie or TV show uses integrated catalog data to display all the available providers and options for that item, generally prioritizing them by offer type: free, subscription, rental, and purchase. This prioritization order means that your current subscribers will often see your app as the first option. Seeing your app listed as a preferred viewing option reminds customers of the value they receive from subscribing to your service. (Note that these prioritization rules are subject to change without notice.)In the following example, a subscriber to the fictional StreamTime service searches for the fictional movie “Repeat Offender”. The search results show that the movie can be either streamed through StreamTime or a digital copy can be purchased from Amazon. Due to the prioritization order, the StreamTime option is given top priority.Inclusion in Featured Movies and TVFire TV’s home screen includes a category titled “Featured Movies and TV”, with a rotating selection of works. Only integrated catalog content is eligible to be included in these promoted titles.Components of Catalog IntegrationFire TV catalog integration has two major components, both of which are required:  Catalog Data Format (CDF) file: The CDF file is an XML file that uses the schema defined by the CDF XSD file. The CDF file contains the catalog of movies and TV shows that you offer through your Fire TV app. Each work’s entry in your catalog includes metadata that describes the work, such as title, release date, cast and crew, and length. The metadata also includes the methods of viewing the work: for free, only by subscribers, or through rental or purchase. You will upload this catalog to Amazon. To learn more about the CDF file and its schema, see About the Catalog Data Format (CDF) and the Fire TV Catalog Data Format (CDF) Schema.  Amazon home screen launcher: You will configure your app to integrate with the media launcher used by Fire TV’s home screen. This allows a customer to launch content from your catalog without having to launch your app first.Content MatchingWhen a content item, such as a movie, is included in the integrated catalogs of multiple content providers, Amazon uses the item’s metadata (such as title or year of release) to identify and match them as the same actual piece of content. As a result, Fire TV’s universal browse and search can present a single entry for the item instead of separate entries for each provider.The following image shows the results of a search for the fictional movie “Argoneum”, offered by three different providers, without content matching. The user would have to select each result in turn to determine the provider and whether the movie is available for free, rental, purchase, or through subscription from that provider.Search results with 3 instances of the movie and 2 instances of a secondary resultWith content matching, the user is presented with a cleaner set of results:Search resuts with 1 instance of the movie and 1 instance of a secondary resultWhen the user selects the single “Argoneum” entry, they are then shown the three providers and the viewing options for each, all in one place.The chance of Amazon successfully matching one piece of content to another depends on the amount of information that you can provide. If you only include the item’s required elements in your CDF file, the title might be the only data available to Amazon for matching. If you include a release year, the content’s runtime, an episode number in a season or mini-series, or any other unambiguous metadata value, you will increase the chance of Amazon achieving a high-confidence match when a user searches or browses for that content.Guidelines and Expectations for Fire TV Catalog IntegrationAs a content provider participating in Fire TV catalog integration, you should ensure that your processes related to catalog updates and uploads meet the following guidelines, and set your expectations accordingly with regards to various wait times after uploading a new catalog:Guidelines for Uploading Catalogs  Amazon expects your catalog to be uploaded at least once per week, regardless of whether the catalog has changed. Your upload process should be scripted or otherwise automated so that the current catalog is uploaded on at least a weekly interval.  If your most recent successfully ingested catalog file is more than three weeks old, Amazon will disable catalog integration for your app. (In other words, if your catalog is stale for more than three weeks, or fails catalog ingestion for more than three weeks, Amazon disables the catalog integration.)Wait Times for Content Availability after Upload  Amazon will validate and ingest newly uploaded catalog files every four hours. After uploading a new catalog, you might have to wait up to four hours to see if the ingestion was successful.  All content included in a valid catalog file will be available to the user within four hours after catalog upload. However, on-device caches for shows and seasons can persist for up to ten hours, so some content could have up to a 14-hour delay in availability after catalog upload. This means that if a show is cached on a device and has a new season uploaded, the new content might not actually be visible to users for up to 14 hours.  Content will be able to be matched to content from other providers in search or browse within 4 hours of catalog upload.User Experience (UX) Guidelines for Catalog Integration  When a user selects content from your app via Fire TV’s universal search or browse results, begin playback of that content immediately; do not route the customer to your app or the work’s detail screen before starting playback.  As part of launcher integration (see Integrating Your App with the Fire TV Home Screen Launcher), make sure that you publish your users’ subscription status each time that your app opens so that the “Watch Now” option appears for current subscribers when your content is found from outside of your app.   In the event that your current available catalog becomes out of sync with your content that is actually available to users, implement error handling code to gracefully handle the use case where a user selects a content item that is not actually available for playback. If you do not implement error handling code for this scenario, the user will be taken to a black screen with no clear way to navigate back to Fire TV or your app or catalog, providing a confusing and negative user experience.To learn more about the catalog integration set-up process, including setting up your AWS account and working with the S3 tools, see Getting Started with Fire TV Catalog Integration. See Integrating Your App with the Fire TV Home Screen Launcher for the code changes needed to integrate with the launcher.",
        "url": "understanding-fire-tv-catalog-integration.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "uploading-your-catalog-html": {
        "title": "Uploading Your Catalog to Amazon",
        "tags": "[]",
        "content": "This page describes how to validate and upload your Catalog Data Format (CDF) file to Amazon’s AWS S3 bucket for catalog ingestion. Amazon strongly recommends validating your CDF file before attempting to upload; please include a validation step as part of your upload process.  Prerequisites  Validating Your CDF File  Uploading Your CDF File          Example Workflow        Additional Resources for AWSPrerequisitesBefore uploading your catalog to Amazon, you will need to set up your AWS account, and give your 12-digit AWS Account ID to your Amazon Fire TV representative. Your Fire TV representative will create your AWS S3 bucket for catalog ingestion and provide you with access to your bucket. Because Amazon creates the S3 bucket, the bucket will not appear in your AWS S3 console. However, you should be able to access the bucket via the Command Line Interface (CLI) to view the bucket contents and upload files to the bucket. The commands used to interact with your S3 bucket are given in the next sections of this page.See Setting Up Your AWS Account for Fire TV Catalog Integration for details.Validating Your CDF FileAmazon highly recommends validating your CDF file before uploading the file to AWS. Validating your file locally can help catch errors that would prevent the file from being successfully ingested and integrated with the Fire TV catalog. Validate your CDF file against the schema provided in Amazon’s CDF XSD file: CDF XSD file.Note that XML validation tools can only check that your XML is well-formed (for example, no broken or missing tags) and valid against the CDF schema (for example, no incorrectly nested elements). While XML validation should catch the most common errors in your CDF file, your CDF file could still contain errors that are not caught until the file is uploaded to AWS.Use an XML validation tool to validate your CDF file. While Amazon does not provide an XML validation tool, you can easily obtain one at no cost from a variety of sources:  If you created or edited your CDF file using an IDE, your IDE might have a built-in XML validation tool.  On a Mac or Linux, use the xmllint utility. Your Mac or Linux computer should come with these utilities already installed as part of the OS.  On Windows, a number of free XML validation tools are available for download.To use xmllint to validate your CDF file:  Download the CDF XSD file and copy or move this file to the same directory as the CDF file that you previously created.  Open a terminal window (or a command window in Windows) to access your computer’s command line interface.      At the shell prompt, type the following command:    $ xmllint --schema catalog.xsd --noout &lt;cdf_file_name&gt;.xml        The $ represents the shell prompt. Replace &lt;cdf_file_name&gt; with the actual name of your CDF file. The --noout option suppresses extra output as xmllint traverses your XML file. When finished, xmllint will report any errors that it found in your file or will report that your XML file is valid against the specified schema.  Uploading Your CDF FileYour catalogs are contained in a catalogs folder inside the S3 bucket for your catalog bucket. Use any S3 tool to upload your catalog file to this bucket and folder.To upload a CDF file to an S3 bucket:      Type the following command, substituing your CDF file name for &lt;catalog_file_name.xml&gt; and S3 bucket name for &lt;s3_bucket_name&gt;. Note that the --acl bucket-owner-full-control option is required so that Amazon will be able to read the file that you upload upload, and thus ingest your catalog.    $ aws s3api put-object --body &lt;catalog_file_name.xml&gt; --bucket &lt;s3_bucket_name&gt; --key catalogs/catalog.xml --region us-east-1 --acl bucket-owner-full-control         Note: Make sure that if you copy-and-paste this command into a terminal window that the -- characters paste as double-dashes and not as an n-dash.    This command successfully uploads files up to 2GB in size. If successful, the AWS CLI will display a set of tags for the VersionID, ETag, and Expiration for the file.        Verify that you see your catalog file in your S3 bucket. Type the following command to list all files in your S3 bucket:    $ aws s3 ls s3://&lt;s3_bucket_name&gt;/catalogs/ --region us-east-1        You may upload multiple catalogs to the catalog bucket, but Amazon only uses the most recently uploaded catalog, regardless of its name. If you find a problem with your catalog, or need to update the data in the CDF file, just upload a new file.  Example WorkflowThe following example command uploads a catalog file named my-catalog.xml to an S3 bucket named cdf-bucket:$ aws s3api put-object --body my-catalog.xml --bucket cdf-bucket --key catalogs/catalog.xml --region us-east-1 --acl bucket-owner-full-controlThis command returns the following sample output:{    \"VersionId\": \"m_QwgKPy9RJZsWperU_LEULD1waJE2He\",    \"ETag\": \"\\\"e8c38d5258ad1f3b241ae2ce347e40bc\\\"\",    \"Expiration\": \"expiry-date=\\\"Fri, 06 Jan 2017 00:00:00 GMT\\\", rule-id=\\\"Rule for the Entire Bucket\\\"\"}To verify that the my-catalog.xml file was successfully uploaded, use the following command:$ aws s3 ls s3://cdf-bucket/catalogs/ --region us-east-1This command returns a list of all catalog files currently found in the bucket:2015-12-07 15:02:17      10236 my-catalog.xml2015-12-01 15:10:28        166 other-catalog.xmlAdditional Resources for AWSThese links provide further information on AWS and Amazon S3.  Amazon Web Services: All AWS products  Amazon Simple Storage Service (S3): Secure object storage  Amazon Identity and Access Management (IAM): Define users and roles for your AWS account  Start Developing with AWS: Documentation, SDKs, and sample apps for various languages and platforms  AWS Command Line Interface (CLI): Simple access to AWS services  Tools for Amazon Web Services: All SDKs and sample code  AWS SDK For Java: Integrate AWS with your Java apps  Amazon S3 Client: Java class for accessing Amazon S3  Upload an Object Using the AWS SDK for Java: Sample code for uploading your data to Amazon S3",
        "url": "uploading-your-catalog.html",
        "product": "Fire TV Catalog"
      }
      ,
      
    
          
      "fire-app-builder-app-tour-html": {
        "title": "Take an App Tour",
        "tags": "[]",
        "content": "After you have successfully built the app, spend some time exploring the various screens. The following sections show what each screen in the the sample app in Fire App Builder.  Screens in the app  Activities Performed with Each Screen  Explore Fire App Builder’s Contents  Subfolder Contents  Configurable JSON Files Overview  Next StepsScreens in the appSplash screen. This screen appears when you first launch the app and displays only until the app finishes loading (usually less than a second). Note: You can completely customize this screen and any other screen that shows the “Fire App Builder” text. For example, in place of “Fire App Builder” you can substitute your own company name or design.After the app loads, you see the Home screen.Home screen with the ContentBrowseActivity. This view arranges the videos in various categories or groups. When you view a channel, the first video in that channel group appears as the featured background image, with its title and description in the upper-left. This is the default layout.With the Home screen, you have a couple of display options, depending on the activity you select. By default, the Home screen has the ContentBrowseActivity activity configured. However, you can also load a more compact view by associating this screen with the FullContentBrowseActivity activity instead:Home with FullContentBrowseActivity. With this activity, all the videos appear in a more compressed grid, with the categories listed on the left. None of the videos are superimposed as large featured images in the background.When you select a video, the video is highlighted with the background image appearing in the upper-right:Home screen with video selected. The selected video appears with the large image in the background.When you click the video again, the Content Details screen appears with play buttons:Content Details. This screen shows the details for a specific video, including both the title and description.If the video description extends beyond the display width available, a modal appears to allow users to see the additional description content.Content Details screen. If the description doesn't fit within the alotted space on the Content Details screen, users can expand it to read more.When you play media, the Renderer screen appears.Renderer. This screen appears when you play media.When the controls display on the video, Recommended Content appears below the controls below a dim overlay. If you click the down arrow on your remote, the recommended content shifts into prominent view without the dim overlay.Recommended Content selected and displayedIf you’ve already played the media, a different set of controls appears below the video when you view the content details.Resuming playback on the Details. If you stopped watching a video part-way through, instead of a WATCH NOW button, you see RESUME PLAYBACK and WATCH FROM BEGINNING buttons.To search for a video, select the search button on the home screen. When you do, the Search screen appears and allows you to type a keyword. The search will match the keyword against the title and description elements.Search. This screen allows users to search for media.The search results screen lists the results as media cards in a grid:Search. The search results appear as thumbnails below the search bar. Here the word bay matches a number of different videos.Activities Performed with Each ScreenActivities are the various functions the app can do. Each activity invokes a different screen. Fire App Builder has six available activities:  ContentBrowseActivity  ContentDetailsActivity  ContentSearchActivity  FullContentBrowseActivity  SplashActivity  VerticalContentGridActivity(Both ContentBrowseActivity and FullContentBrowseActivity can be used for the Home screen.)Each activity in Fire App Builder uses a different screen. The screen used by each activity is configured through the Navigator.json file (located in app &gt; assets). The graph object (shown below) from Navigator.json contains key-value pairs that associate the activity with the screen and other properties:\"graph\": {    \"com.amazon.android.tv.tenfoot.ui.activities.SplashActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_SPLASH_SCREEN\"    },    \"com.amazon.android.tv.tenfoot.ui.activities.FullContentBrowseActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_HOME_SCREEN\"    },    \"com.amazon.android.tv.tenfoot.ui.activities.ContentDetailsActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_DETAILS_SCREEN\"    },    \"com.amazon.android.tv.tenfoot.ui.activities.ContentSearchActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_SEARCH_SCREEN\"    },    \"com.amazon.android.uamp.ui.PlaybackActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_RENDERER_SCREEN\"    }  }For example, the SplashActivity displays the Splash screen. The ContentBrowseActivity displays the Home screen, and so on.You can associate any activity with any screen, but the only activity that makes sense to switch up is the ContentBrowseActivity. You can replace this activity with FullContentBrowseActivity to provide the more compact Home screen layout described earlier.The other properties for each activity in this code are as follows:            Activity property      Description                  verifyScreenAccess      Require the user to authenticate to view the screen. Set this to true if you want to require users to log in prior to viewing content. Mostly you would verify screen access for the Content Renderer screen only, so that users can get a sense of the media first and feel more enticement to log in.              verifyNetworkConnection      Require a network connection to show the screen. (If the page contains only settings and no online media, you could set this to false. But for most screens, leave this at true. )              onAction      The action to perform (such as display a certain screen) when the activity runs.      The AndroidManifest.xml file initiates the SplashActivity activity when the app starts:&lt;activity    android:name=\"com.amazon.android.tv.tenfoot.ui.activities.SplashActivity\"    android:screenOrientation=\"landscape\"&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"android.intent.action.MAIN\" /&gt;        &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;        &lt;category android:name=\"android.intent.category.LEANBACK_LAUNCHER\" /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;This SplashActivity activity loads the Splash screen.Beyond these activities and screens, you can also write your own activity and associate it with your own screen. (Details on how to make this advanced customization are beyond the scope of this documentation.)Explore Fire App Builder’s ContentsBefore you start creating your app, take a few minutes to familiarize yourself with the various libraries, modules, and components available in Fire App Builder.The available components in Fire App BuilderThe following table briefly describes each component.            Folders      Description                  AMZNMediaPlayerComponent      Used to play streaming media.              AdsInterface      An interface for ads.              AmazonInAppPurchaseComponent      Component that implements the Purchase Interface for Amazon In-app purchasing.              AnalyticsInterface      An interface for analytics.              AuthInterface      An interface for authorization.              ContentBrowser      Controller (from the Model-view-controller architectural pattern) that allows users to browse content within the app. It fetches the feed and controls flows, recipes, and configurations.              ContentModel      Model (from the Model-view-controller architectural pattern) that defines the method for storing data that the browser will use to render.              DataLoader      Reusable module to load data from the network. Commonly used for loading the feed.              DynamicParser      Configurable module to parse the feed and populate the model.              FacebookAuthComponent      Component that implements the Auth Interface for Facebook authorization.              FlurryAnalyticsComponent      Component that implements the Analytics interface for Flurry analytics.              ModuleInterface      The core code that makes different components modular in the Fire App Builder framework.              PassThroughAdsComponent      Dummy implementation for the ads interface, used by Fire App Builder. If you don’t have an ad implementation in your app, you can use this as base code to start your own ads module.              PurchaseInterface      An interface for setting up payments.              TVUIComponent      Contains the TV UI code, which is based on the Leanback Support Library. Also contains the classes for the activities.              UAMP      Universal Android Media Player. Amazon Media Player builds on top of UAMP to extend it with additional features.              Utils      Contains reusable Java classes, including security classes used to encrypt and decrypt keys used with some components (such as Facebook Authorization, Adobe Pass, and Flurry Analytics components).              Application      A sample app that uses the various libraries and components in the Fire App Builder framework. This is the app that you customize (see Download Fire App Builder and Build an App).       Note: When you open Fire App Builder in Android Studio, the “Android” view shows this folder as “app” because it’s your working app. If you switch over to the “Project” view, you’ll see that the app folder is actually named “Application.”Subfolder ContentsWithin each folder in Fire App Builder, you usually see the same pattern of subfolders. The following table describes each subfolder:            Subfolder      Contents                  build      This subfolder, required by Android, is auto-generated when the project builds. Do not edit files in the build folder.              libs      If this subfolder is included, it contains external libraries required by a component or other external service. Do not edit files in this folder. Other times the libraries required by a component are referenced as dependencies in the build.gradle file and retrieved when the project builds.              src      Contains the actual code for the component or function. The res subfolder contains resources for the component, which you will frequently work with if using the component. When you edit files, you will primarily edit files that appear within the res subfolder.              test      Unit test files. The content in test folders mirrors the content in the main folder but is meant for writing unit tests. Unit tests don’t require any Android dependencies — you can run them on your own machine without a Fire TV device. You usually don’t need to do anything in this folder.              androidTest      Tests that require an Android dependency. These tests require a Fire TV device to run the code. You usually don’t need to do anything in this folder.      Configurable JSON Files OverviewThe basic app in Fire App Builder requires almost no Java coding. Instead, you configure the app through various JSON files that contain simple key-value pairs that allow you to specify the app options you want. The following are the JSON files you can configure.            JSON or XML files to configure      Location                  Navigator.json      app &gt; assets              BasicFileBasedUrlGeneratorConfig.json      app &gt; assets &gt; configurations              BasicHttpBasedDownloaderConfig.json      app &gt; assets &gt; configurations              DataLoadManagerConfig.json      app &gt; assets &gt; configurations              LightCastCategoriesRecipe.json      app &gt; assets &gt; recipes              LightCastContentsRecipe.json      app &gt; assets &gt; recipes              LightCastDataLoaderRecipe1.json      app &gt; assets &gt; recipes              LightCastDataLoaderRecipe2.json      app &gt; assets &gt; recipes              custom.xml      app &gt; res &gt; values      (Don’t worry about configuring the JSON or XML files now. The files are listed here simply to introduce you to upcoming the configuration tasks. The point is that you can configure your app by merely adjusting JSON or XML files instead of doing Java programming.)Next StepsNow that you have a good feel for the basic functionality, libraries, and components in Fire App Builder, it’s time to start customizing it with your own content. See Load Your Media Feed.",
        "url": "fire-app-builder-app-tour.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-connecting-adb-to-fire-tv-html": {
        "title": "Connect to Fire TV Through ADB",
        "tags": "[]",
        "content": "You can use Android Debug Bridge (ADB) to connect your development computer to an Amazon Fire TV device or stick for installing, testing, and debugging your apps.Before you use ADB to connect to Fire TV or Fire TV stick, complete the following sections: Note: Android Debug Bridge is provided by the Android Open Source Project, not by Amazon.  Step 1. Enable Debugging on Amazon Fire TV  Step 2. Set Up Android Debug Bridge          Mac OS X      Windows        Step 3. Add Android Debug Bridge to Your Path          Mac OS X      Windows        Step 4: Options for Connecting ADB          Connect ADB Through the Network      Connect ADB Through USB        Update ADB  Run Your App  Troubleshooting  Using an Android TV Emulator  Next StepsStep 1. Enable Debugging on Amazon Fire TVYou must enable both ADB and debugging on your Fire TV device before you can connect to it:  From the main screen of your Fire TV, select Settings.  Select Device &gt; Developer Options.  Turn on ADB Debugging.      (Optional) If you plan to connect your computer to your Fire TV device using a USB cable, turn on USB Debugging.     Note: When USB Debugging is enabled, the USB port is unavailable for other uses such as external storage or input devices. To re-enable the USB port, turn off USB debugging.    Turn on Apps from Unknown Sources.Step 2. Set Up Android Debug BridgeAndroid Debug Bridge (ADB) is a command-line utility for running and managing Android apps on your device or emulator. ADB is available when you install Android Studio, but Windows users will need to install a special USB driver.Mac OS XNo action is required for ADB to work on Mac OS X.WindowsIf you’re on Windows and want to connect your computer to Fire TV through a USB cable, you need to install a special USB driver to connect your computer to a Fire TV device through ADB. The driver supports all the Fire TV platforms. To install the driver:  Download the USB file and extract the zip file’s contents.  Double-click the FireDevices_Drivers.  Complete the installation dialog boxes as prompted. Note: The USB driver is only certified through Windows 8.1. If you’re on Windows 10, you will need to explicitly accept that you are installing from an “un-certified source.”Step 3. Add Android Debug Bridge to Your PathYou need to add ADB to your PATH so you can more easily execute adb commands. (Your PATH is an environment variable used to specify the location of the program’s executable. If you don’t add ADB to your PATH, running adb commands will require you to browse to the &lt;Android SDK&gt;/platform-tools directory to run adb.)Mac OS XTo add ADB to your PATH on Mac:      Get the path to your Android SDK platform-tools directory:                  Open Android Studio and click the SDK Manager button .        The location to your Android SDK appears near the top next to Android SDK Location. For example: /Users/&lt;your username&gt;/Library/Android/sdk        If this is your first time opening Android Studio, there isn’t an SDK Manager button. Instead, at the Welcome to Android Studio prompt, click Configure &gt; SDK Manager and provide the location to the Android SDK.            Copy the path to the SDK and paste it somewhere convenient, such as a text editor.      Add /platform-tools to the end of the path you copied in the previous step. (“platform-tools” is the directory containing the adb executable.)      Copy the full path to your clipboard.            Use the following command to add adb to your .bash_profile, replacing /Users/&lt;your username&gt;/Library/Android/sdk/platform-tools/ with your path to your Android SDK.    echo 'export PATH=$PATH:/Users/&lt;your username&gt;/Library/Android/sdk/platform-tools/' &gt;&gt; ~/.bash_profile        Your .bash_profile file is usually in your user directory, which you can find by typing cd ~ (change to your user directory). Then type ls -a (list all) to show all files, including hidden ones.    If the file isn’t there, simply create one. You can then type open .bash_profile to see the paths listed. One of the lines should be something like this: export PATH=$PATH:/Users/&lt;your username&gt;/Library/Android/sdk/platform-tools/.        Restart any terminal sessions, and then type adb. If you successfully added ADB to your path, you will see ADB help info rather than “command not found.”  WindowsTo add ADB to your PATH on Windows:      Get the path to your Android SDK platform-tools directory:                  Open Android Studio and click the SDK Manager button .        The location to your Android SDK appears near the top next to Android SDK Location. For example: C:\\Users\\&lt;your user name&gt;\\AppData\\Local\\Android\\Sdk\\platform-tools        If this is your first time opening Android Studio, there isn’t an SDK Manager button. Instead, at the Welcome to Android Studio prompt, click Configure &gt; SDK Manager and provide the location to the Android SDK.            Copy the path to the SDK and paste it somewhere convenient, such as a text editor.      Add /platform-tools to the end of the path you copied in the previous step. (“platform-tools” is the directory containing the adb executable.)      Copy the full path to your clipboard.        Click Start and type view advanced system settings in the search box.  Click View advanced system settings.  When the System Settings dialog opens, click the Environment Variables button.  Under System Variables (the lower pane), select Path and click Edit.      Do one of the following:          On Windows 7 or 8, move your cursor to the farthest position on the right, type ; and then press Ctrl+V to insert the path to your SDK that you copied earlier. It may look like this: ;C:\\Users\\&lt;your user name&gt;\\AppData\\Local\\Android\\Sdk\\platform-tools. Click OK on each of the three open dialog boxes to close them.      On Windows 10, click the New button and add this location.        Restart any terminal sessions, and then type adb. If you successfully added ADB to your path, you will see ADB help info rather than “command not found.”Step 4: Options for Connecting ADBYou can use ADB to connect the Fire TV or Fire TV stick to your computer in two ways:  Connect ADB Through the Network. With this option, you connect using either a wired Ethernet or WiFi network connection. Both your computer and the Fire TV device must be on the same network for a network ADB connection to work.  Connect ADB Through USB. With this option, you use an A-to-A USB cable to establish a direct USB connection. Note: The following instructions apply to Generation 2 devices that have a more updated user interface. If you have a generation 1 device, the menu locations differ slightly.Connect ADB Through the NetworkYou need the IP address of your Fire TV device on your network to connect ADB to it.  If you haven’t already done so, connect your Fire TV device to a network (the same network that your computer is on). To do this, from the Fire TV home screen, go to Settings &gt; Network and select a network.  From the Fire TV home screen, select Settings.      Go to Device &gt; About &gt; Network. Make a note of the IP address listed on this screen.     Tip: Copy this IP address onto a convenient and visible place if you plan to connect regularly via the network.        Open a terminal window.    On a Mac, you can open Terminal by pressing Cmd + spacebar and then typing Terminal. On Windows, you open the Command Prompt usually by typing cmd in your program search. (The exact steps vary based on your Windows version.)    Make sure your Fire TV device and your computer are on the same network. You can use either a wifi network or a wired network.      Run the following commands, where &lt;ipaddress&gt; is the IP address of the Fire TV device noted in the previous section:    adb kill-serveradb start-serveradb connect &lt;ipaddress&gt;         Note: Make sure you added ADB to your PATH, as described in Add Android Debug Bridge to Your Path. Otherwise you will need to cd (change directories) to the platform-tools directory first and use./adb on a Mac or adb on Windows to run adb commands.    If the connection was successful, ADB responds with the message:    connected to &lt;ipaddress&gt;:5555            Verify that the Fire TV device appears in the list of devices:    adb devices        ADB responds with the message:    List of devices attached&lt;ipaddress&gt;:5555  device      If the serial number does not appear after running adb devices, update ADB and then repeat the steps here. Tip: You don’t always need to kill and start the server with ADB. Usually you can just run the adb connect &lt;ipaddress&gt; command.Connect ADB Through USBTo connect your computer to Fire TV through USB, you need an A-to-A USB cable. Note that you must have a Fire TV, not a Fire TV Stick, because only Fire TV (the box) has the USB cable port.  If you’re on Windows, install the USB driver as described in Set Up Android Debug Bridge.  Connect your Fire TV to a USB port on your computer.      Run the following commands:    adb kill-serveradb start-serveradb devices      After the last command, ADB responds with the following message, where &lt;serialno&gt; is the serial number of the device:List of devices attached&lt;serialno&gt; deviceIf the serial number does not appear after running adb devices, update ADB and then repeat the steps here.After ADB connects your computer to your Fire TV device, when you open Android Studio and click the Run App button, you’ll be prompted with a dialog box like this:In this example, “Amazon AFTS” refers to Fire TV (Generation 2).Update ADBIf your device isn’t listed when you type adb devices, try updating ADB:      Open a terminal session and navigate to your Android SDK tools directory.    In Android Studio, you can see the installation directory by going to Tools &gt; Android &gt; SDK Manager or by clicking the SDK Manager button . The directory is listed next to Android SDK Location.        In your Terminal or Command Prompt, change directories (cd) to your Android SDK directory, and then cd one level down to tools. (The tools directory is contained within the SDK directory.)        Run one of the following commands to update ADB:    Mac:    ./android update adb        Windows:    android update adb        You receive a message that says ADB has been updated.  Run Your AppAfter you have connected your computer to your Fire TV device through ADB, you can build and run your app on the Fire TV device. In Android Studio, click the Run App button .TroubleshootingIf you receive a message such as the following: unable to connect to 192.168.0.6:5555: Operation timed outorerror: device offlinetry any of the doing the following:  Make sure both Fire TV and your computer are using the same network and router.  When connecting wireless with adb connect &lt;ipaddress&gt;, make sure you’re typing the IP address correctly, with all the required dots .  Close Android Studio and any other emulators or USB cable connections.  Kill (adb kill-server) and restart (adb start-server) the server.  Restart Fire TV (Settings &gt; Device [or System] &gt; Restart).  Restart your router.  Update ADB.  Search online for the error message you’re seeing.Using an Android TV EmulatorIf you absolutely cannot use a Fire TV device to test your app, there is limited support for using an emulator. See Use an Android TV Emulator to Run Your App.Next StepsWith ADB all set up, you’re ready to download and build Fire App Builder.",
        "url": "fire-app-builder-connecting-adb-to-fire-tv.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-download-and-build-html": {
        "title": "Download Fire App Builder and Build an App",
        "tags": "[]",
        "content": "To build the sample app with Fire App Builder, complete the instructions in the following sections:  1. Clone the Fire App Builder Project  2. Set Up the JDK  3. Install Android Studio and the Necessary Tools and SDKs  4. Open the Sample App  5. Customize the Fire App Builder Sample Project  Next Steps1. Clone the Fire App Builder ProjectFire App Builder is available in a Github repository (https://github.com/amzn/fire-app-builder) that you can download or clone. Cloning a repo allows you to get updates from the repository when they become available.To clone the repo:  Get git, if you don’t already have it.      If you use Windows, configure git to allow symbolic links (symlinks):    git config –global core.symlinks true         Note: On Windows, if you clone the repo without git’s symbolic linking configured to true, Fire App Builder won’t build.    Go to https://github.com/amzn/fire-app-builder.  Click Clone or Download, and then copy the clone URL: https://github.com/amzn/fire-app-builder.git  Open your command line and browse to a convenient directory for the project.      Clone the project:    git clone https://github.com/amzn/fire-app-builder.git        git is initialized in a directory called fire-app-builder and the Fire App Builder project is downloaded.     Tip: If you want to clone the repo into an existing (empty) folder, first browse to the folder on the command line and then run git clone https://github.com/amzn/fire-app-builder.git . to copy the repo into the existing folder. Or git clone https://github.com/amzn/fire-app-builder.git myspecialfolder to download the project into a folder called myspecialfolder.  2. Set Up the JDKYou need the Java Development Kit (JDK) from Oracle to compile Java apps on your machine.First check to see if you already have the JDK. Open Terminal or Command Prompt and type java -version. If you have the JDK, the response should be something like this:java version \"1.8.0_101\"Java(TM) SE Runtime Environment (build 1.8.0_101-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)On Windows you can also manually look in a directory such as C:\\Program Files\\Java\\jdk1.8.0\\ to see if the JDK is there.If you don’t have the JDK, download the appropriate version of the JDK Installer for your machine from Java SE Development Kit Downloads and run it.For more details, see the following:  Mac: 10 JDK 8 Installation for OS X  Windows: JDK Installation for Microsoft Windows. (Specifically, see “Running the JDK Installer” and “Updating the PATH Environment Variable.”)  For other operating systems and information, see JDK 8 and JRE 8 Installation Start Here.3. Install Android Studio and the Necessary Tools and SDKsTo work with Fire App Builder, you need to install Android Studio, the official IDE for Android projects.See Getting Started with Android Studio and Install Android Studio for information about setting up the Android Studio development environment on your machine.The Fire App Builder project requires you to have certain SDK tools and APIs installed with Android Studio. Note that selecting these tools from the Standalone SDK Manager isn’t entirely necessary. When you open the Fire App Builder project (as described in the next section, Open the Sample App), Android Studio will prompt you to install any build tools or APIs that you’re missing. For example, you’ll see messages such as the following:Or you may see the following in the Gradle Console:Clicking these links will install the missing tools and attempt to rebuild the project. You can simply keep opening the project and installing any missing tools as prompted until Android Studio no longer complains.However, you can also open the Standalone SDK Manager and install all the tool and SDK requirements ahead of time. To install the necessary tools:  Go to Tools &gt; Android &gt; SDK Manager (or simply click the SDK Manager button ).  In the Preferences dialog box that opens, click the Launch Standalone SDK Manager link.      Make sure you have at least the following tools, APIs, and SDKs selected and installed:        After selecting the check boxes, click the Install packages… button.4. Open the Sample App Warning: Allow about 30-40 minutes for Android Studio to download and build the app the first time.In this step, you will open the “Application” project from Fire App Builder in Android Studio and build the app:  Start Android Studio.      At the Welcome screen, click Open an existing Android Studio project.        Note that if you don’t see this welcome screen, you most likely have not configured Android Studio with the JDK or any Android SDKs.        Inside the Fire App Builder project folder, select the Application folder, and then click OK.        Depending on the latest release of Gradle, you may be prompted to update Gradle. If prompted, click Don’t remind me again for this project.    Gradle starts importing and building the project.     Note:  The first time you open the project, it can take anywhere from 20-40 minutes for Gradle to build the project, depending on the assets Gradle needs to download as well as your network and processor speed. Subsequent times should take about a minute or less. While you’re waiting, consider taking an app tour to become familiar with the app, and also consider exploring the Settings options on your Fire TV device.        Open the Gradle Console by clicking Gradle Console in the lower-right corner so you can monitor the progress of the Gradle Build. This will let you know if the build succeeds or if Android Studio requires other downloads. Wait until Gradle finishes building.    If Android Studio highlights any missing libraries or SDKs, follow the prompts to download and fix the issues.    When finished, you should see a message in the Gradle Console that says BUILD SUCCESSFUL. When Gradle finishes building the project, Android Studio will show the following directories in the Android view:        When Android opens the project, by default the Android view is shown (circled in red in the previous screenshot), and the “Application” folder is simply referred to as “app.” The Android view flattens the project’s files and displays the most commonly used files into a more usable arrangement, but the actual structure of the files differs on your computer disk. (The “Project” view will show you the actual arrangement of all the folders and files.)     Note: Unless otherwise specified, this documentation refers to locations of files using the Android view.    Connect your computer to your Fire TV device following the instructions in Connecting to Fire TV Through ADB.  Click the Run ‘app’ button .      In the Select Deployment Target dialog box, select Amazon, and then click OK.        In the Select Deployment Target dialog box, AFTS refers to Amazon Fire TV (Generation 2). If you have the stick, it will say AFTT (Generation 2) or AFTM (Generation 1).     Tip: If you don’t see the Amazon option, you haven’t connected your computer to the Fire TV device through ADB. If you don’t have a Fire TV, there is limited support for using an emulator.    When the app builds successfully, your Fire TV device will load the application. See Take an App Tour provides a screen-by-screen walkthrough of the app.    If you run into build failure, you can try cleaning and rebuilding the project (Build &gt; Clean Project or Build &gt; Rebuild Project).    If you close the app on your Fire TV, you can relaunch it using the Fire TV UI by going to Settings &gt; Applications &gt; Manage Installed Applications &gt; Fire App Builder with your remote control.    Note that ADB builds the app on your connected device in a temporary folder. When you disconnect your device, the app will no longer be available on the Fire TV. If you want to permanently install the app onto your Fire TV, you will need to sideload the app onto your device. See Installing and Running Your App.  5. Customize the Fire App Builder Sample ProjectThe first step in creating your app is to customize the “Application” folder. The Application folder contains the sample app created with Fire App Builder. You have two options for customizing the Application folder. The option you choose depends on how you want to handle later updates that you might pull from the Github repo:  Option 1: Duplicate the Application folder and its files: When you run git pull to get later updates from the Fire App Builder repo, you won’t have to resolve any merge conflicts for potential updates to Application’s files. However, if there are updates to the Application folder and its contents, you won’t be prompted to merge them into your project. Additionally, if code in other folders requires updates to the Application folder, your project may break without these updates.  Option 2: Directly customize the Application folder and its files: When you run git pull to get later updates from the Fire App Builder repo, you will be prompted with merge conflicts that you’ll have to sort through. It will be more tedious to get the updates, and you’ll need to be familiar with how to resolve merge conflicts with git repos. However, you will be sure not to miss any updates to the Application folder and its files.To customize the Application folder:  In Android Studio, close the Fire App Builder project by going to File &gt; Close Project.  Using Finder (Mac) or your File Explorer (Windows), browse to the directory where you downloaded Fire App Builder. Do one of the following:          Duplicate the Application folder (option 1). Then rename the copy (for example, “Gizmoapp”).      Directly rename the Application folder (option 2) (for example, “Gizmoapp”).        Inside your customized Application folder (“Gizmoapp”), delete the build folder (which stores the generated app).  In Android Studio, from the Welcome screen that is displayed, click Open an existing Android Studio project. Select your customized Application folder (“Gizmoapp”) within the Fire App Builder folder, and click OK.  If prompted about upgrading Gradle plugin settings, click Don’t remind me again for this project.  Expand the Project pane (but not the Project view) in the upper-left corner to view the files.  In the app folder, expand res &gt; values and open the strings.xml files.      In the app_name string, type the name of your app.    Note that the AndroidManifest.xml file (inside app &gt; manifests) reads the name of the application from the string you just edited. (In Android Manifest, the code referencing the string is android:label=\"@string/app_name\". This is how most of Fire App Builder is set up — code that you customize is extracted out into XML files so you don’t have to directly edit Java.)        Open your app’s AndroidManifest.xml file (located in app &gt; manifests) and update the com.amazon.android.calypso package name to a package name that reflects your app’s new name. For example, if your app was named “Gizmoapp,” you might change it to the following:    &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.amazon.android.gizmoapp\"&gt;        The sample app in Fire App Builder doesn’t have any classes in the com.amazon.android.calypso package, but you can add custom classes to overwrite existing Fire App Builder functionality or add to it.    Go to Build &gt; Clean Project to clean up any artifacts from the previous app. (This process takes several minutes.)  Build your new app by clicking the Run ‘app’ button .Next StepsNow that you’ve built and customized the default app in Fire App Builder, see Take an App Tour to get more familiar with what Fire App Builder offers.",
        "url": "fire-app-builder-download-and-build.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-configure-navigator-open-feeds-html": {
        "title": "Configure Navigator -- Open Feeds",
        "tags": "[]",
        "content": "If your feed is openly accessible (that is, no tokens are required), follow the steps in the section below. In contrast, if your feed requires tokens, see Configure Navigator – Token-based Feeds instead. For an overview to configuring Navigator, see Navigator Configuration Overview.  Configure Navigator.json for Non-token-based Feeds  Handling Live Media  Hard-Coding Your Categories  Next StepsConfigure Navigator.json for Non-token-based FeedsUse this approach for feeds that don’t require tokens to access the media.  Open the Navigator.json file (located in app &gt; assets).      Look for the globalRecipes object:    \"globalRecipes\": [    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    },    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    }]            Make the number of categories and contents objects match the number of media URLs in your URL file. For example, if you have 4 media URLs, you would need four sets of these categories and contents objects and a different DataLoaderRecipe for each.    In this scenario, your URL file (which you configured in Load Your Media Feed) might look like this:    {  \"urls\": [    \"http://www.lightcast.com/api/firetv/channels.php?app_id=263&amp;app_key=4rghy65dcsqa&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=249&amp;app_key=gtn89uj3dsw&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=267&amp;app_key=6tgbfr4edc2x&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=273&amp;app_key=u8jnsaq2rfgy&amp;action=channels_videos\"  ]}        As a result, your globalRecipes object in Navigator.json would look as follows:    \"globalRecipes\": [    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    },    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    },    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe3.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe3.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    },    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe4.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe4.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    }]         Note: Although the sample app in Fire App Builder has 4 media URLs in the URL file, you see only two DataLoaderRecipe files. This is because only 2 of the 4 media URLs are actually used — there are more than enough videos already.        If you haven’t already done so, increment the number in the DataLoaderRecipe files for each line of media in your URL file. If you have 4 media URLs, you would increment the DataLoaderRecipe by one each time (LightCastDataLoaderRecipe1.json, LightCastDataLoaderRecipe1.json, LightCastDataLoaderRecipe3.json, and LightCastDataLoaderRecipe4.json).     Note: Optionally, you can rename the files to a name that more closely reflects your app, or you can leave them as LightCast.        As needed, create the additional DataLoaderRecipe files by duplicating the LightCastDataLoaderRecipe1.json file and incrementing the index number for each file:    LightCastDataLoaderRecipe1.json would look like this:    {  \"task\": \"load_data\",  \"url_generator\": {    \"url_index\": \"0\"  }}        LightCastDataLoaderRecipe2.json would look like this:    {  \"task\": \"load_data\",  \"url_generator\": {    \"url_index\": \"1\"  }}        LightCastDataLoaderRecipe3.json would look like this:    {  \"task\": \"load_data\",  \"url_generator\": {    \"url_index\": \"2\"  }}        LightCastDataLoaderRecipe4.json would look like this:    {  \"task\": \"load_data\",  \"url_generator\": {    \"url_index\": \"3\"  }}        Each of these DataLoaderRecipe files will load the data from each line of your URL file (urlFile.json):    {  \"urls\": [    \"http://www.lightcast.com/api/firetv/channels.php?app_id=263&amp;app_key=4rghy65dcsqa&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=249&amp;app_key=gtn89uj3dsw&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=267&amp;app_key=6tgbfr4edc2x&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=273&amp;app_key=u8jnsaq2rfgy&amp;action=channels_videos\"  ]}       Note: The file construction is rather manual here, but here’s what’s happening. Fire App Builder will first query for the categories, and then the contents. Fire App Builder can only get one URL at a time, so if your media feed consists of multiple URLs stored in the urlFile.json file (as is the case with the Fire App Builder sample app), you’ll need to repeat the categories and contents objects for each URL.Handling Live MediaIf you have live media, you can adjust the app so that just one button appears on the Content Details screen: Watch Now. (This is because with live content, you can’t rewind and “Watch from Beginning.”)If you want to mark your entire feed as live, open Navigator.json (located in your app &gt; assets folder), and add the following property shown in red. Some content before and after the object is shown to provide context.     ...{      \"categories\": {        \"name\": \"Hardcoded Category Name\"      },      \"contents\": {        \"dataLoader\": \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\": \"recipes/LightCastAllContentsRecipe.json\"      },      \"recipeConfig\": {        \"liveContent\": true      }    }  ],  \"graph\": {    \"com.amazon.android.tv.tenfoot.ui.activities.SplashActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_SPLASH_SCREEN\"    },    \"com.amazon.android.tv.tenfoot.ui.activities.ContentBrowseActivity\": {    ...If you have only some media that is live, and it’s mixed in with other content that isn’t live, you can match this content in the matchList parameter when you query for your contents. Here’s an example:{  \"cooker\": \"DynamicParser\",  \"format\": \"xml\",  \"translator\":\"ContentTranslator\",  \"model\": \"com.amazon.android.model.content.Content\",  \"modelType\": \"array\",  \"query\": \"rss/channel/item\",  \"matchList\": [    \"title/#text@title\",    \"id/#text@id\",    \"description/#text@description\",    \"url/#text@url\",    \"image/#text@cardImageUrl\",    \"image/#text@backgroundImageUrl\",    \"live/#text@live\"  ]}In this example, live/#text is used to target the part of the feed that contains the live tag.Hard-Coding Your CategoriesIf your feed doesn’t include categories in the feed structure, you can hard-code a category name in Navigator.json and insert the entire media feed for that hard-coded category. Instead of loading your categories from the LightCastCategoriesRecipe.json file, you configure the categories inside the globalRecipes object like this:\"globalRecipes\": [{  \"categories\" : {    \"name\" : \"Hard-coded category name\"  },  \"contents\" : {    \"dataLoader\" : \"recipes/YourAppNameDataLoaderRecipe1.json\",    \"dynamicParser\" : \"recipes/YourAppNameContentsRecipe.json\"  } }]Just load the contents recipe, not the categories recipe (since you don’t have categories in your feed). The contents object is loaded in the same way described in the previous section, with a separate DataLoaderRecipe[#] file for each media URL in the URL file.Next StepsNow that your feed is configured, it’s time to start customizing the look and feel of your app. See Customize the Look and Feel of Your App.",
        "url": "fire-app-builder-configure-navigator-open-feeds.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-configure-navigator-token-feeds-html": {
        "title": "Configure Navigator -- Token-based Feeds",
        "tags": "[]",
        "content": "If your feed requires a token to view the content, follow the steps in the section below. In contrast, if your feed is openly accessible, see Configure Navigator – Open Feeds. For an overview in configuring Navigator, see Navigator Configuration Overview.  Configure Navigator.json for Token-based Feeds  Handling Live Media  Hard-Coding Your Categories  Next StepsConfigure Navigator.json for Token-based FeedsUse these instructions if you have media feeds that are token-based. In this step, you will configure Navigator.json with the category and content recipe files you created earlier.      Open the Navigator.json file (located in app &gt; assets) and look for the globalRecipes object:    \"globalRecipes\": [    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    },    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    }]            Duplicate the categories and contents pairs for as many media feeds as you have. In this example, there are two media feeds, so there are two sets of categories and contents objects. Suppose you have 4 media feeds. Then your globalRecipes object would look like this:    \"globalRecipes\": [    {      \"categories\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"      },      \"contents\" : {        \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"      }    },     {       \"categories\" : {         \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",         \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"       },       \"contents\" : {         \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe2.json\",         \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"       }     },     {       \"categories\" : {         \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe3.json\",         \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"       },       \"contents\" : {         \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe3.json\",         \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"       }     },     {       \"categories\" : {         \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe4.json\",         \"dynamicParser\" : \"recipes/LightCastCategoriesRecipe.json\"       },       \"contents\" : {         \"dataLoader\" : \"recipes/LightCastDataLoaderRecipe4.json\",         \"dynamicParser\" : \"recipes/LightCastContentsRecipe.json\"       }     }]        Remember to separate items in the array with commas.        If you haven’t already done so, update the LightCastDataLoaderRecipe file names to increment each time (LightCastDataLoaderRecipe1.json, LightCastDataLoaderRecipe2.json, LightCastDataLoaderRecipe3.json, LightCastDataLoaderRecipe4.json) for each CategoriesRecipe and ContentsRecipe instance. This is because the DataLoaderRecipe can only load one URL at a time, so if you have 4 URLs in your URL file, you need 4 DataLoaderRecipe files to load all the feeds.     Note: Optionally, you can rename the files to a name that more closely reflects your app, or you can leave them as LightCast.        Open each of your LightCastDataLoaderRecipe.json files and replace the contents with the following:    {  \"task\" : \"cache_data\",  \"data_file_path\" : \"/\",  \"url_generator\" : {      \"base_url\" : \"http://yourcompany.com/mediafeed?id=$$token$$\",      \"token_generation_url\" : \"http://yourcompany.com/url_to_generate_token\"  }}            In each of your DataLoaderRecipe files, configure the base_url and token_generation_url with the same values you used in BasicTokenBasedUrlGeneratorConfig.json (inside assets &gt; configurations). However, for each LightCastDataLoaderRecipe, load a different media feed URL, so that each base_url value is unique.  Handling Live MediaIf you have live media, you can adjust the app so that just one button appears on the Content Details screen: Watch Now. (This is because with live content, you can’t rewind and “Watch from Beginning.”)If you want to mark your entire feed as live, open Navigator.json (located in your app &gt; assets folder), and add the following property shown in red. Some content before and after the object is shown to provide context.     ...{      \"categories\": {        \"name\": \"Hardcoded Category Name\"      },      \"contents\": {        \"dataLoader\": \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\": \"recipes/LightCastAllContentsRecipe.json\"      },      \"recipeConfig\": {        \"liveContent\": true      }    }  ],  \"graph\": {    \"com.amazon.android.tv.tenfoot.ui.activities.SplashActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_SPLASH_SCREEN\"    },    \"com.amazon.android.tv.tenfoot.ui.activities.ContentBrowseActivity\": {    ...If you have only some media that is live, and it’s mixed in with other content that isn’t live, you can match this content in the matchList parameter when you query for your contents. Here’s an example:{  \"cooker\": \"DynamicParser\",  \"format\": \"xml\",  \"translator\":\"ContentTranslator\",  \"model\": \"com.amazon.android.model.content.Content\",  \"modelType\": \"array\",  \"query\": \"rss/channel/item\",  \"matchList\": [    \"title/#text@title\",    \"id/#text@id\",    \"description/#text@description\",    \"url/#text@url\",    \"image/#text@cardImageUrl\",    \"image/#text@backgroundImageUrl\",    \"live/#text@live\"  ]}In this example, live/#text is used to target the part of the feed that contains the live tag.Hard-Coding Your CategoriesIf your feed doesn’t include categories in the feed structure, you can hard-code a category name in Navigator.json and insert the entire media feed for that hard-coded category. Instead of loading your categories from the LightCastCategoriesRecipe.json file, you configure the categories inside the globalRecipes object like this:\"globalRecipes\": [{  \"categories\" : {    \"name\" : \"Hard-coded category name\"  },  \"contents\" : {    \"dataLoader\" : \"recipes/YourAppNameDataLoaderRecipe1.json\",    \"dynamicParser\" : \"recipes/YourAppNameContentsRecipe.json\"  } }]Just load the contents recipe, not the categories recipe (since you don’t have categories in your feed). The contents object is loaded in the same way described in the previous section, with a separate DataLoaderRecipe[#] file for each media URL in the URL file.Next StepsNow that your feed is configured, it’s time to start customizing the look and feel of your app. See Customize the Look and Feel of Your App.",
        "url": "fire-app-builder-configure-navigator-token-feeds.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-configure-navigator-html": {
        "title": "Navigator Configuration Overview",
        "tags": "[]",
        "content": "The Navigator.json file (located in app &gt; assets) defines what type of user interface elements are in the app and how they communicate with each other, what activities are associated with the apps, the layouts, and more.After you have set up your recipes, you need to configure the Fire App Builder UI to use this information. To do this, you will configure the globalRecipes object in the Navigator.json file with the categories and contents recipes you customized earlier.  DataLoaderRecipe  Two Kinds of FeedsDataLoaderRecipeThe DataLoaderRecipe file loads a media feed URL. Because DataLoaderRecipe can load only one media feed URL at a time, if you have multiple media feed URLs, you will have to create multiple DataLoaderRecipe files, each time referencing the same category and contents recipes. This can be somewhat manual to set this up, but once set up, you won’t need to touch it again.Two Kinds of FeedsThe approaches for configuring Navigator differ for token or non-token-based feeds. See one of the following:  Configure Navigator – Token-based Feeds: Use these instructions if you publish your media details in a media feed whose access is restricted by a token.  Configure Navigator – Open Feeds: Use these instructions if you publish your media details in a media feed that is open and unrestricted.",
        "url": "fire-app-builder-configure-navigator.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-load-media-feed-html": {
        "title": "Load Your Media Feed",
        "tags": "[]",
        "content": "The heart of your app is the media feed. This feed contains your video content, including titles, descriptions, thumbnails, and other details for each media object.Since different media feeds have different structures (with different terms for the various properties or elements), Fire App Builder queries your media feed for the needed components and converts the queried result to a structure and terminology that aligns with Fire App Builder’s content model. Before you write these queries (specifying them in categories and content recipes), you must first load your media feed following the instructions here.Two Fire App Builder components are used to load and configure the media feed: DataLoader and DynamicParser. The DataLoader module loads the data feed, and DynamicParser configures the structure and key values of the feed so that Fire App Builder can read it. Rather than working in Java, you configure both of these modules through JSON files. The Java code will read from the values in various JSON files.  Types of Feeds          Load Token-based Feeds      Load Open Feeds        Other Options for Loading the Feed  Live Feeds  Loading a Static Feed That Is Packaged with Your App  Next StepsTypes of FeedsYou can load the following types of feeds:  Token-based Feeds  Open FeedsLoad Token-based FeedsUse these instructions if you publish your media details in a web feed whose access is restricted by a token.      Open the DataLoadManagerConfig.json file (located in app &gt; assets &gt; configurations).     Tip: In Android Studio, instead of browsing folders, you can press Shift key twice and then type the file name to quickly find a file.    Leave the value for the data_downloader.impl option as is: com.amazon.dataloader.datadownloader.BasicHttpBasedDataDownloader.  If desired, update the options for these two properties:          is_cache_manager_enabled: Whether your feed is cached in the app. Caching your feeds speeds up screen loading with the media retrieved, but the cache will not reflect the latest updates to the feed until the data loader is updated or until the feed is expired. Options are true or false. Usually leave this as true.      data_updater.duration: The interval (in seconds) when the data loader refreshes your feed and retrieves the latest updates. When the data loader updates, the cache gets purged. The default is 2000 seconds, or 5.5 hours.         Note: Each time users start the app, your app’s cache is automatically purged and the feed is refreshed.        Open the BasicHttpBasedDownloaderConfig.json file (located in app &gt; assets &gt; configurations) and change the value from com.amazon.dataloader.datadownloader.BasicFileBasedUrlGenerator to com.amazon.dataloader.datadownloader.BasicTokenBasedUrlGenerator:    {  \"url_generator_impl\": \"com.amazon.dataloader.datadownloader.BasicTokenBasedUrlGenerator\"}            Create a file inside app &gt; assets &gt; configurations called BasicTokenBasedUrlGeneratorConfig.json. Inside the file, create a JSON object that includes two key-value pairs as follows:    {  \"base_url\" : \"http://yourcompany.com/mediafeed?id=$$token$$\",  \"token_generation_url\" : \"http://yourcompany.com/url_to_generate_token\"}            Customize the values for both base_url and token_generation_url with your company’s actual values.    The base_url is the URL to your media feed. The token_generation_url contains a link to a URL that generates the token to access the URL.    In this example, the token is inserted into the URL with $$token$$. (Your media URL may insert the token in some other way. If so, adjust the placement of the $$token$$ where it should appear.)    The parameters from this BasicTokenBasedUrlGeneratorConfig.json file (base_url and token_generation_url) get passed to the BasicTokenBasedUrlGenerator class (located in DataLoader &gt; java &gt; com.amazon.dataloader). The BasicTokenBasedUrlGenerator class constructs a URL which is then consumed by the BasicHttpBasedDataDownloader class. The BasicHttpBasedDataDownloader class gets and retrieves the content from the URL.  Load Open FeedsUse these instructions if you publish your media details in a web feed that is open and unrestricted, that is, no token is required to access the media.      Open the DataLoadManagerConfig.json file (located in app &gt; assets &gt; configurations).     Tip: In Android Studio, instead of browsing folders, you can press Shift key twice and then type the file name to quickly find a file.        Ensure the value for the data_downloader.impl option is com.amazon.dataloader.datadownloader.BasicHttpBasedDataDownloader:    {  \"data_downloader.impl\": \"com.amazon.dataloader.datadownloader.BasicHttpBasedDataDownloader\",  \"is_cache_manager_enabled\": true,  \"data_updater.duration\": 14400}            Open the BasicHttpBasedDownloaderConfig.json file (located in app &gt; assets &gt; configurations) and ensure the value for url_generator_impl is com.amazon.dataloader.datadownloader.BasicFileBasedUrlGenerator:    {  \"url_generator_impl\" : \"com.amazon.dataloader.datadownloader.BasicFileBasedUrlGenerator\"}            Open the BasicFileBasedUrlGeneratorConfig.json file (located in app &gt; assets &gt; configurations) and verify the contents matches the code below. This file specifies the location of the url_file that will contain your media feed. To make things easiest, leave the file name as the default:    {  \"url_file\" : \"urlFile.json\"}            Open the urlFile.json (located in app &gt; assets) and list your media feed URLs.    {  \"urls\": [    \"http://www.lightcast.com/api/firetv/channels.php?app_id=263&amp;app_key=4rghy65dcsqa&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=249&amp;app_key=gtn89uj3dsw&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=267&amp;app_key=6tgbfr4edc2x&amp;action=channels_videos\",    \"http://www.lightcast.com/api/firetv/channels.php?app_id=273&amp;app_key=u8jnsaq2rfgy&amp;action=channels_videos\"  ]}      Other Options for Loading the FeedIf neither of these options work for you to load your feed, you can write your own data loader by adding a class in the DataLoader folder that implements the Dataloader interface. Additionally, if your feed is generated from a REST endpoint, you will have to write your own data downloader.Live FeedsIf you have a live TV feed, there’s nothing special you need to do to load it. You can load it the same way as your other media. However, when you configure options in Navigator.json, you can add a parameter that tells Fire App Builder to  remove the “Watch from Beginning” button for live streams. You can also identify live media through tags when the content recipe. See Navigator Configuration Overview for more details.Loading a Static Feed That Is Packaged with Your AppFor testing purposes, you may want to load a static feed that is packaged within your app. You wouldn’t normally do this, since you wouldn’t be able to update the feed without resubmitting a new version of your app. Hence this would be done for testing purposes only.To load a static feed that is packaged inside your app:  Open the DataLoadManagerConfig.json file (located in app &gt; assets &gt; configurations).  Change the value for data_downloader.impl to com.amazon.dataloader.datadownloader.BasicFileBasedDownloaderConfig.  Open the BasicFileBasedDownloaderConfig.json file (located in app &gt; assets &gt; configurations).      If desired, you can rename the XML file:    {  \"data_file_path\": \"GenericMediaData.xml\"}        Place your feed file into the app &gt; assets folder.Next StepsLoading the feed is just the first step. You have to help Fire App Builder identify the categories and content in your feed. See Recipe Configuration Overview.",
        "url": "fire-app-builder-load-media-feed.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-set-up-recipes-categories-html": {
        "title": "Set Up the Category Recipe",
        "tags": "[]",
        "content": "In this step, you will query for the categories from your feed. Categories group your media into different collections or channels. It’s a way of organizing your media so that all your video isn’t in one long list. For a general overview of recipe configuration, see Recipe Configuration Overview.  Configure the Category Recipe          query Parameter                  JSON Feeds          XML Feeds                    matchList Parameter      keyDataType Parameter        Feeds without Categories  Next StepsConfigure the Category Recipe  Open the LightCastCategoriesRecipe.json file (located in app &gt; assets &gt; recipes).      Configure the file’s values as explained in the following table. If parameters need more explanation, the sections below the table provide more detail.    KeyDescription            cooker                      Defines which utility will take the parameters defined in the recipe and execute the logic. In other words, the cooker “cooks” the recipe. Leave it at the default value: DynamicParser.                      format                      Specifies the data format for the incoming data feed. Options are json or xml.                      translator                      Specifies whether translation or reflection is used when converting your feed’s objects to the Fire App Builder content model. Translation is faster and recommended. To use translation, simply leave the value at the default: ContentContainerTranslator. If you want to use reflection instead, remove the translator parameter altogether from the recipe. Also see the “How do I use reflection…” question in the FAQ, because using reflection will require a change in the names used in the matchlist parameter.                      model                      Specifies the content model for the data. The content model provides the structure for your content and maps it into the Fire App Builder UI. Leave it at the default: com.amazon.android.model.content.ContentContainer.                      modelType                      Specifies whether the feed is an array or a single object. Available options are array or single. Almost all feeds are array. For example, if your JSON feed is enclosed within square brackets, or your XML feed has nested angle brackets, choose array. If your feed is structured as a single object, choose single.                          query                      A query used to return categories from your media feed. The syntax of the query depends on the structure of your feed. You will need to construct the right query to get your categories. For JSON feeds, use Jayway JsonPath syntax for the query syntax. For XML feeds, use XPath expressions for the query syntax. See query Parameter below for more details.                          queryResultType                      If the result from the query (a specified in the query parameter) returns a list of strings, include this queryResultType parameter and set it equal to []$. If the query’s result is an object (a map), omit this parameter. (Fire App Builder needs to know the result type because it will needs to push an object into a Java hashmap.)                          matchList                      The query that you defined in the query parameter returns a result. This result needs to be mapped from your feed’s names to the names Fire App Builder uses in its content model. The matchList parameter maps the results from the query to the name for media categories in Fire App Builder. See matchList Parameter for more details.                      keyDataType                       The media objects that are related to the category. It’s essential to identify which media should be grouped into which category. Similar to matchList, you target the items on the left followed by @ and then keyDataPath to map and identify these media objects to the category. For example: StringKey@keyDataPath. See keyDataType Parameter for more details.            query ParameterThe syntax you use differs between JSON and XML. See the section that is relevant to your feed:  JSON Feeds  XML FeedsJSON FeedsThe sample app in Fire App Builder reads from a generic LightCast media feed that uses a JSON format. The Categories recipe uses the following value for the query parameter to return a list of categories from your feed: $..categories[*]. This is Jayway JsonPath syntax. Here’s what this syntax means:            Query Syntax      What It Matches                  $      Specifies the root directory as the beginning of the search.              ..      Indicates a recursive search in every directory and subdirectory of the root for matches.              categories[]      Says to look for the named array called “categories”.              *      Matches any contents (wildcard).      Putting it all together: $..categories[*] Starts at the root ($), looks in every directory and subdirectory recursively for matches (..), and looks to match on a named array called categories, with any contents in the array (*).You can test your queries using the Jayway JsonPath Evaluator.With the sample app in Fire App Builder, if you run this query ($..categories[*]) against one of the LightCast feed URLs, the result returns the category names as strings, like this:[   \"Jamaican Attractions\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"The Country Jamaica\",   \"The Country Jamaica\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"Jamaican History\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"Jamaican History\",   \"Jamaican History\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"Jamaican History\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"Jamaican History\",   \"Jamaican History\",   \"Jamaican History\",   \"The Country Jamaica\",   \"Jamaican Wildlife\",   \"Jamaican Attractions\",   \"The Country Jamaica\",   \"Jamaican Wildlife\",   \"The Country Jamaica\",   \"Jamaican Attractions\",   \"Jamaican Wildlife\",   \"Jamaican Attractions\",   \"Jamaican Wildlife\"](Fire App Builder will remove duplicates from the query result.)Fire App Builder needs to take the array of objects and convert the array to a hashmap to process in a Java class. So the next parameter (queryResultType) is used to convert the array of strings into an array of objects.\"queryResultType\": \"[]$\",See Querying JSON for more details about constructing Jayway JsonPath queries. See also Jayway JsonPath for more details about Jayway JsonPath in general.XML FeedsIf your feed is XML, instead of using Jayway JsonPath, you must use XPath expressions to target the specific elements in your feed. XPath reduces your XML document into various items called “nodes.” The XPath syntax targets the location of specific nodes.Suppose your XML feed contains a structure like this:&lt;rss&gt;    &lt;channel&gt;        &lt;item&gt;        &lt;title&gt;Sample Title&lt;/title&gt;        &lt;pubDate&gt;Wed, 26 Oct 2016 20:34:22 PDT&lt;/pubDate&gt;        &lt;link&gt;https://example.com/myshow/episodes/110&lt;/link&gt;        &lt;author&gt;Sample Author name&lt;/author&gt;        &lt;category&gt;Technology&lt;/category&gt;        &lt;category&gt;Gadgets&lt;/category&gt;        &lt;/item&gt;    &lt;/channel&gt;&lt;/rss&gt;Here’s a sample XPath expression to get the categories in this XML feed://category/text()The // looks recursively in all nodes for matches, no matter where those nodes are located in the hierarchy. category selects the category node, and text() selects the text from that node.You can test this out using the XPath Tester/Evaluator. The response from the expression is as follows:Text='Technology'Text='Gadgets'(You can ignore the Text= part. This is just part of the XPath Tester/Evaluator’s display, not what was matched in the query.)Note that with iTunes feeds, there’s a general category for the feed (such as &lt;itunes:category text=\"Technology\"&gt;) as well as categories for each item (&lt;category&gt;Technology&lt;/category&gt;). When you target categories for your recipe, you want to target the categories for each item in the feed, not the general feed categories.Try copying your XML feed into the XPath Tester/Evaluator and selecting the categories using a similar syntax.See Querying XML for more examples showing XPath expressions. See also XPath syntax and the examples section on XPath Examples for more details about XPath expressions in general. Note: If individual items in your feed are associated with multiple categories, your app’s display will show those items in each category they’re associated with. For example, if your Cool Video appears in both Technology and Gadgets categories, this video will appear in two places in your app’s display.matchList ParameterThe purpose of the matchList parameter is to select specific properties from the category query result and map them to the Fire App Builder content model.The syntax used by matchList is not Jayway JsonPath or XPath expressions but rather custom Fire App Builder syntax that targets specific elements in the query result. (Hence the JSON and XML instructions are combined in the same sections.)In the sample app in Fire App Builder, the value for the Categories recipe is StringKey@name.Here’s how this syntax works. On the left of the ampersand (@) you put the property you want to target in the query result (StringKey selects the list of strings). On the right of the ampersand (@), you put the Fire App Builder element you want to map the property to (name).For the Categories recipe, your matchList parameter should map your feed’s categories to name.In the Fire App Builder sample app, since the query result is a list of strings, StringKey is used to match the strings. But suppose the result set from your query contained a JSON object such as the following:\"list\": { \"title\" : \"My category title\" }To match on My category title and convert it to name, you would use the following:list/title@nameUse the forward slash (/) to go deeper in object levels (just like with with XPath). In this case, title is one object below list, which is one object below the root. After moving past these two levels, the result is simply the category name.To match XML elements, you follow a similar technique. Supposing the result is a list of strings:Text='Technology'Text='Gadgets'To match the text contents and map them to the category element in the Fire App Builder UI, you would use the following syntax:StringKey@nameIf your query result looked like this:&lt;list&gt;&lt;title&gt;My category title&lt;/title&gt;&lt;/list&gt;Then you would map the category title like this:/list/title@nameThe forward slash (/) takes you one level deeper in the XML nodes.keyDataType ParameterFire App Builder needs to know which media items should be grouped with the selected categories. The keyDataType parameter identifies the media items that are related to a category. This parameter is used for the Category recipe and later passed into a variable in the Contents recipe.The Fire App Builder query result is a list of strings, so StringKey@keyDataPath is used to target the media items and associate them with the category. If your result is also a list of strings, then you would use the default:\"keyDataType\": \"StringKey@keyDataPath\"However, suppose your media objects were listed inside an assets node that in turn was nested inside a container node, like this:\"container\": {    \"assets\": [    \"5825652561001\",    \"5825652558001\",    \"5825652569001\",    \"5873045223001\",    ]}To get the media objects, you would write the query like this:container/assets@keyDataPathSimilar to the matchList parameter, the keyDataType query does not use Jayway JsonPath syntax either. Instead, you match each node by writing the node name followed by / to move into the next level. container/assets matches all the items at this level.On the right of the ampersand @, the keyDataPath key is how these media objects are stored and used by Fire App Builder. The @keyDataPath helps match up the items with the Fire App Builder content model.Feeds without CategoriesIf your feed lacks categories but you have separate feeds for each category, you can hard-code the category names when you configure Navigator.json. This will group all the videos in a particular feed with a particular category. More detail for this approach is provided in the “Hardcoding Your Categories.”Next StepsNow that you’ve configured the categories for your app’s media feed, you need to configure the contents. See Set Up your Content Recipe.",
        "url": "fire-app-builder-set-up-recipes-categories.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-set-up-recipes-content-html": {
        "title": "Set Up the Content Recipe",
        "tags": "[]",
        "content": "When you configured your categories, you configured the general groupings for your media. In this step you will map your feed’s content (the titles, descriptions, images, video URLs, and so on) to the Fire App Builder content model. For an overview to recipe configuration, see Recipe Configuration Overview.  Configure the Content Recipe          query Parameter                  JSON Feeds          XML Feeds                    matchList Parameter                  Image Resolutions          Recommended Content (Through Tags)                      Next StepsConfigure the Content Recipe  Open the LightCastContentsRecipe.json file (located in app &gt; assets &gt; recipes).      Configure the file’s values as explained in the following table. If parameters need more explanation, the sections below the table provide more detail.    KeyDescription            cooker                      Defines which utility will take the parameters defined in the recipe and execute the logic. In other words, the cooker “cooks” the recipe. Leave it at the default value: DynamicParser.                      format                      Specifies the data format for the incoming data feed. Options are json or xml.                      translator                      Specifies whether translation or reflection is used when converting your feed’s objects to the Fire App Builder content model. Translation is faster and recommended. To use translation, simply leave the value at the default: ContentTranslator. If you want to use reflection instead, remove the translator parameter altogether from the recipe. Also see the “How do I use reflection…” question in the FAQ, because using reflection will require a change in the names used in the matchlist parameter.                      model                      Specifies the content model for the data. The content model provides the structure for your content and maps it into the Fire App Builder UI. Leave it at the default: com.amazon.android.model.content.Content.                          modelType                      Specifies whether the feed is an array or a single object. Available options are array or single. Almost all feeds are array. For example, if your JSON feed is enclosed within square brackets, or your XML feed has nested angle brackets, choose array. If your feed is structured as a single object, choose single.                          query                      A query used to return content from your media feed. The syntax of the query depends on the structure of your feed. You will need to construct the right query to get your content. For JSON feeds, use Jayway JsonPath syntax for the query syntax. For XML feeds, use XPath expressions for the query syntax. See query Parameter below for more details.                          queryResultType                      If the result from the query (a specified in the query parameter) returns a list of strings, include this queryResultType parameter and set it equal to []$. If the query’s result is an object (a map), omit this parameter. (Fire App Builder needs to know the result type because it will needs to push an object into a Java hashmap.)                          matchList                      The query that you defined in the query parameter returns a result. This result needs to be mapped from your feed’s names to the names Fire App Builder uses in its content model. The matchList parameter maps the results from the query to the name for media categories in Fire App Builder. See matchList Parameter for more details.            query ParameterThe syntax for JSON feeds differs significantly from the syntax for XML feeds, so the two formats are treated separately in the following sections:  JSON Feeds  XML Feeds Tip: Although the query syntax in this section might seem a little complex, remember that Fire App Builder lets you use any feed structure you want, without limiting you to a specific order or specification (such as Media RSS). With this flexibility, it’s unavoidable that you’ll need to use more advanced query syntax to target the elements in your feed.JSON FeedsIn the sample app in Fire App Builder, the value for query is $[?(@.categories[0] in [$$par0$$])]. As with the query parameter in the Categories recipe, this is (mostly) Jayway JsonPath syntax. This syntax uses a Jayway JsonPath filter operator to select the items inside the categories array that have at least one item at the 0 position.Let’s take a step back to unpack this syntax with more clarity, because you’ll need to customize this query to fit your own feed syntax. A sample Lightcast feed (which is what the sample Fire App Builder uses) looks like this:[  {    \"id\": \"136211\",    \"title\": \"Legends Beach Resort, Negril Jamaica\",    \"description\": \"Legends Beach Resort, Negril Jamaica\",    \"duration\": \"538\",    \"thumbURL\": \"http:\\/\\/l3.cdn01.net\\/_thumbs\\/0000136\\/0136211\\/0136211__009f.jpg\",    \"imgURL\": \"http:\\/\\/l3.cdn01.net\\/_thumbs\\/0000136\\/0136211\\/0136211__009f.jpg\",    \"videoURL\": \"http:\\/\\/media.cdn01.net\\/802E1F\\/process\\/encoded\\/video_1880k\\/0000136\\/0136211\\/M3FA8J1MI.mp4?source=firetv&amp;channel_id=13671\",    \"categories\": [      \"Jamaican Attractions\"    ],    \"channel_id\": \"13671\"  },  {    \"id\": \"136216\",    \"title\": \"Falmouth Jamaica Nature's Lullaby \",    \"description\": \"Falmouth Jamaica Nature's Lullaby\",    \"duration\": \"1813\",    \"thumbURL\": \"http:\\/\\/l4.cdn01.net\\/_thumbs\\/0000136\\/0136216\\/0136216__001f.jpg\",    \"imgURL\": \"http:\\/\\/l4.cdn01.net\\/_thumbs\\/0000136\\/0136216\\/0136216__001f.jpg\",    \"videoURL\": \"http:\\/\\/media.cdn01.net\\/802E1F\\/process\\/encoded\\/video_1880k\\/0000136\\/0136216\\/L2XGJI1LM.mp4?source=firetv&amp;channel_id=13672\",    \"categories\": [      \"The Country Jamaica\"    ],    \"channel_id\": \"13672\"  },  {    \"id\": \"136209\",    \"title\": \"Rafting on the Rio Grande River, Jamaica\",    \"description\": \"Rafting on the Rio Grande River, Jamaica\",    \"duration\": \"660\",    \"thumbURL\": \"http:\\/\\/l1.cdn01.net\\/_thumbs\\/0000136\\/0136209\\/0136209__010f.jpg\",    \"imgURL\": \"http:\\/\\/l1.cdn01.net\\/_thumbs\\/0000136\\/0136209\\/0136209__010f.jpg\",    \"videoURL\": \"http:\\/\\/media.cdn01.net\\/802E1F\\/process\\/encoded\\/video_1880k\\/0000136\\/0136209\\/I9BDFF0IM.mp4?source=firetv&amp;channel_id=13671\",    \"categories\": [      \"Jamaican Attractions\"    ],    \"channel_id\": \"13671\"  }](This isn’t the full feed, but it shows the repeating structure.)Plug this feed into the Jayway JsonPath Evaluator. Then run the following query:$[?(@.categories in [\"The Country Jamaica\"]\")]This query returns the following:[   {      \"id\" : \"136216\",      \"title\" : \"Falmouth Jamaica Nature's Lullaby \",      \"description\" : \"Falmouth Jamaica Nature's Lullaby\",      \"duration\" : \"1813\",      \"thumbURL\" : \"http://l4.cdn01.net/_thumbs/0000136/0136216/0136216__001f.jpg\",      \"imgURL\" : \"http://l4.cdn01.net/_thumbs/0000136/0136216/0136216__001f.jpg\",      \"videoURL\" : \"http://media.cdn01.net/802E1F/process/encoded/video_1880k/0000136/0136216/L2XGJI1LM.mp4?source=firetv&amp;channel_id=13672\",      \"categories\" : [         \"The Country Jamaica\"      ],      \"channel_id\" : \"13672\"   }]Here’s what this query syntax retrieves:            Query Syntax      What It Matches                  $[      Starts at the root and selects the unnamed array.              ?(@.categories[0] in [\"The Country Jamaica\"]      Creates a filter for all categories arrays that contain [\"The Country Jamaica\"] in the 0 index position.      Now there’s one difference in query syntax used in the sample Fire App Builder app. Instead of [\"The Country Jamaica\"], the query parameter uses $$par0$$ instead:\"query\": \"$[?(@.categories[0] in [$$par0$$])]\"$$par0$$ is a variable defined in Fire App Builder that stores all the items retrieved by the query, and this is where the syntax differs from Jayway JsonPath. In the code, the keyDataType from the categories recipe actually populates the $par0$$ variable with categories.Let’s go through one more example. Suppose your JSON looks like this:{    \"titles\": {        \"video\": [            {                \"category\": \"reference\",                \"publisher\": \"Jess\",                \"title\": \"Video title 1\",                \"price\": 3.95            },            {                \"category\": \"history\",                \"publisher\": \"John\",                \"title\": \"Video title 2\",                \"price\": 2.99            },            {                \"publisher\": \"Dave\",                \"title\": \"Video title 3\",                \"price\": 8.99            },            {                \"category\": \"science\",                \"publisher\": \"Jess\",                \"title\": \"Video title 4\",                \"price\": 3.99            }        ]     }}To select all arrays containing science as category, you would use this query:$.titles.video[?(@.category contains \"science\")]This returns:[   {      \"category\" : \"science\",      \"publisher\" : \"Jess\",      \"title\" : \"Video title 4\",      \"price\" : 3.99   }]However, we need all items in the array that contain category, so we remove the conditions around the @.category:$.titles.video[?(@.category)]Now add the in [$$par0$$] variable:$.titles.video[?(@.category in [$$par0$$])]Here’s a summary:            Query Syntax      What It Matches                  $.titles.video[      Selects the title object and the video array.              ?(@.category in [$$par0$$]      Filters the array to match on all items that have category.      Note that when you add in [$$par0$$] in the Jayway JsonPath Evaluator, it will not understand this syntax because it’s specific to Fire App Builder rather than being part of Jayway JsonPath.Your query will look different based on your feed and the syntax necessary to match the content objects. For example, here’s a more complex query:$.assets[?(@.type == 'movie.Container' &amp;&amp; @.assetId in $$par0$$)]This query says to start at the root ($), look in the first directory level (.) to the object named assets, and filter the array to type objects that are equal to movie.Container and which contain an assetId element.XML FeedsIf your feed is XML, instead of using Jayway JsonPath you will use XPath expressions to target the specific elements in your feed. XPath reduces your XML document into various items called “nodes.” The XPath syntax allows you to target the location of specific nodes.Unlike with the Jayway JsonPath syntax, the syntax for XML feeds is much simpler.Suppose your feed looked like this:&lt;rss&gt;    &lt;channel&gt;        &lt;item&gt;        &lt;title&gt;Sample Title 1&lt;/title&gt;        &lt;pubDate&gt;Wed, 26 Oct 2016 20:34:22 PDT&lt;/pubDate&gt;        &lt;link&gt;https://example.com/myshow/episodes/110&lt;/link&gt;        &lt;author&gt;Sample Author name&lt;/author&gt;        &lt;category&gt;Gadgets&lt;/category&gt;        &lt;/item&gt;                &lt;item&gt;        &lt;title&gt;Sample Title 2&lt;/title&gt;        &lt;pubDate&gt;Mon, 24 Oct 2016 09:24:12 PDT&lt;/pubDate&gt;        &lt;link&gt;https://example.com/myshow/episodes/109&lt;/link&gt;        &lt;author&gt;Sample Author name&lt;/author&gt;        &lt;category&gt;Technology&lt;/category&gt;        &lt;/item&gt;    &lt;/channel&gt;&lt;/rss&gt;The query for your content would look like this://itemIn XPath, the //item will match any instances of the item element regardless of its position in the XML structure. (There’s no need for the [$$par0$$] with the XML.)See Querying XML for more details about constructing XPath queries.matchList ParameterThe matchList parameter selects specific properties in the query’s result and maps the properties to Fire App Builder’s content model. The syntax used by matchList is custom Fire App Builder syntax that targets specific elements.In the sample app in Fire App Builder, the value for the Contents recipe is an array of property mappings that maps the title, id, description, media, and images to Fire App Builder’s content model. This is what the matchlist parameter looks like in the sample app:[    \"title@title\",    \"id@id\",    \"description@description\",    \"videoURL@url\",    \"imgURL@cardImageUrl\",    \"imgURL@backgroundImageUrl\"  ]Here’s how this syntax works. On the left of the ampersand (@) you put the property you want to target in the query result (for example, title). On the right of the ampersand (@), you put the Fire App Builder element you want to map the property to (for example, title).The following table lists the Fire App Builder elements that you can map properties or elements of your feed to:Fire App Builder NameDescriptionRequired        title              Video title.              Required              id              Video ID. Used to uniquely identify the media object.              Required              subtitle              Subtitle for a video.              Optional              description              Description of the video.              Required              url              Link to the video.              Required              cardImageUrl              Image thumbnail that appears on the home screen alongside other media thumbnails. The ideal size is 548px by 452px. See the following section on Image Resolutions for more detail.              Required              backgroundImageUrl              Larger image that appears when media is selected. The ideal size is 1920px x 1080px. See the following section on Image Resolutions for more detail.              Required              tags              Used to associate recommended content. See Recommend Content Through Tags for more information.              Optional              live              Used to identify live stream content. For live stream content, the “Watch from Beginning” button is not shown when users return to the media after having previously watching it. See Configure Live Streams for more information.              Optional       Warning: The Fire App Builder content model requires you (at the very least) to map your feed’s elements to the title, ID, description, URL, card image, and background image. If you have just one image, you can map both the card and background image to the same image.To better understand how the matchlist parameter works, let’s step through the details in the Fire App Builder sample app. In the LightCast media feed for Fire App Builder, the selections from the query parameter returns the following:[   {      \"id\" : \"136211\",      \"title\" : \"Legends Beach Resort, Negril Jamaica\",      \"description\" : \"Legends Beach Resort, Negril Jamaica\",      \"duration\" : \"538\",      \"thumbURL\" : \"http://l3.cdn01.net/_thumbs/0000136/0136211/0136211__009f.jpg\",      \"imgURL\" : \"http://l3.cdn01.net/_thumbs/0000136/0136211/0136211__009f.jpg\",      \"videoURL\" : \"http://media.cdn01.net/802E1F/process/encoded/video_1880k/0000136/0136211/M3FA8J1MI.mp4?source=firetv&amp;channel_id=13671\",      \"categories\" : [         \"Jamaican Attractions\"      ],      \"channel_id\" : \"13671\"   },   {      \"id\" : \"136216\",      \"title\" : \"Falmouth Jamaica Nature's Lullaby \",      \"description\" : \"Falmouth Jamaica Nature's Lullaby\",      \"duration\" : \"1813\",      \"thumbURL\" : \"http://l4.cdn01.net/_thumbs/0000136/0136216/0136216__001f.jpg\",      \"imgURL\" : \"http://l4.cdn01.net/_thumbs/0000136/0136216/0136216__001f.jpg\",      \"videoURL\" : \"http://media.cdn01.net/802E1F/process/encoded/video_1880k/0000136/0136216/L2XGJI1LM.mp4?source=firetv&amp;channel_id=13672\",      \"categories\" : [         \"The Country Jamaica\"      ],      \"channel_id\" : \"13672\"   },   {      \"id\" : \"136209\",      \"title\" : \"Rafting on the Rio Grande River, Jamaica\",      \"description\" : \"Rafting on the Rio Grande River, Jamaica\",      \"duration\" : \"660\",      \"thumbURL\" : \"http://l1.cdn01.net/_thumbs/0000136/0136209/0136209__010f.jpg\",      \"imgURL\" : \"http://l1.cdn01.net/_thumbs/0000136/0136209/0136209__010f.jpg\",      \"videoURL\" : \"http://media.cdn01.net/802E1F/process/encoded/video_1880k/0000136/0136209/I9BDFF0IM.mp4?source=firetv&amp;channel_id=13671\",      \"categories\" : [         \"Jamaican Attractions\"      ],      \"channel_id\" : \"13671\"   }]The matchList parameter converts these property names in the feed to the names used in Fire App Builder’s content model:[    \"title@title\",    \"id@id\",    \"description@description\",    \"videoURL@url\",    \"imgURL@cardImageUrl\",    \"imgURL@backgroundImageUrl\"  ]  title@title converts title to title  id@id converts id to id  description@description converts description to description  videoURL@url converts videoURL to url  imgURL@cardImageUrl converts imgURL to cardImageUrl  imgURL@backgroundImageUrl converts imgURL to backgroundImageUrl(In this example, a lot of the names are the same, but in your feed, might might have terms such as videoTitle, videoSummary, and so on.)Customize the left side of the ampersand @ to correspond with your own feed’s terminology; customize the right side of the @ to correspond with Fire App Builder’s term in its content model.Your feed might not list each element in a simple key-value pair. If you have various levels of nesting, your matchList might look like this:    \"common/title@title\",    \"assetId@id\",    \"common/subtitle@subtitle\",    \"common/description@description\",    \"video/videoURL@url\",    \"imgURLs/ImageSmall@cardImageUrl\",    \"imgURLs/ImageLarge@backgroundImageUrl\"With this syntax, the forward slash (/) separates elements at each level. For example, common/title looks inside the common object to match on the title property.Let’s look an an example using XML. Suppose your XML feed looks like this:&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;rss version=\"2.0\" … …&gt;  &lt;channel&gt;    &lt;title&gt;Content Mix for US News-in-Pictures 9x16&lt;/title&gt;    &lt;description&gt;Screenfeed Content Server&lt;/description&gt;    &lt;lastBuildDate&gt;Mon, 08 Dec 2014 22:55:16 GMT&lt;/lastBuildDate&gt;&lt;ttl&gt;5&lt;/ttl&gt;     &lt;item&gt;      &lt;title&gt;John Anderson ……&lt;/title&gt;      &lt;guid isPermaLink=\"false\"&gt;1&lt;/guid&gt;      &lt;pubDate&gt;Mon, 08 Dec 2014 22:55:16 GMT&lt;/pubDate&gt;      &lt;category&gt;News&lt;/category&gt;      &lt;media:content url=\"http://samples.screenfeed.com/1.jpg\" type=\"image/jpeg\"&gt;        &lt;media:title type=\"plain\"&gt;1080x1920 - English - with caption&lt;/media:title&gt;        &lt;media:credit&gt;Â© 2014 News Agency&lt;/media:credit&gt;        &lt;media:thumbnail url=\"http://samples.screenfeed.com/public/us-news-in-pictures/1080x1920/h9xnRIN9CUGiTWNQBBrjOw-1080x1920h-1.jpg\" /&gt;      &lt;/media:content&gt;&lt;/item&gt; ...  &lt;/channel&gt;&lt;/rss&gt;In order to get the contents, the query in the matchList parameter would look like this:  \"matchList\": [    \"title/#text@title\",    \"guid/#text@id\",    \"media:content/media:title/#text@description\",    \"media:content/#attributes/url@url\",    \"media:content/#attributes/url@cardImageUrl\",    \"media:content/#attributes/url@backgroundImageUrl\",  ]In this case, here’s how the conversions happen:  title/#text@mTitle converts title/#text to title  guid/#text@mId converts guid/#text to id.  media:content/media:title/#text@mDescription converts media:content/media:title/#text to description  media:content/#attributes/url@mUr converts media:content/#attributes/url to url  media:content/#attributes/url@mCardImageUrl converts media:content/#attributes/url to cardImageUrl  media:content/#attributes/url@mBackgroundImageUrl converts media:content/#attributes/url to backgroundImageUrl.The only real difference here is the use of the #text selector, which targets the text inside an element. The #text syntax is custom Fire App Builder syntax and is equivalent to text() in XPath.Here’s another example. Suppose your feed looks like this:&lt;rss&gt;    &lt;channel&gt;        &lt;item&gt;        &lt;title&gt;Sample Title 1&lt;/title&gt;        &lt;pubDate&gt;Wed, 26 Oct 2016 20:34:22 PDT&lt;/pubDate&gt;        &lt;link&gt;https://example.com/myshow/episodes/110&lt;/link&gt;        &lt;author&gt;Sample Author name 1&lt;/author&gt;        &lt;category&gt;Technology&lt;/category&gt;        &lt;category&gt;Gadgets&lt;/category&gt;        &lt;/item&gt;                &lt;item&gt;        &lt;title&gt;Sample Title 2&lt;/title&gt;        &lt;pubDate&gt;Wed, 23 Oct 2016 08:33:12 PDT&lt;/pubDate&gt;        &lt;link&gt;https://example.com/myshow/episodes/109&lt;/link&gt;        &lt;author&gt;Sample Author name 2&lt;/author&gt;        &lt;category&gt;News&lt;/category&gt;        &lt;/item&gt;    &lt;/channel&gt;&lt;/rss&gt;Here’s what the matchlist parameter would look like:\"matchList\": [    \"title/#text@title\",    \"guid/#text@id\",    \"itunes:subtitle/#text@description\",    \"media:content/#attributes/url@url\",    \"media:content/media:thumbnail/#attributes/url@cardImageUrl\",    \"media:content/media:thumbnail/#attributes/url@backgroundImageUrl\"]Image ResolutionsYou can use two images for media in your app: an image card and a background image. The two types of images get used in different places, and the containers where each image is used also varies slightly.The following screenshot shows the difference between the two types of images on the Content Home screen:The image cards appear in a list of thumbnails. When you select one of the image cards, a larger background image appears in the upper-right area of the screen.The two images also appear on the Content Preview screen:Here the image card appears a little larger, with the background image filling the entire background of the screen. The background image has a dark gray overlay.The recommended image sizes (width x height) are as follows:  Image cards: 548px by 452px. This image can be larger but will be scaled down. The image will also be cropped to fill a 320px x 240px container in some cases.  Background images: 1920px x 1080px. This image can be larger but will be scaled down. The image will also be cropped to fill a 1120px x 800px container in some cases.When Fire App Builder does image cropping, it preserves the aspect ratio of the image by cropping the sides of the image (thus focusing on the center).Recommended Content (Through Tags)Below the video is a Recommended Content section that shows other videos with the same tags:To populate the Recommended Content section in the app, you need to match on your tags in the matchList parameter. For example:common/tags@tagsHere the tags element appears inside a common element. This syntax converts common/tags to tags so Fire App Builder can read it and display related media objects.Note that the LightCast feed in the Fire App Builder sample app doesn’t include tags. However, there’s a fallback parameter that you can set to true if you want to show recommended content, but you don’t have tags in your feed.In your Navigator.json file (located in your app’s assets folder), the config object has a property called categoryDefaultRecommendation:  \"config\": {    \"showRecommendedContent\": true,    \"categoryDefaultRecommendation\": true,    \"searchAlgo\": \"basic\"  }If you set categoryDefaultRecommendation to true, Fire App Builder will use other media assets from the same category for the recommended content (rather than pulling content with the same tags). Note: Currently, Recommended Content matches (which are based on tags in the feed) will match unlimited content if many items have the same tags. This is a known limitation/bug.To turn off the Recommended Content section, you can set showRecommendedContent to false in Navigator.json.Next StepsNow that you’ve configured the categories and contents for your app’s media feed, you need to associate the feed with the app’s UI. See Navigator Configuration Overview.",
        "url": "fire-app-builder-set-up-recipes-content.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-set-up-recipes-overview-html": {
        "title": "Recipe Configuration Overview",
        "tags": "[]",
        "content": "After you load the media feed, you need to configure two recipes that Fire App Builder will use to pull the media categories and content from your feed. “Recipes” are simple files that contain settings (in the form of keys and values) that Fire App Builder uses when building your app. The two recipes you must configure are as follows:  Categories recipe: Provides different containers to group your media.  Contents recipe:  Maps the properties from your media feed, such as the titles, descriptions, video URLs, and images, to Fire App Builder’s content model.If you look at the Home screen with the default Lightcast feed, you’ll see that the media is organized in different rows. On the default home screen, you can see that media is grouped under “Jamaica Attractions” and “The Country Jamaica,” among other groups.Categories providing groupings for media.Since every media feed usually has a different structure (for example, your feed might use the term “channels” instead of “categories,” “img” instead of “image,” and so on, as well as different hierarchies and structures) you will need to write some query syntax to target the categories and content in your feed.If your feed is JSON, you will use Jayway JsonPath syntax to write the queries. If your feed is XML, you will use XPath syntax here to write the queries.After you query for the categories and content from your query, you then apply a selector to get the category or content text from the results. This selector, called matchList, doesn’t use Jayway JsonPath or XPath expressions but rather is custom Fire App Builder syntax.Next StepsSee Set Up the Category Recipe to start identifying categories in your feed. Fire App Builder will group your media based on these categories.",
        "url": "fire-app-builder-set-up-recipes-overview.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-customize-look-and-feel-html": {
        "title": "Customize the Look and Feel of Your App",
        "tags": "[]",
        "content": "You can customize much of the app’s look and feel through your app’s custom.xml file (located in res &gt; values) as well as navigator.json (in app &gt; assets). Here’s a list of what you can easily change in the app:  Change the Font  Customize the Splash Screen  Customize the Recommended Content Section  Customize the Homepage Layout          Background Image for Homepage Browse Layout        Customize the Content Cards  Customize the Content Details  Customize the Playback Overlay  Customize the Search Bar  Customize the Content Reload Time  Customize the App Icon  Update the Terms of Use  Next StepsChange the FontYou can change your app’s fonts through the branding object in Navigator.json (inside app &gt; assets):\"branding\": {    \"globalTheme\": \"AppTheme\",    \"lightFont\" : \"Roboto Light\",    \"boldFont\" : \"Roboto Bold\",    \"regularFont\" : \"Roboto Regular\"  }Here’s how the fonts are used:            Property      Where It’s Used                  lightFont      Used in description and body text.              boldFont      Used in titles.              regularFont      Used in buttons and subtitles.      (With the globalTheme property, there aren’t other values you can select.)You can assign any valid device or custom font for any of the three font options. For example, you could apply Roboto Bold to all three fonts if you want.You can use any of these device fonts:  Amazon Ember fonts: Amazon Ember, Amazon Ember Bold, Amazon Ember Bold Italic, Amazon Ember Italic, Amazon Ember Light, Amazon Ember Light Italic, Amazon Ember Medium, Amazon Ember Medium Italic, Amazon Ember Thin, Amazon Ember Thin Italic, AndroidClock Regular, AndroidClock-Large Regular  Roboto fonts: Roboto Black, Roboto Black Italic, Roboto Bold, Roboto Bold Italic, Roboto Condensed Bold, Roboto Condensed Bold Italic, Roboto Condensed Italic, Roboto Condensed Light, Roboto Condensed Light Italic, Roboto Condensed Regular, Roboto Italic, Roboto Light, Roboto Light Italic, Roboto Medium, Roboto Medium Italic, Roboto Regular, Roboto Thin, Roboto Thin Italic  Verdana fonts: Verdana, Verdana Bold, Verdana Bold Italic, Verdana Italic  Miscelleneous fonts: Carrois Gothic SC, Clockopia, Code2000, Coming Soon, Cutive Mono, Dancing Script, Dancing Script BoldDroid Sans Mono, Kindle Symbol, MotoyaLMaru W3 mono, MT Chinese Surrogates, NanumGothic, Source Code Pro MediumFor example, if you wanted to use Amazon Ember fonts, you could customize the branding object like this:  \"branding\": {    \"globalTheme\": \"AppTheme\",    \"lightFont\" : \"Amazon Ember\",    \"boldFont\" : \"Amazon Ember Bold\",    \"regularFont\" : \"Amazon Ember\"  }The screens would then look like this:And this:These Amazon Ember fonts will be used in the titles, subtitles, descriptions, body, and buttons.Beyond using different device fonts, you can also use custom fonts. If you use a custom font, store the font in your app’s assets/fonts directory. Then provide the path to the font in the branding object, such as fonts/Proxima-Nova-Light.tff (instead of just entering Proxima Nova Light):  \"branding\": {    \"globalTheme\": \"AppTheme\",    \"lightFont\" : \"fonts/Proxima-Nova-Light.tff\",    \"boldFont\" : \"fonts/Proxima-Nova-Light.tff\",    \"regularFont\" : \"fonts/Proxima-Nova-Light.tff\"  }Customize the Splash ScreenBy default, the sample app in Fire App Builder shows the following Splash screen:You can adjust the Splash screen settings in the custom.xml file:&lt;!-- Splash Screen Customization --&gt;&lt;!-- Background to display on Splash Screen --&gt;&lt;drawable name=\"splash_background\"&gt;@drawable/bg_generic_nopreview&lt;/drawable&gt;&lt;!-- Company logo to show on Splash Screen --&gt;&lt;drawable name=\"splash_logo\"&gt;@drawable/fire_app_builder_white&lt;/drawable&gt;&lt;!-- Copyright string text color --&gt;&lt;color name=\"copyright\"&gt;#E6FFFFFF&lt;/color&gt;&lt;!-- End of Splash Screen Customization --&gt;The references to @drawable refer to images in TVUIComponent &gt; res &gt; drawable. Either replace these images with your own customized images, or add unique image files and update the references in the XML to point to your images.The bg_generic_nopreview image is just a 1900 x 1080px black image. This same background is used for the fullbrowse homepage layout, but you can specify a different image reference here if you want.The splash_logo should contain your logo on a transparent background. The logo image size in the sample application is 356 x 108px, but you can use a larger image if you want. The image will be scaled down automatically.Your logo appears as an overlay on top of the splash screen’s background image, so if you’re customizing the images, make sure the combination looks good. A light logo on a dark background will have the necessary contrast.To customize the Copyright text on the Splash screen, see the strings.xml folder inside your app’s res &gt; values &gt; strings.xml folder.&lt;!-- Copyright string --&gt;&lt;string name=\"copyright\"&gt;Copyright 2016. All Rights Reserved.&lt;/string&gt;Customize the Recommended Content SectionOn the Content Details screen, a list of “Recommended Content” appears below the content preview.For more details on configuring Recommended Content, see “Recommended Content (Through Tags)” in Set Up the Content Recipe.Customize the Homepage LayoutThe default home screen layout uses the ContentBrowseActivity. This layout is referred to as the “Homepage Browse layout.”Home with the ContentBrowseActivity. This view arranges the videos in various channels or groups. When you view a channel, the first video in that channel group appears as the featured background image, with its title and description in the upper-left.You can change the homepage layout to a more compressed view by using the FullContentBrowseActivity instead. This alternative homepage layout is referred to as the “Homepage Full Browse layout.”Home with FullContentBrowseActivity. With this activity, all the videos appear in a more compressed grid, with the channels listed on the left. None of the videos are superimposed as large featured images in the background.The left sidebar can collapse in when the user is browsing through the video titles. This gives more space and focus to your video content.To change the homepage to the more compressed, Full Browse layout:  Open the Navigator.json file (located in app &gt; assets).      In the graph object, locate the CONTENT_HOME_SCREEN:    \"com.amazon.android.tv.tenfoot.ui.activities.ContentBrowseActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_HOME_SCREEN\"    }        Change ContentBrowseActivity to FullContentBrowseActivity.The following diagram shows the properties you can customize on the homepage’s Browse layout (the default):The browse_background property is set through the TVUIComponent’s custom.xml file and references an image rather than a hex value.The following diagram shows the properties for the homepage’s Full Browse layout:The following code in your app’s custom.xml shows where these homepage options are set:    &lt;!-- Browse Customization --&gt;    &lt;!-- The background gradient color, if no background drawable is provided.         Used in default_background.xml --&gt;    &lt;color name=\"background_gradient_start\"&gt;#000000&lt;/color&gt;    &lt;color name=\"background_gradient_end\"&gt;#DDDDDD&lt;/color&gt;    &lt;!-- The header's bar color (left-hand navigation bar) --&gt;    &lt;color name=\"browse_headers_bar\"&gt;#0DFFFFFF&lt;/color&gt;    &lt;!-- Selected header text color --&gt;    &lt;color name=\"browse_header_selected\"&gt;#FFFFFFFF&lt;/color&gt;    &lt;!-- Non-selected header text color --&gt;    &lt;color name=\"browse_header\"&gt;#CCD8D8D8&lt;/color&gt;    &lt;!-- Header color when left-hand navigation bar is closed         and rows are showing full screen --&gt;    &lt;color name=\"browse_row_header\"&gt;#99FFFFFF&lt;/color&gt;    &lt;!-- Search orb color (the circle shape around the search icon) --&gt;    &lt;color name=\"search_orb\"&gt;#EE962D&lt;/color&gt;    &lt;!-- Header text size --&gt;    &lt;dimen name=\"browse_header_text\"&gt;16sp&lt;/dimen&gt;    &lt;!-- Company logo --&gt;    &lt;drawable name=\"company_logo\"&gt;@drawable/fire_app_builder_white_2&lt;/drawable&gt;    &lt;drawable name=\"browse_bg_color\"&gt;@drawable/bg_generic_nopreview&lt;/drawable&gt;    &lt;!-- End of Browse Customization --&gt; Note: Disregard the comments in the Browse Customization section in the application’s custom.xml file above. Some of the comments are out of date, and some of the elements aren’t properly configured. See the following table to understand what each element does.                                    Element         Description                           background_gradient_start         Does nothing. Ignore.                     background_gradient_end         Does nothing. Ignore.                     browse_headers_bar         Changes the color of the left navigation bar when you're in the compressed homepage layout.                     browse_header_selected         Does nothing. Ignore.                     browse_header         Does nothing. Ignore.                     browse_row_header         For the homepage Browse layout, changes the category title above the videos rows. For the Full Browse layout, changes the color of the category titles in the left navigation bar. Both the selected and non-selected category titles receive this color. The selected category titles are bold, and the non-selected category titles are softer and muted.                     search_orb         Does nothing. Ignore.                     browse_header_text         Changes the size of the category titles.                     company_logo         This image is stored in TVUIComponent &gt; res &gt; drawable. Replace the image with your own logo. The image should be transparent and at least 356px wide by 108px tall. You can use a larger image &mdash; it will be scaled down in the app.                     browse_bg_color         The background image used for both the Full Browse layout and the Splash screen. This image is stored in TVUIComponent &gt; res &gt; drawable. The image is a 1900 x 1080px PNG image with a black color.                     browse_background         This element isn't included in application's custom.xml file &mdash; Ignore. You can simply add the line. This element controls the background image used for the homepage Browse layout. More details about this image are listed below.                     browse_bg_color         This element isn't included in application's custom.xml file &mdash; Ignore. You can simply add the line. This element controls the background image used for the homepage Full Browse layout. More details about this image are listed below.         Background Image for Homepage Browse LayoutThe background color for the homepage Browse layout (the default) isn’t configurable through the custom.xml values above because there’s a line missing in custom.xml:    &lt;drawable name=\"browse_background\"&gt;@drawable/bg_generic&lt;/drawable&gt;You can add this line to your application’s custom.xml file and control your background image file used here. Alternatively, you can edit the custom.xml inside TVUIComponent &gt; res &gt; values &gt; custom.xml. (The custom.xml file in your app just overwrites the other values in XML files, so setting the property in either file will work. But as a best practice, leave the component files unedited and just edit your application’s config.xml file.)Like the browse_bg_color element, the drawable image referenced here is stored in TVUIComponent &gt; res &gt; drawable (assuming you’re browsing in the Android view).The bg_generic.png image looks like this:bg_generic.png. The image is a 1900 x 1080px PNG image with transparency in the upper-right area.To change this default image, create your own image file with the same dimensions. Make the upper-right corner transparent, similar to the existing image. Name it bg_generic.png and replace the existing file in TVUIComponent &gt; res &gt; drawable.To make it easy to customize the image, you can download the Photoshop file used to create the image. In Photoshop, view the image’s layers and use the Paint Bucket tool to apply a new color to the two layers. In the downloadable file, the color has been changed from black to blue to make the colors more apparent.For the Full Browse layout, you change this image in a similar way — by replacing the bg_generic_nopreview.png in TVUIComponent &gt; res &gt; drawable or by creating a unique image file and updating the reference to it in your application’s custom.xml file.Customize the Content CardsYou can customize the background colors and dimensions of the content cards. The “cards” refers to the rectangular thumbnails that show the media details. For example, the Home screen displays a row of content cards under the “Jamaican Attractions” title.The following code shows the available settings to customize the appearance of these cards:&lt;!-- Movie Info Card Customization --&gt;&lt;!-- Background color of the card info --&gt;&lt;color name=\"card_info_bg\"&gt;#2B2B2B&lt;/color&gt;&lt;!-- Card info title text color --&gt;&lt;color name=\"card_info_title_text\"&gt;#E6FFFFFF&lt;/color&gt;&lt;!-- Card info content text color --&gt;&lt;color name=\"card_info_content_text\"&gt;#FFFFFFFF&lt;/color&gt;&lt;dimen name=\"card_info_title_text\"&gt;8sp&lt;/dimen&gt;&lt;!-- Card info content text size --&gt;&lt;dimen name=\"card_info_content_text\"&gt;12sp&lt;/dimen&gt;&lt;!-- Card info selected title text size --&gt;&lt;dimen name=\"card_info_selected_title_text\"&gt;10sp&lt;/dimen&gt;&lt;!-- Card info selected content text size --&gt;&lt;dimen name=\"card_info_selected_content_text\"&gt;15sp&lt;/dimen&gt;&lt;!-- End of Movie Info Card Customization --&gt;Customize the Content DetailsYou can customize various elements on the Content Details screen:The relevant code in the custom.xml file is as follows:&lt;!-- Details Customization --&gt;&lt;!-- Text color for unfocused action button --&gt;&lt;color name=\"action_button_text_color\"&gt;#E6FFFFFF&lt;/color&gt;&lt;!-- Text color for focused action button --&gt;&lt;color name=\"action_button_text_color_focused\"&gt;#E6FFFFFF&lt;/color&gt;&lt;!-- Background color for focused action button --&gt;&lt;drawable name=\"action_button_focused\"&gt;@drawable/btn_generic_focused&lt;/drawable&gt;&lt;!-- Background color for normal state of action button --&gt;&lt;drawable name=\"action_button_normal\"&gt;@drawable/btn_normal&lt;/drawable&gt;&lt;!-- Details description title text color --&gt;&lt;color name=\"details_description_title\"&gt;#E6FFFFFF&lt;/color&gt;&lt;!-- Details description body text color --&gt;&lt;color name=\"details_description_body\"&gt;#FFFFFFFF&lt;/color&gt;&lt;!-- Action button text size --&gt;&lt;dimen name=\"action_text\"&gt;14sp&lt;/dimen&gt;&lt;!-- Details description title text size --&gt;&lt;dimen name=\"details_description_title_text\"&gt;24sp&lt;/dimen&gt;&lt;!-- Details description body text size --&gt;&lt;dimen name=\"details_description_body_text\"&gt;16sp&lt;/dimen&gt;&lt;!-- End of Details Customization --&gt;Customize the Playback OverlayYou can customize the playback overlay on the Content Renderer screen:&lt;!-- Playback Overlay Customization --&gt;&lt;!-- Background color of the playback overlay --&gt;&lt;color name=\"playback_background\"&gt;#9922262A&lt;/color&gt;&lt;!-- Background color of the progress bar --&gt;&lt;color name=\"playback_background_progress_bar\"&gt;#FF373737&lt;/color&gt;&lt;!-- Color of buffered progress bar --&gt;&lt;color name=\"playback_buffered_progress\"&gt;#FF5A5A5A&lt;/color&gt;&lt;!-- Color of the progress bar --&gt;&lt;color name=\"progress_bar\"&gt;#FFDADADA&lt;/color&gt;&lt;!-- Text color of the playback time --&gt;&lt;color name=\"playback_time_text\"&gt;#FFFFFFFF&lt;/color&gt;&lt;!-- Hide More options status activation status--&gt;&lt;bool name=\"hide_more_options\"&gt;true&lt;/bool&gt;&lt;!-- End of Playback Overlay Customization --&gt;Customize the Search BarYou can customize the background color and text used in the search bar.The relevant code in custom.xml is as follows:&lt;!-- Search Bar Customization --&gt;&lt;!-- Background color of search orb --&gt;&lt;color name=\"search_orb_background\"&gt;#EE962D&lt;/color&gt;&lt;!-- Icon to display inside of search orb --&gt;&lt;drawable name=\"search_icon\"&gt;@drawable/ic_search&lt;/drawable&gt;&lt;!-- Background color of Search screen --&gt;&lt;drawable name=\"search_background\"&gt;@drawable/bg_gradient_search&lt;/drawable&gt;&lt;!-- Search hint text --&gt;&lt;string name=\"search_bar_hint\"&gt;I\\'m looking for…&lt;/string&gt;&lt;!-- End of Search Bar Customization --&gt;Customize the Content Reload TimeYou can customize the time it takes for content to reload (content refers to  the videos and other details that your app loads from the media feed). By default the reload time is 14400000 milliseconds, or 4 hours. After this time expires, the Navigator.js file (located in app &gt; assets &gt; resources) will reload the recipes and data loader settings.&lt;!-- Content Reload time in milliseconds --&gt;&lt;integer name=\"time_to_reload_content\"&gt;14400000&lt;/integer&gt;&lt;!-- End Content Reload time in milliseconds --&gt;Customize the App IconYou can change the app icon. This is the image thumbnail that appears in your list of apps on Fire TV.To update this file, change the ic_launcher.svg files. Switch to the Project view, and then look in app &gt; src &gt; main &gt; res. There are 4 app icon files, each corresponding to different screen sizes:  mipmap-hdpi (72x72px)  mipmap-mdpi (48x48px)  mipmap-xhdpi (96x96px)  mipmap-xxhdpi (96x96px)The app icon has a transparent background.Update the Terms of UseThe Terms of Use section appears in the footer of the app and links to the terms_of_use.html file (located in app &gt; assets).The Terms of Use file is a sample file that you should edit before distributing your app.  For instance, you might choose to include terms of use, an end user license agreement, privacy notices, and/or other legal notices in this file.The Terms of Use file also includes notices for open source components that are built in to the sample app by default. These notices are provided as a convenience only. Amazon makes no representations as to their accuracy or completeness and will not be responsible for any inaccuracies or incompleteness.Next StepsTo use components that leverage authentication, ads, in-app purchasing, or analytics, see Components Overview.",
        "url": "fire-app-builder-customize-look-and-feel.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-freewheel-ads-component-html": {
        "title": "Freewheel Ads Component",
        "tags": "[]",
        "content": "You can implement FreeWheel video ads in the app you build with Fire App Builder. To learn more about Freewheel, see Freewheel.tv. Both preroll and midroll ads are supported in Fire App Builder.  The User Experience  Configure FreewheelThe User ExperienceBefore media begins to play on a Content Renderer screen, the Freewheel video ads play.FreeWheel Ads display. (This screenshot shows the filler ads track.)After the video ads end, the media that the user selected starts playing.Configure Freewheel      Load the Freewheel component into your app. See Load a Component in Your App for details about how to load a component into your app.        Remove any other ads components that are loaded in your app (such as VastAdsComponent or PassThroughAdsComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the VAST Ads component and the Freewheel Ads component, because both components use the same IAds interface. For a list of the components by interface, see Components Overview.        Go to FreeWheelAdsComponent &gt; java &gt; com.amazon.ads.android.freewheel and open the FreeWheelAds.java file.     Note: Unlike with other components, the values you must customize for the FreeWheelAdsComponent aren’t extracted out into an XML file. (The extraction will be completed in an upcoming release.)        Customize the values for the following four strings:    /** * FreeWheel server url.*/private String mAdUrl = \"http://demo.v.fwmrm.net/\";/** * FreeWheel network id.*/private int mNetworkId = 90750;/** * FreeWheel profile.*/private String mProfile = \"3pqa_android\";/** * FreeWheel site section.*/private String mSiteSectionId = \"3pqa_section_nocbp\";      You get these values through your FreeWheel account.",
        "url": "fire-app-builder-freewheel-ads-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-vast-ads-component-html": {
        "title": "VAST Ads Component",
        "tags": "[]",
        "content": "Fire App Builder supports the VAST ads template (Video Ad Serving Template). VAST is a standard protocol that supports different video advertisers. The Interactive Advertising Bureau (IAB) describes VAST as follows:  VAST is a Video Ad Serving Template for structuring ad tags that serve ads to video players. Using an XML schema, VAST transfers important metadata about an ad from the ad server to a video player. Initially launched in 2008, VAST has since played an important role in the growth of the digital video marketplace. Digital Video Ad Serving Template (VAST) 4.0If you want to show DoubleClick ads in your app, you can do so through the VAST Ads Component. However, note that Fire App Builder supports only a subset of VAST features.  Unsupported VAST Features  Tracking Events  The User Experience  Configure VAST AdsUnsupported VAST FeaturesThe Fire App Builder integration of VAST does not include support for the entire VAST specification. Additionally, the VAST integration in Fire App Builder is not officially certified by the IAB. The following VAST features are not supported in Fire App Builder:  Ad types other than “Linear Video Ad”  Any interactions within the ad  Click, pause, resume, or close actions within the ad  302 redirects Note: Linear ads can appear before, during, or after the video plays. However, in the current VastAdsComponent in Fire App Builder, ads can only appear before the video plays (preroll ads).Tracking EventsDuring the Linear Video Ad playback, the component triggers events for the following:  Impressions  Errors  Start (25%, mid, 75%, and complete)The following table lists the component’s specific support for various events:            Tracking Events      Supported                  creativeView      No              start      Yes              midpoint      Yes              firstQuartile      Yes              thirdQuartile      Yes              complete      Yes              mute      No              unmute      No              pause      No              rewind      No              resume      No              fullscreen      No              expand      No              collapse      No              acceptInvitation      No              close      No      The User ExperienceAfter the user clicks the Watch Now button, the VAST ads template serves up ads for a short period of time.The VAST ads template serves up video before the user's selected media starts to play. The screenshot here is just ad filler that would be replaced by a real ad when you configure VAST ads.After the video ads, the user’s selected media begins to play.Configure VAST AdsTo configure VAST Ads:  Load the VAST ads component into your app. See the Load a Component in Your App for details about how to load a component into your app.      Remove any other ad components that are loaded in your app (such as FreeWheelAdsCompnent or PassThroughAdsComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the VAST Ads component and the Freewheel Ads component, because both components use the same IAds interface. For a list of the components by interface, see Components Overview.        Go to VastAdsComponent &gt; res &gt; values and open strings.xml. Copy the vast_preroll_tag string and paste it into your own app’s custom.xml file (inside res &gt; values):    &lt;string name=\"vast_preroll_tag\"&gt;\"https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&amp;amp;iu=/124319096/external/single_ad_samples&amp;amp;ciu_szs=300x250&amp;amp;impl=s&amp;amp;gdfp_req=1&amp;amp;env=vp&amp;amp;output=vast&amp;amp;unviewed_position_start=1&amp;amp;cust_params=deployment%3Ddevsite%26sample_ct%3Dlinear&amp;amp;correlator=\"&lt;/string&gt;            Customize value for the vast_preroll_tag string with your own VAST ads tag.    Note that in your VAST tag, the following characters must be encoded:                Character      Encoding                  \"      &amp;quot;              '      &amp;apos;              &lt;      &amp;lt;              &gt;      &amp;gt;              &amp;      &amp;amp;        ",
        "url": "fire-app-builder-vast-ads-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-crashlytics-component-html": {
        "title": "Crashlytics Component",
        "tags": "[]",
        "content": "Crashlytics (by Fabric) provides analytics around app crashes. According to Crashlytics:  Crashlytics is the #1 crash reporting platform for iOS and Android. With Crashlytics, you get real-time information on crashes inside your app, and all the details you need to tackle the most impactful stability issues head-on. Simply including Crashlytics will enable crash reporting right away - there’s no extra code to write. — CrashlyticsYou can read more in the Crashlytics documentation for Android. The Crashlytics Component implements the IAnalytics interface. You must have a Crashlytics account to use this component.Follow these steps to configure Crashlytics:  Step 1. Get Your Crashlytics Key  Step 2. Configure the Crashlytics Component  Step 3. Make a Test Crash  Step 4. Explore the Crashlytics DashboardStep 1. Get Your Crashlytics KeyAssuming you don’t already have a Crashlytics account, sign up for one and provide details about your app:  Go to https://fabric.io/sign_up and sign up for an account.  Walk through the confirmation and welcome screens.      When you get to the “You’ll be up and running in 3 steps!” screen, ignore it.    Instead of downloading and installing the Fabric plugin with these 3 steps, ignore this screen entirely. You do not need to install the Fabric plugin in Android Studio to install or configure the Crashlytics component. This plugin simply ensures you have made updates to your code that allow Crashlytics to work. In the steps that follow, you will be making adjustments to the Fire App Builder code that will accomplish a similar end.        Go to the Install Crashlytics via Gradle page and look in the “Add Your API Key” section.    Assuming you’re still logged in, you’ll see your API key automatically populated in the code sample:    The code samples automatically populate with your API key.    Copy this API key into a convenient place to use in later steps.(If you already have an existing Crashlytics account and have viewed crashlytics stats previously, you can also view your API key from your organization’s settings. See Fabric API Keys.)Step 2. Configure the Crashlytics ComponentThese instructions assume you’re in the Android view.  Load the Crashlytics component into your app. See Load a Component in Your App for details about how to load a component into your app.      Remove any other analytics components that are loaded in your app (such as FlurryAnalyticsComponent, OmnitureAnalyticsComponent, or LoggerAnalyticsComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Flurry Analytics component and the Omniture Analytics component, because both components use the same IAnalytics interface. For a list of the components by interface, see Components Overview.    Expand Gradle Scripts and and open the build.gradle (Project: Application) file. (Your app will not be named “Fire App Builder,” but open the build.gradle file for your app’s name.)      Uncomment the code as noted in the Crashlytics code comments. The following code sample shows the code correctly uncommented:    buildscript {    repositories {        mavenCentral()        jcenter()        // Uncomment when using CrashlyticsComponent        maven { url 'https://maven.fabric.io/public' }    }    dependencies {        classpath 'com.android.tools.build:gradle:1.5.0'        classpath 'me.tatarka:gradle-retrolambda:3.2.3'    // Uncomment when using CrashlyticsComponent        classpath 'io.fabric.tools:gradle:1.+'    //         NOTE: Do not place your application dependencies here; they belong    //         in the individual module build.gradle files    }}allprojects {    repositories {        jcenter()        mavenCentral()        maven { url 'http://repo.brightcove.com/releases' }        // Uncomment when using CrashlyticsComponent        maven { url 'https://maven.fabric.io/public' }    }}    Go to CrashlyticsComponent &gt; manifests and open the AndroidManifest.xml file.      Insert your Crashlytics key in the value property:    android:name=\"io.fabric.ApiKey\"android:value=\"0c508f569dc758c937d5c0046a17871dcccce2c8\"/&gt;         Note: There’s a string named your_api_key in CrashlyticsComponent &gt; res &gt; values &gt; strings.xml. However, you don’t need to do anything with this string. The comment above the code instructs you to insert the Crashlytics key in the AndroidManifest.xml file instead.    Expand the Gradle Scripts folder and open the build.gradle (Module: app) file.      Uncomment the line as indicated by the Crashlytics comment:    // Uncomment when using CrashlyticsComponentapply plugin: 'io.fabric'    Expand the Gradle Scripts folder open the build.gradle (Module: app) file.      Uncomment the lines as indicated in the Crashlytics comment:      androidTestCompile 'com.jayway.android.robotium:robotium-solo:5.3.1'    compile project(':TVUIComponent')    compile project(':UAMP')    compile project(':AMZNMediaPlayerComponent')    compile project(':PassThroughAdsComponent')    compile project(':FacebookAuthComponent')    compile project(':AmazonInAppPurchaseComponent')    compile project(':LoggerAnalyticsComponent')    // Uncomment when using CrashlyticsComponent    compile('com.crashlytics.sdk.android:crashlytics:2.6.1@aar') {        transitive = true;    }    Build and run your app.When you build and run your app, Crashlytics will detect that your code is correctly configured. At this point, you will no longer be blocked at the Crashlytics onboarding screen and will be able to proceed to your Crashlytics dashboard.When fabric detects that your Crashlytics configuration is correct (based on you building your app), you see a screen like this that lets you proceed to your Dashboard, where you can view your crash analytics.Step 3. Make a Test CrashTo test out the Crashlytics configuration, perform a test crash:  In the Android view, go to TVUIComponent &gt; java &gt; com.amazon.android &gt; tv.tenfoot &gt; ui &gt; fragments and open the ContentDetailsFragment.java file.      Add the following inside the onStart() method near the top:    if(true) {throw new RuntimeException(\"Causing fake crash for Crashlytics test\");}        Click the Run ‘app’ button   to start your app.When the app starts, it immediately crashes. If you filter your logcat console by the keyword “crashlytics”, you’ll see the following logs:07-01 13:04:02.021 28688-28688/com.amazon.android.calypso D/CrashlyticsAnalyticsModuleInitReceiver: IAnalyticsModule initialized.07-01 13:04:02.064 28688-28688/com.amazon.android.calypso I/CrashlyticsCore: Initializing Crashlytics 2.3.8.9707-01 13:04:04.296 28688-28787/com.amazon.android.calypso I/CrashlyticsCore: Crashlytics report upload complete: 5776CC9E029B-0001-6E05-6C83E6F7D1F2.clsStep 4. Explore the Crashlytics DashboardAfter you have set up the code, run the app, and caused a crash, Crashlytics will let you bypass the onboarding page and take you to the Dashboard where you can view details about the crash.  Log into Crashlytics.  Click Dashboard in the upper-right corner.  View the information and settings on the Dashboard.Sample crash appearing in the Crashlytics Dashboard",
        "url": "fire-app-builder-crashlytics-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-flurry-analytics-component-html": {
        "title": "Flurry Analytics Component",
        "tags": "[]",
        "content": "Flurry provides analytics for your Android app that shows details related to media playback. According to Flurry Analytics:  The Flurry Analytics SDK provides you with the tools and resources you need to gain a deep level of understanding about your users’ behavior in your apps. Set up advanced analysis of complex events, with metrics, segments and funnels to better track your users’ habits and performance.Follow the sections below to configure Flurry Analytics.  Step 1. Get a Flurry API Key  Step 2. Configure the Flurry Analytics Component  Step 3. Encrypt your Flurry API Key  Checking Flurry in Your LogsStep 1. Get a Flurry API Key  Create an account with Flurry Analytics and get your API key.  Copy your Flurry API key into a convenient place.Step 2. Configure the Flurry Analytics Component      Load the Flurry Analytics Component into your app. See Load a Component in Your App.        Remove any other analytics components that are loaded in your app (such as Crashlytics, OmnitureAnalyticsComponent, or LoggerAnalyticsComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Flurry Analytics component and the Omniture Analytics component, because both components use the same IAnalytics interface. For a list of the components by interface, see Components Overview.        Go to FlurryAnalyticsComponent &gt; res &gt; values &gt; custom.xml and copy the following strings:    &lt;string name=\"encrypted_flurry_api_key\"&gt;YOUR_ENCRYPTED_FLURRY_API_KEY&lt;/string&gt;&lt;string name=\"flurry_key_1\"&gt;flurry_random_key_1&lt;/string&gt;&lt;string name=\"flurry_key_2\"&gt;flurry_random_key_2&lt;/string&gt;&lt;string name=\"flurry_key_3\"&gt;flurry_random_key_3&lt;/string&gt;&lt;string name=\"flurry_key_4\"&gt;flurry_random_key_4&lt;/string&gt;&lt;string name=\"flurry_key_5\"&gt;flurry_random_key_5&lt;/string&gt;&lt;string name=\"flurry_key_6\"&gt;flurry_random_key_6&lt;/string&gt;            Paste these strings in your app’s custom.xml file (located inside res &gt; values).     Tip: As a best practice to integrate future updates, always copy values from the component’s XML files into your app’s custom.xml file. Your app’s XML values will overwrite any values in your component’s XML files.    The encrypted_flurry_api_key string will hold the encrypted version of your Flurry API key. The flurry_key_[#] strings are used to create the encryption.  Step 3. Encrypt your Flurry API KeyYou must encrypt your Flurry API key.  Open your app’s custom.xml file (inside res &gt; values).      Type a random alphanumeric string for each of the flurry_key_[#] values. For example:    &lt;string name=\"flurry_key_1\"&gt;flurryblurry8837&lt;/string&gt;&lt;string name=\"flurry_key_2\"&gt;furryBEAR2999&lt;/string&gt;&lt;string name=\"flurry_key_3\"&gt;homer2YHfurrybaLL28_sneezun&lt;/string&gt;&lt;string name=\"flurry_key_4\"&gt;curry88fl@vrczng&lt;/string&gt;&lt;string name=\"flurry_key_5\"&gt;someFlurryBlurry9911&lt;/string&gt;&lt;string name=\"flurry_key_6\"&gt;yrrulFbackwardZZ44&lt;/string&gt;        In the Android View, expand the Utils &gt; java &gt; com &gt; amazon &gt; utils &gt; security folder and open the ResourceObfuscationStandaloneUtility class.      In the getRandomStringsForKey() method, enter the values you used for flurry_key_1, flurry_key_2, and flurry_key_3 respectively.    For example, assuming these first 3 keys are the ones displayed in the previous code sample, you would enter the following:    private static String[] getRandomStringsForKey() {    return new String[]{            \"flurryblurry8837\",            \"furryBEAR2999\",            \"homer2YHfurrybaLL28_sneezun\"    };}        In this example, the values are as follows:          flurryblurry8837 is the value used for flurry_key_1.      furryBEAR2999 is the value used for flurry_key_2.      homer2YHfurrybaLL28_sneezun is the value used for flurry_key_3.            In the getRandomStringsForIv() method, enter the values you used for flurry_key_4, random_key_5, random_key_6 respectively. For example:        private static String[] getRandomStringsForIv() {            return new String[]{                \"someFlurryBlurry9911\",                \"calypsoIslandShipBLLd99\",                \"yrrulFbackwardZZ44\"        };    }}        In this example, the values are as follows:          someFlurryBlurry9911 is the value used for flurry_key_4.      someFlurryBlurry9911 is the value used for flurry_key_5.      yrrulFbackwardZZ44 is the value used for flurry_key_6.            In the getPlainTextToEncrypt() method, insert your Flurry API key in place of Encrypt_this_text:     private static String getPlainTextToEncrypt() {        return \"Encrypt_this_text\";    }        Right-click the ResourceObfuscationStandaloneUtility.java file and select Run ‘ResourceObfusc…main().      Look for the encrypted result printed to the console. It will look something like this:    Encrypted version of plain text 123456789 is Hgei944983ljdfHoaQ==            Copy your encrypted Flurry API key and paste it into the encrypted_flurry_api_key string’s value in your app’s custom.xml file. For example:    &lt;string name=\"encrypted_flurry_api_key\"&gt;Hgei944983ljdfHoaQ==&lt;/string&gt;         Tip: Save your random keys in a safe place, such as your company wiki, so that you always have an easy way to retrieve them. You will need these keys to decrypt the value.  Flurry Analytics is now integrated into your app and will start sending in information about events.Checking Flurry in Your LogsWhen you build your app, view logcat with a filter on the word “flurry” to see how the Flurry Analytics Component gets triggered with events.Although it takes several hours before the activity data populates in Flurry Analytic’s dashboards, you can see event logs in a matter of minutes. In Flurry Analytics, go to Events &gt; Event Logs.",
        "url": "fire-app-builder-flurry-analytics-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-google-analytics-component-html": {
        "title": "Google Analytics Component",
        "tags": "[]",
        "content": "The Google Analytics Component allows you to gather analytics from your Android app using Google Analytics. You can learn more about the analytics service by going to Google Analytics. Configuring the component requires you to set up a google-services.json file that you generate from Google Analytics, and then match up dimensions and metrics indexes between Google Analytics and the component in Fire App Builder. You also need to set up custom reports that contain the dimensions and metrics you want.To configure the Google Analytics Component, complete each of the following sections.  Step 1. Configure the Google Analytics Component  Step 2. Set Up the google-services.json File  Step 3. Set Up Dimensions  Step 4. Set Up Metric Indexes  Step 5. Set Up Reports  Step 6. Verify Everything Is WorkingStep 1. Configure the Google Analytics Component      Remove any other analytics components that are loaded in your app (such as Crashlytics, OmnitureAnalyticsComponent, or LoggerAnalyticsComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Flurry Analytics component and the Omniture Analytics component, because both components use the same IAnalytics interface. For a list of the components by interface, see Components Overview.        Load the Google Analytics component into your app. See Load a Component in Your App for details about how to load a component into your app.     Note: Don’t click the Sync Gradle button until you have completed the next two steps.    In the Android view, expand the Gradle Scripts directory and open the build.gradle (Project: Application) file (substitute “Fire App Builder” with your project’s name).      Uncomment the classpath line below the Google Analytics component comment:    // Uncomment when using Google Analytics componentclasspath 'com.google.gms:google-services:3.0.0'        Now you can sync your Gradle files in your project by clicking the Sync Gradle button .  Step 2. Set Up the google-services.json FileGoogle Analytics packages all of your analytics settings into a google-services.json file. After you generate and download this file, you will place it in the Google Analytics Component folder.  Sign in to your Google account.  On the Google Analytics site, go to Add Analytics to Your Android App.  In the Get a configuration file section, click Get a Configuration File.  Enter an App name and an Android package name.          For the App name, type the name of your app.      For the Android package name, use the package name in the Google Analytics Component’s AndroidManifest.xml file: com.amazon.analytics.google.            Click Continue to choose and configure services.    Although the screen says “Select which Google services you’d like to add to your app below,” only Analytics is available for integration.    Click Continue to generate configuration files.  Click Download google-services.json and download the JSON file.  Move the google-services.json file into your GoogleAnalyticsComponent folder.Step 3. Set Up DimensionsIn this step you will set up dimensions in your app that correspond with dimensions that you set up in Google Analytics. According to Google Analytics’ documentation, “Dimensions are attributes of your data. For example, the dimension City indicates the city, for example, “Paris” or “New York”, from which a session originates. The dimension Page indicates the URL of a page that is viewed.”  In your app, expand GoogleAnalyticsComponent &gt; java &gt; com.amazon.analytics.google and open the GoogleAnalytics file.      Locate the following dimension indexes:    /** * Custom dimension indexes. */private final int PLATFORM_IDX = 1;private final int SEARCH_IDX = 2;private final int ERROR_MSG_IDX = 10;private final int PLAYBACK_SOURCE_IDX = 3;private final int PURCHASE_RESULT_IDX = 8;private final int PURCHASE_SKU_IDX = 9;private final int TITLE_IDX = 4;private final int SUBTITLE_IDX = 5;private final int VIDEO_TYPE_IDX = 6;private final int PURCHASE_TYPE_IDX = 7;        You will be creating dimensions in Google Analytics that correspond with the dimensions and indexes here. (You don’t need to do anything with the code here just yet. Just leave the file open to adjust later.)    Sign in to your Google Analytics Dashboard.  Click Admin on the top navigation row.      In the Property column (the middle column), click Custom Definitions &gt; Custom Dimensions.            Click the New Custom Dimension button.     Warning: You can only create 20 dimensions. Also, you cannot edit a dimension once you create it, so be careful here. If you mess up and need to change things, you may need to sign in with a different Google account.    Type a friendly name for the first dimension. For example, type “Platform” instead of “PLATFORM_IDX”.  Leave the Scope as Hit (the default).  Leave Active check box selected.      Click Create.        Click Done.  Repeat this process until you have created a custom dimension for all of the following values:          Platform      Search Term      Error Message      Playback Source      Purchase Source      Purchase Result      Purchase SKU      Title      Subtitle      Video Type      Purchase Type         Note: The names here (for example, “Platform”) do not need to match up with the names in the GoogleAnalytics.java file (for example, “PLATFORM_IDX”). Google will match up the dimensions based on the index values.        In the GoogleAnalytics.java file (inside GoogleAnalyticsComponent &gt; java &gt; com.amazon.analytics.google), change the index numbers to correspond with the auto-created dimension index numbers (highlighted in yellow in the screenshot below) in your Google Analytics Dashboard.        (Since you can’t customize the index values in Google Analytics, you have to make the index values in the component match up with the index values Google creates.)    /** * Custom dimension indexes. */private final int PLATFORM_IDX = 1;private final int SEARCH_IDX = 2;private final int ERROR_MSG_IDX = 10;private final int PLAYBACK_SOURCE_IDX = 3;private final int PURCHASE_RESULT_IDX = 8;private final int PURCHASE_SKU_IDX = 9;private final int TITLE_IDX = 4;private final int SUBTITLE_IDX = 5;private final int VIDEO_TYPE_IDX = 6;private final int PURCHASE_TYPE_IDX = 7;        Unless you created the dimensions in Google in the exact same order, it’s likely that your index values will be somewhat different. Just make sure each dimension you created in Google Analytics (for example, Error Message, 10) corresponds with the dimensions and indexes in your component (for example, ERROR_MSG_IDX = 10).  Step 4. Set Up Metric IndexesIn this section, you’ll do the same thing you did in the previous section but with metric indexes. According to Google Analytics’ documentation, “Metrics are quantitative measurements. The metric Sessions is the total number of sessions. The metric Pages/Session is the average number of pages viewed per session.”  In your app, expand GoogleAnalyticsComponent &gt; java &gt; com.amazon.analytics.google and open the GoogleAnalytics file.      Locate the following metric indexes:    /** * Custom metric indexes. */private final int AD_SECONDS_WATCHED_IDX = 1;private final int VIDEO_SECONDS_WATCHED_IDX = 2;private final int VIDEO_ID_IDX = 3;private final int AD_ID_IDX = 4;        Similar to dimensions, you will be creating metrics in Google Analytics that correspond with the metrics and indexes here. (You don’t need to do anything with the code here just yet. Just leave the file open to adjust later.)    Sign in to your Google Analytics Dashboard.  Click Admin on the top navigation row.      In the Property column (the middle), click Custom Definitions &gt; Custom Metrics.        Click the New Custom Metric button.     Warning: You can only create 20 metrics. Also, you cannot edit a metric once you create it, so be careful here. If you mess up and need to change things, you may need to sign in with a different Google account.    Type a friendly name for the first metric. For example, type “Ad Seconds Watched” instead of “AD_SECONDS_WATCHED_IDX”.  Leave the other values (Scope, Formatting Type, Minimum Value, Maximum Value, and Active) at the defaults unless you specifically want to adjust these values.  Click Create.  Click Done.  Repeat this process until you have created a custom dimension for all of the following values:          Ad Seconds Watched      Video Seconds Watched      Video ID      Ad ID         Note: As before, the names here (for example, “Ad Seconds Watched”) do not need to match up with the names in the GoogleAnalytics.java file (for example, “AD_SECONDS_WATCHED_IDX”). Google will match up the metrics based on the index values.        In the GoogleAnalytics.java file (inside GoogleAnalyticsComponent &gt; java &gt; com.amazon.analytics.google), change the metrics index numbers to correspond with the auto-created metric index numbers in your Google Analytics Dashboard.    (Since you can’t customize the index values in Google Analytics, you have to make the index values in the component match up with the index values Google creates.)  Step 5. Set Up ReportsThe final step is to create a report based on the dimensions and metrics in the component. Note: Only minimal information for creating custom reports is provided here. For full documentation, see Custom dimensions &amp; metrics in the Google documentation. You will need to choose how you want to match up the dimensions and metrics in your reports based on the information that’s important to you.  In Google Analytics, click Customization.  Click the New Custom Report button.  Give your custom report a Title.  In the Dimensions section, click + add dimension, expand Custom Dimensions, and select the dimensions you want.      In the Metrics Groups section, click + add metric, expand Custom Metrics, and select the metrics you want.        Make any other adjustments to your report, and click Save.Step 6. Verify Everything Is WorkingYou can verify the Google integration by doing the following:  In Android Studio, launch your app.      In Google Analytics, click Reporting and then go to Real-Time &gt; Overview.    You should see an active user.      ",
        "url": "fire-app-builder-google-analytics-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-omniture-analytics-component-html": {
        "title": "Omniture Analytics Component",
        "tags": "[]",
        "content": "Omniture gives you a JAR file to integrate into your app (instead of relying on API keys). The JAR file stores your security keys and other configuration information. Note: These instructions assume you have the Project view selected in Android Studio.To configure the Omniture Analytics Component:  Load the Omniture Analytics component into your app. See Load a Component in Your App for details about how to load a component into your app.      Remove any other analytics components that are loaded in your app (such as FlurryAnalyticsComponent, CrashlyticsComponent, or LoggerAnalyticsComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Flurry Analytics component and the Omniture Analytics component, because both components use the same IAnalytics interface. For a list of the components by interface, see Components Overview.    Inside your app’s folder, create a folder called AdobeMobileLibrary.      Inside this new AdobeMobileLibrary folder, put the JAR file that Adobe gives you.    For example, if the JAR file were named adobeMobileLibrary-4.6.1.jar, the path to the file would look like this:  (your app) &gt; AdobeMobileLibrary &gt; adobeMobileLibrary-4.6.1.jar.        In the AdobeMobileLibrary folder, open the build.gradle file  add a reference to your JAR file:    configurations.create(\"default\")artifacts.add(\"default\", file('adobeMobileLibrary-4.6.1.jar'))            Inside your app’s settings.gradle file, include the AdobeMobileLibrary component:    include  ':app',         ':AdobeMobileLibrary',            In the OmnitureAnalyticsComponent folder, open the build.gradle file and make sure there’s a dependency for the AdobeMobileLibrary:    dependencies {compile fileTree(dir: 'libs', include: ['*.jar'])compile project(':ModuleInterface')compile project(':AnalyticsInterface')compile project(':AdobeMobileLibrary')}        Your app will now start tracking activities using Omniture Analytics.  ",
        "url": "fire-app-builder-omniture-analytics-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-adobe-pass-auth-component-html": {
        "title": "Adobe Pass Authorization Component",
        "tags": "[]",
        "content": "Adobe Primetime (formerly Adobe Pass) provides an authentication mechanism that requires users to log in prior to viewing media. Users sign in to their ISP or content provider, and those credentials then authenticate them with the app. You can learn more at Adobe Primetime here. Note: Previously, when the component was coded, “Adobe Primetime” was called “Adobe Pass.” The name Adobe Pass is still used in the code, and the component’s name is AdobePassAuthComponent, so you will see the terms Adobe Pass and Adobe Primetime used somewhat interchangeably in the documentation.  The User Experience with Adobe Pass  Configuring the Adobe Pass Auth Component  Step 1. Configure the Adobe Pass Auth Component in Your App  Step 2. Encrypt Your Adobe Primetime Keys          Encrypting Other Values        Step 3. Configure the Strings for the Adobe Primetime Login Prompt  Step 4. Customize the Styles for the Adobe Pass Screens  Step 5. Configure Which Screen to Prompt Users to Log inThe User Experience with Adobe PassThis example shows a configuration of Adobe Pass/Primetime with a sample app.When users click the Watch Now button on the Content Details screen, they’re greeted by an Adobe Primetime Login prompt:Adobe Primetime login promptUsers open a browser on their computer and go to the indicated URL (in this example, www.example.com/amazon/firetv) to enter the registration code. The user also signs in to their cable provider.Authenticating with Adobe Pass requires users to sign in to their cable provider.After the user enters the registration code and cable provider credentials, the user is logged in and sees a success screen similar to this one. (You configure these URLs and screens through your Adobe Primetime account.)Login success.Now the user turns back to the Fire TV and clicks the Submit button to log in. The app now lets the user watch media.If the login is unsuccessful, the user sees an error message on the screen indicating what went wrong:Possible error messages screen from an unsuccessful Adobe Primetime login attempt.Configuring the Adobe Pass Auth ComponentTo configure the Adobe Pass Component, follow these five steps:  Step 1. Configure the Adobe Pass Auth Component in Your App  Step 2. Encrypt Your Adobe Pass Keys  Step 3. Configure the Strings for the Adobe Pass Login Prompt  Step 4. Customize the Styles for the Adobe Pass Screens  Step 5. Configure Which Screen to Prompt Users to Log inStep 1. Configure the Adobe Pass Auth Component in Your AppThe Adobe Pass Auth Component provides three separate groups of files you can customize that configure the Adobe Pass information and the Fire TV user interface that users see.To configure the Adobe Pass Authorization Component:  Load the Adobe Pass Authorization component into your app. See Load a Component in Your App for details about how to load a component into your app.      Remove any other authentication components that are loaded in your app (such as FacebookAuthComponent or LoginWithAmazonComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Adobe Pass Auth component and the Pass Through Login component, because both components use the same IAuthentication interface. For a list of the components by interface, see Components Overview.    Go to AdobePassAuthComponent &gt; res &gt; values and open the custom.xml file.      Copy the following values and paste them into your app’s custom.xml file:    &lt;!--Adobe pass clientless API Requestor ID --&gt;&lt;string name=\"adobe_pass_requestor_id\"&gt;YOUR REQUESTOR ID&lt;/string&gt;&lt;!-- Encrypted Adobe pass public key for your application, encrypt it usingKeyEncrypterStandaloneUtility --&gt;&lt;string name=\"encrypted_adobe_pass_public_key\"&gt;YOUR ENCRYPTED PUBLIC KEY&lt;/string&gt;&lt;!-- Encrypted Adobe pass secret key for your application, encrypt it usingKeyEncrypterStandaloneUtility --&gt;&lt;string name=\"encrypted_adobe_pass_private_key\"&gt;YOUR ENCRYPTED PRIVATE KEY&lt;/string&gt;&lt;!--Adobe pass clientless API registration URL for second screen login --&gt;&lt;string name=\"adobe_pass_registration_url\"&gt;YOUR REGISTRATION URL&lt;/string&gt;&lt;!--Adobe pass clientless API time to live value for the registration token --&gt;&lt;string name=\"adobe_pass_registration_code_ttl\"&gt;YOUR TIME TO LIVE VALUE&lt;/string&gt;&lt;!-- URL used by user to authenticate --&gt;&lt;string name=\"adobepass_login_instruction_line_2\"&gt;Visit YOUR_AUTHENTICATION_URL&lt;/string&gt;&lt;!-- PseudoRandom strings, used to generate random key for encrypting/decrypting resources.These keys should always remain in sync with the keys used by encrypting utility --&gt;&lt;string name=\"random_key_1\"&gt;random_key_1&lt;/string&gt;&lt;string name=\"random_key_2\"&gt;random_key_2&lt;/string&gt;&lt;string name=\"random_key_3\"&gt;random_key_3&lt;/string&gt;&lt;string name=\"random_key_4\"&gt;random_key_4&lt;/string&gt;            Customize the values for each property as explained in the following table:                Value      Description                  adobe_pass_requestor_id      Your Adobe Primetime requestor ID. This value is provided by Adobe.              encrypted_adobe_pass_public_key      Your encrypted Adobe Primetime public key (provided by Adobe). Although this key is provided to you by Adobe, you must encrypt it. See Encrypt Your Adobe Primetime Keys for details on generating this key.              encrypted_adobe_pass_private_key      Your encrypted Adobe Primetime private key. Although this key is provided to you by Adobe, you must encrypt it. See Encrypt Your Adobe Primetime Keys for details on generating this key.              adobe_pass_registration_url      The registration URL. This value is provided by Adobe.              adobe_pass_registration_code_ttl      How long until the registration code expires.              adobepass_login_instruction_line_2      Information about where users go to log in.              random_key_1      A random string used in encrypting the public and private keys. Type any alphanumeric string for the value.              random_key_2      A random string used in encrypting the public and private keys. Type any alphanumeric string for the value.              random_key_3      A random string used in encrypting the public and private keys. Type any alphanumeric string for the value.              random_key_4      A random string used in encrypting the public and private keys. Type any alphanumeric string for the value.        Step 2. Encrypt Your Adobe Primetime KeysWhen you set up an Adobe Primetime account, you’re provided with a public and private key. To keep these values secure, the Adobe Pass Component in Fire App Builder encrypts the keys with a security algorithm. The algorithm is implemented through the ResourceObfuscator and ResourceObfuscationStandaloneUtility classes in your app’s Utils folder.To encrypt your Adobe Primetime public and private key:  In the Android View, expand the Utils &gt; java &gt; com &gt; amazon &gt; utils &gt; security folder and open the ResourceObfuscationStandaloneUtility class.      In the getRandomStringsForKey() method, enter the values you used for random_key_1, random_key_4, and random_key_3 (in the component’s custom.xml file) respectively.    For example, suppose you used the following random strings in your custom.xml file:    &lt;string name=\"random_key_1\"&gt;calypso&lt;/string&gt;&lt;string name=\"random_key_2\"&gt;dadadadadappppp&lt;/string&gt;&lt;string name=\"random_key_3\"&gt;more_random_stuff&lt;/string&gt;&lt;string name=\"random_key_4\"&gt;something_random&lt;/string&gt;        You would customize the strings in the ResourceObfuscationStandaloneUtility class as follows:    private static String[] getRandomStringsForKey() {    return new String[]{            \"calypso\",            \"something_random\",            \"more_random_stuff\"    };}        In this example, the values are as follows:          calypso is the value used for random_key_1.      something_random is the value used for random_key_4.      more_random_stuff is the value used for random_key_3.            In the getRandomStringsForIv() method, enter the values you used for random_key_2 and random_key_3 respectively:        private static String[] getRandomStringsForIv() {        return new String[]{                \"dadadadadappppp\",                \"more_random_stuff\"        };    }}        In this example, the values are as follows:          dadadadadappppp is the value used for random_key_2.      more_random_stuff is the value used for random_key_3. (Same as before.)            In the getPlainTextToEncrypt() method, insert your Adobe Pass public key in place of Encrypt_this_text:     private static String getPlainTextToEncrypt() {        return \"Encrypt_this_text\";    }            Right-click the ResourceObfuscationStandaloneUtility.java file and select Run ‘ResourceObfusc…main().        Look for the encrypted result printed to the console. It will look something like this:    Encrypted version of plain text 123456789 is gnobHJEIxnkBMobJk7mBaQ==            Copy your encrypted key. Paste this key into the encrypted_adobe_pass_public_key value in your app’s custom.xml file (as per the instructions in the previous section). For example:    &lt;string name=\"encrypted_adobe_pass_public_key\"&gt;gnobHJEIxnkBMobJk7mBaQ==&lt;/string&gt;&lt;string name=\"encrypted_adobe_pass_private_key\"&gt;YOUR ENCRYPTED PRIVATE KEY&lt;/string&gt;            Now insert your Adobe Pass private key into the getPlainTextToEncrypt() method, and run the script again (using the same random strings). Copy the encrypted key into the encrypted_adobe_pass_private_key string value in your app’s custom.xml file. For example:    &lt;string name=\"encrypted_adobe_pass_public_key\"&gt;gnobHJEIxnkBMobJk7mBaQ==&lt;/string&gt;&lt;string name=\"encrypted_adobe_pass_private_key\"&gt;bhjKDUYhdlkNNbUEYyvbn==&lt;/string&gt;         Tip: Save your random keys in a safe place, such as your company wiki, so that you always have an easy way to retrieve them.  Encrypting Other ValuesThe encryption utility can be used for any keys you want to encrypt in your app, not just for Adobe Primetime keys. You can use the ResourceObfuscatorStandaloneUitility class to encrypt the keys and the ResourceObfuscator class to decrypt keys.The Adobe Pass Component already leverages the ResourceObfuscator class to decrypt the keys. The random strings you entered (in the custom.xml file in the component) get passed into the ResourceObfuscator class, which does the encryption. The AdobepassRestClient.java class in the Adobe Pass Auth Component instantiates this ResourceObfuscator class and passes in your random strings:  ResourceObfuscator obfuscator = new ResourceObfuscator();        String plainKey = obfuscator.unobfuscate(key, getRandomStringsForKey(appContext),                                                 getRandomStringsForIv(appContext));        return plainKey;    }Note that this encryption technique is not hack proof. There are stronger methods of encryption. However, the algorithm does help prevent malicious users from easily finding and using your keys.Step 3. Configure the Strings for the Adobe Primetime Login PromptYou can configure the strings that appear in the Adobe Primetime Login prompt screen:Adobe Primetime login promptYou can also control the text in the error messages screen that appears if the login fails:Adobe Pass error messagesTo customize the text on these screens:  Go to AdobepassAuthComponent &gt; res &gt; values and open the strings.xml file.      Customize the string values for each of the elements.    &lt;string name=\"app_name\"&gt;AdobepassAuthComponent&lt;/string&gt;   &lt;string name=\"title_activity_adobe_authentication\"&gt;Authentication&lt;/string&gt;   &lt;string name=\"adobepass_login_instruction_line_1\"&gt;Go to your computer or mobile device&lt;/string&gt;   &lt;string name=\"adobepass_login_instruction_line_3\"&gt;Enter the following case-sensitive code:&lt;/string&gt;   &lt;string name=\"adobepass_login_instruction_line_4\"&gt;Loading...&lt;/string&gt;   &lt;string name=\"btn_submit\"&gt;SUBMIT&lt;/string&gt;   &lt;string name=\"btn_get_new_code\"&gt;GET NEW CODE&lt;/string&gt;   &lt;string name=\"adobe_pass_error_authentication_message\"&gt;There was an error authenticating the account. Please try again later.&lt;/string&gt;   &lt;string name=\"adobe_pass_error_registration_message\"&gt;There was an error authenticating the account. Please try again later.&lt;/string&gt;   &lt;string name=\"adobe_pass_no_authorization_message\"&gt;Your subscription package does not include this video.      Step 4. Customize the Styles for the Adobe Pass ScreensYou can customize the logo and colors of the Adobe Primetime login user interface in your app.To customize the styles:  Go to AdobepassAuthComponent &gt; res &gt; values and open the styles.xml file.      Customize the string values for each of the elements. See the preceding screenshots to see how the element names and text affects the display.        &lt;style name=\"AppTheme\" parent=\"android:Theme.Holo.Light.DarkActionBar\"&gt;    &lt;/style&gt;    &lt;drawable name=\"company_logo\"&gt;@drawable/logo&lt;/drawable&gt;    &lt;drawable name=\"splash_background\"&gt;@drawable/bg_generic_nopreview&lt;/drawable&gt;    &lt;drawable name=\"action_button_focused\"&gt;@drawable/btn_generic_focused&lt;/drawable&gt;    &lt;color name=\"action_button_text_color\"&gt;#E6FFFFFF&lt;/color&gt;    &lt;color name=\"action_button_text_color_focused\"&gt;#E6FFFFFF&lt;/color&gt;    &lt;drawable name=\"action_button_normal\"&gt;@drawable/btn_normal&lt;/drawable&gt;      Step 5. Configure Which Screen to Prompt Users to Log inYou need to configure which screens should implement the authentication. For example, you might want to require authentication only for the PlaybackActivity on the Content Renderer screens, so that unauthenticated users can be enticed by the media in your app and be motivated to sign in.To configure which screens require authentication:  Open the Navigator.json file (located in app &gt; assets).      In the graph object, locate the activity you want to restrict (such as PlaybackActivity), and change verifyScreenAccess to true. For example:    \"com.amazon.android.uamp.ui.PlaybackActivity\": {  \"verifyScreenAccess\": true,  \"verifyNetworkConnection\": true,  \"onAction\": \"CONTENT_RENDERER_SCREEN\"}      ",
        "url": "fire-app-builder-adobe-pass-auth-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-facebook-auth-component-html": {
        "title": "Facebook Authorization Component",
        "tags": "[]",
        "content": "With the Facebook Auth Component, you can prompt users to log in using Facebook before they watch media (or perform some other action).  The User Experience with Facebook Authorization  Configuration Overview  Step 1. Get a Facebook App ID and Client Token  Step 2. Configure Your App  Step 3. Encrypt the Facebook App ID and Token Values  Step 4. Decide When to Prompt Users to Log In{#step4}  Step 5. Customize the UI Text{#step5}  Disable User’s Ability to Postpone Login  Looking at the Logs for Facebook Auth Component ActionsThe User Experience with Facebook AuthorizationIf you require users to log in before playing media, users will see the following prompt after clicking “Watch Now” on the Content Details screen:Login prompt when verifyScreenAccess is set to true for the PlaybackActivityIf a user clicks Later, he or is able to watch media without logging into Facebook. (Currently, there isn’t a later prompt that asks the user again.)If a user clicks Now, he or she is prompted to log into Facebook via a computer browser:Prompt to log into Facebook.After logging in, Facebook shows the following screenshot:Facebook login success on the browserAfter clicking Continue on the browser window, the user clicks Submit on the Facebook Login prompt on the Fire TV screen.Configuration OverviewFollow these steps to configure the Facebook Authorization Component  Step 1. Get a Facebook App ID and Client Token  Step 2. Configure Your App  Step 3. Encrypt the Facebook App ID and Token Values  Step 4. Decide When to Prompt Users to Log In  Step 5. Customize the UI TextStep 1. Get a Facebook App ID and Client TokenFirst you must set up a Facebook app to get the app ID and client token. Note that the app name you choose will be visible when users log in via their computer browsers, so choose a name (usually your Fire TV app’s name) that you want users to see.Note that these instructions were written in June 2016. Facebook may have changed some of the button names, steps, or workflow since that time.To create a Facebook app:  Go to Register and Configure an App in the Facebook for Developers site and create a Facebook app. Be sure to follow steps 1, 2, and 3.  After you click Create new Facebook App in step 3, select Android.  In the “Quick Start for Android” screen, type a name for your app (use the same name as your Fire TV app). Then click Create New Facebook App ID.  Complete the required fields to create a Facebook app. In the “Tell us about your Android project” section, note that the “Package Name” and “Default Activity Class Name” are required but won’t actually be used since these fields relate to Google Play.  When you click Next, you’re prompted with a “Google Play Package Name” dialog box indicating that it can’t find your package name in Google Play. Click Use this package name to ignore the message.  An additional section appears: “Add your development and release key hashes.” Follow the steps in this section to generate a key hash and add it in the Key Hashes field. Then click Next.  You’ve finished the Quick Start for Android. In the upper-right corner of the screen, select My Apps and select your new app.  In the left sidebar, under PRODUCTS, click + Add Product.  Next to Facebook Login, click Get Started.      In the Client OAuth Settings section, turn on Login from Devices.    Client OAuth settings for your Facebook app.    Click Save Changes.  In the left sidebar, click Settings &gt; Basic. Copy the App ID into a convenient place.  In the left sidebar, click Settings &gt; Advanced. Copy the Client Token into a convenient place.Step 2. Configure Your AppThe Facebook Auth Component should already be loaded in the sample app in Fire App Builder, but you will need to configure the component.  The Facebook Auth Component is already loaded in the sample app built with Fire App Builder. If it isn’t loaded due to updates you’ve made, see Load a Component in Your App.      Remove any other authentication components that are loaded in your app (such as AdobepassAuthComponent or LoginWithAmazonComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Adobe Pass Auth component and the Pass Through Login component, because both components use the same IAuthentication interface. For a list of the components by interface, see Components Overview.  Step 3. Encrypt the Facebook App ID and Token ValuesYou must insert an encrypted version of the Facebook app ID and client token into your app. To encrypt your app ID and client token:  Expand the FacebookAuthComponent &gt; res &gt; values folder and open the strings.xml file.      Copy the following strings and paste them into your app’s custom.xml file:    &lt;string name=\"encrypted_fb_client_token\"&gt;YOUR_ENCRYPTED_FB_APP_CLIENT_TOKEN&lt;/string&gt;&lt;string name=\"encrypted_fb_app_id\"&gt;YOUR_ENCRYPTED_FB_APP_ID&lt;/string&gt;    &lt;string name=\"fb_key_1\"&gt;fb_random_key_1&lt;/string&gt;&lt;string name=\"fb_key_2\"&gt;fb_random_key_2&lt;/string&gt;&lt;string name=\"fb_key_3\"&gt;fb_random_key_3&lt;/string&gt;&lt;string name=\"fb_key_4\"&gt;fb_random_key_4&lt;/string&gt;&lt;string name=\"fb_key_5\"&gt;fb_random_key_5&lt;/string&gt;&lt;string name=\"fb_key_6\"&gt;fb_random_key_6&lt;/string&gt;         Tip: As a best practice to integrate future updates, always copy values from the component’s XML files into your app’s custom.xml file. Your app’s XML values will overwrite any values in your component’s XML files.    The encrypted_authentication_client_token is the encrypted version of the client token you generated when you created your Facebook app. The encrypted_authentication_app_id is the encrypted version of the Facebook app ID. You’ll encrypt these values in the upcoming steps. The random keys are used to create the encryption.        Type a random alphanumeric string for each of these fb_key_[#] values. For example:    &lt;string name=\"fb_key_1\"&gt;odysseusgrEEk2000bc&lt;/string&gt;&lt;string name=\"fb_key_2\"&gt;helengreekFAce5000ships&lt;/string&gt;&lt;string name=\"fb_key_3\"&gt;homer@1storyTllr20&lt;/string&gt;&lt;string name=\"fb_key_4\"&gt;latinusOdysseusson332&lt;/string&gt;&lt;string name=\"fb_key_5\"&gt;calypsoIslandShipBLLd99&lt;/string&gt;&lt;string name=\"fb_key_6\"&gt;athenazeusEPICodysseY77&lt;/string&gt;        In the Android View, expand the Utils &gt; java &gt; com &gt; amazon &gt; utils &gt; security folder and open the ResourceObfuscationStandaloneUtility class.      In the getRandomStringsForKey() method, enter the values you used for fb_key_1, fb_key_2, and fb_key_3 respectively.    For example, assuming these first 3 keys are the ones displayed in the previous code sample, you would enter the following:    private static String[] getRandomStringsForKey() {    return new String[]{            \"odysseusgrEEk2000bc\",            \"helengreekFAce5000ships\",            \"homer@1storyTllr20\"    };}        In this example, the values are as follows:          odysseusgrEEk2000bc is the value used for fb_key_1.      helengreekFAce5000ships is the value used for fb_key_2.      homer@1storyTllr20 is the value used for fb_key_3.            In the getRandomStringsForIv() method, enter the values you used for fb_key_4, random_key_5, and random_key_6 respectively. For example:        private static String[] getRandomStringsForIv() {            return new String[]{                \"latinusOdysseusson332\",                \"calypsoIslandShipBLLd99\",                \"athenazeusEPICodysseY77\"        };    }}        In this example, the values are as follows:          latinusOdysseusson332 is the value used for fb_key_4.      calypsoIslandShipBLLd99 is the value used for fb_key_5.      athenazeusEPICodysseY77 is the value for fb_key_6.            In the getPlainTextToEncrypt() method, insert your Facebook client token in place of Encrypt_this_text:     private static String getPlainTextToEncrypt() {        return \"Encrypt_this_text\";    }            Right-click the ResourceObfuscationStandaloneUtility.java file and select Run ‘ResourceObfusc…main().        Look for the encrypted result printed to the console. It will look something like this:    Encrypted version of plain text 123456789 is mTWxLhZeHslQFwpN3irjfQ==            Copy your encrypted app ID and paste it into the encrypted_fb_client_token string’s value in your app’s custom.xml file. For example:    &lt;string name=\"encrypted_fb_client_token\"&gt;rneiu89EIxnk9489faoPoaQ&lt;/string&gt;&lt;string name=\"encrypted_fb_app_id\"&gt;YOUR_ENCRYPTED_FB_APP_ID&lt;/string&gt;            Now insert your Facebook app ID into the getPlainTextToEncrypt() method, and run the script again (using the same random strings). Copy the encrypted key into the encrypted_fb_app_id string value in your app’s custom.xml file. For example:    &lt;string name=\"encrypted_adobe_pass_public_key\"&gt;gnobHJEIxnkBMobJk7mBaQ==&lt;/string&gt;&lt;string name=\"encrypted_adobe_pass_private_key\"&gt;AQ/9Qtc26GzLVSHRe1ftPw==&lt;/string&gt;         Tip: Save your random keys in a safe place, such as your company wiki, so that you always have an easy way to retrieve them. You will need these keys to decrypt the value.  Step 4. Decide When to Prompt Users to Log In{#step4}You can configure the screen where users should be prompted to log in to Facebook.  Open the Navigator.json file (located in your app’s assets folder).      Set the verifyScreenAccess value to true for the screen where you want users to log in. For example, if you want users to log in before playing media, you would verify screen access at the PlaybackActivity:      \"com.amazon.android.uamp.ui.PlaybackActivity\": {  \"verifyScreenAccess\": true,  \"verifyNetworkConnection\": true,  \"onAction\": \"CONTENT_RENDERER_SCREEN\"}        Now when users launch your app and try to watch media, they will be prompted to log in.  Step 5. Customize the UI Text{#step5}To change the text that appears in the dialog box prompting users to log in:  Go to ContentBrowser &gt; res &gt; values and open the strings.xml file.      Copy the following strings into your app’s custom.xml file (inside res &gt; values):    &lt;string name=\"optional_login_dialog_title\"&gt;Login&lt;/string&gt;&lt;string name=\"optional_login_dialog_message\"&gt;Do you want to get most of your app by logging in now?&lt;/string&gt;&lt;string name=\"now\"&gt;Now&lt;/string&gt;&lt;string name=\"later\"&gt;Later&lt;/string&gt;        Customize the string values.Disable User’s Ability to Postpone LoginBy default, users have the option of postponing the Facebook login. Currently if users click Later at this prompt, they aren’t prompted ever again – this is a bug. To disable the user’s ability to postpone the Facebook login:  Expand the FacebookAuthComponent &gt; res values folder and open the custom.xml file.      Copy the following strings into your app’s custom.xml file (inside res &gt; values):    &lt;bool name=\"is_authentication_can_be_done_later\"&gt;true&lt;/bool&gt;        Change the string’s value to false.Looking at the Logs for Facebook Auth Component ActionsAfter a user has already logged in, when he or she restarts the Fire TV app, the Facebook Auth Component will automatically check to see if the user is already logged in. Filtering the logcat to show “facebook” only, you will see the following if a user is not logged in:06-24 17:39:18.602 29089-29089/com.amazon.android.calypso D/FacebookAuthenticationModuleInitReceiver: IAuthenticationModule initialized.06-24 17:39:18.684 29089-29089/com.amazon.android.calypso D/FacebookAuthentication: Facebook configured and previous access token is:06-24 17:39:43.566 29089-29089/com.amazon.android.calypso D/FacebookAuthentication: Checking if user is logged in06-24 17:39:43.569 29089-29089/com.amazon.android.calypso D/FacebookAuthentication: Access token is null. User not logged in.06-24 17:39:43.612 29089-29089/com.amazon.android.calypso D/Navigator: FacebookAuthenticationActivity onActivityCreatedIn this case, the user is not logged in, so the FacebookAuthenticationActivity gets created.If a user is logged in, the logcat will show something like the following:06-24 17:46:27.933 29089-29148/com.amazon.android.calypso D/FacebookApi: Making http call to Facebook url: https://graph.facebook.com/v2.6/device/login_status06-24 17:46:28.235 29089-29148/com.amazon.android.calypso D/FacebookApi: Response from HTTP call: {\"access_token\":\"AAOA4zsiSjMBAJa42JB2LTTyIjq3hQTAl9RTq5FVA8QxKQFhhBlGlqGXpsqQYX9Puo5ZAZBW2eUgoyYquifpTaZAKS9SJhvJefv0hUMjGqAmjuOVNOxNjZCxQQmA23dc4Xcqhs8goZBIuYmbYKuJnltAopk5dQF4ZD\",\"expires_in\":5183946}06-24 17:46:28.235 29089-29089/com.amazon.android.calypso D/com.amazon.android.auth.facebook.FacebookAuthentication: Storing access token: AAOA4zsiSjMBAJa42JB2LTTyIjq3hQTAl9RTq5FVA8QxKQFhhBlGlqGXpsqQYX9Puo5ZAZBW2eUgoyYquifpTaZAKS9SJhvJefv0hUMjGqAmjuOVNOxNjZCxQQmA23dc4Xcqhs8goZBIuYmbYKuJnltAopk5dQF4ZD06-24 17:46:28.257 29089-29089/com.amazon.android.calypso D/Navigator: FacebookAuthenticationActivity onActivityPaused06-24 17:46:28.257 29089-29089/com.amazon.android.calypso D/AnalyticsManager: FacebookAuthenticationActivity onActivityPaused, analytics tracking.Here the access token is retrieved because the session is still active. As a result, the user is automatically logged in.If you want to change the way the events are reported, you can manually customize the string values in FacebookAuthComponent &gt; java &gt; com.amazon.android.auth.facebook &gt; FacebookApi.java. For example, if you do not want to use the term name in your analytics, you can customize this to another value:public static final String NAME = \"name\";To clear any login settings, scroll down to the bottom of your Fire TV app and click the Logout button.",
        "url": "fire-app-builder-facebook-auth-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-login-with-amazon-component-html": {
        "title": "Login with Amazon Component",
        "tags": "[]",
        "content": "The Login with Amazon Component allows you to prompt users to log in to your Amazon Fire TV app using their Amazon account credentials before they perform a specific action, such as watching media. To learn more, see Login with Amazon.Since Amazon Fire TV already requires users to log in with their Amazon accounts when they set up and register their Fire TV, the real benefit of the component isn’t that it allows users to log in with their Amazon account. The component’s benefit is that it prompts users to consent to share their Amazon name and email address with your app. This allows you to get a better sense of your audience.  The User Experience with Login with Amazon Component  Configuration Overview  Step 1. Configure Your App  Step 2. Create a Security Profile on the Developer Console  Step 3. Get the Login with Amazon API Key          Getting Your App’s Signature      The User Experience with Login with Amazon ComponentWhen users click the Watch Now button to view media, they see a Login with Amazon button that starts the login process:Figure 1. Login with Amazon buttonAfter clicking the button, the user is presented with a secure login screen (hosted by Amazon) that shows the user’s name and email address (associated with their Fire TV account). They are asked to consent to share this data (name + email address) with the app. The consent screen shows the app name, logo, and privacy notice.Figure 2. Privacy consent screen.If users click I agree, they are redirected back to the app with a token that grants them access to watch the media.Figure 3. Success and return back to the app.Once back in the app, the user clicks Return. The media the user selected begins to play.If users do not consent to share their info with the app, they are redirected back to the app and see the same Login with Amazon screen (Figure 1) as before.Once logged in, users can log out using the Logout button at the bottom of your app. The next time users try to view media, they will be prompted to log in again (Figure 1). Since users have already consented to share their details with the app, the privacy screen (Figure 2) will be bypassed.If users want to revoke your app’s access to their data, they do the following:  Log in to https://amazon.com and go to Your Account &gt; Your Account. (Or go directly here.)  Under Settings, click Manage Login with Amazon.  Click Remove next to your app.Configuration OverviewTo configure the Login with Amazon Component, follow these steps:  Step 1. Configure Your App  Step 2. Create a Security Profile on the Developer Console  Step 3. Get the Login with Amazon API KeyStep 1. Configure Your AppTo configure the Login with Amazon Component:  As with other components, follow the general instructions to Load a Component in Your App.      Remove any other authentication components that are loaded in your app (such as AdobepassAuthComponent or FacebookAuthComponent). See Remove a Component for details.     Note: You can load only one component per interface. For example, you cannot load both the Adobe Pass Auth component and the Pass Through Login component, because both components use the same IAuthentication interface. For a list of the components by interface, see Components Overview.    In your app, open the Navigator.json file (located in app &gt; assets).      Set the verifyScreenAccess value to true for the screen where you want users to log in. For example, if you want users to log in before playing media, you would verify screen access at the PlaybackActivity:      \"com.amazon.android.uamp.ui.PlaybackActivity\": {  \"verifyScreenAccess\": true,  \"verifyNetworkConnection\": true,  \"onAction\": \"CONTENT_RENDERER_SCREEN\"}        To change the text that appears in the Login with Amazon screen (Figure 1), go to LoginWithAmazonComponent &gt; res &gt; values &gt; strings.xml. Copy the strings into your app’s custom.xml file (inside res &gt; values) and customize the string values.To fully configure the component, you will need to insert the API key from the Login with Amazon service. The next sections explain how to get this API key.Step 2. Create a Security Profile on the Developer ConsoleYou must create a security profile for your app on the Developer Console. This security profile is used by the Login with Amazon service and is required to get an API key.Your security profile contains information about your app and is displayed to users on the privacy consent screen (Figure 2). On the privacy consent screen, users see the name of your application, your logo, and a link to your privacy policy.To set up your security profile, follow the instructions in the “Register Your Security Profile” section on the Register your Android app with Login with Amazon page.Step 3. Get the Login with Amazon API KeyAfter creating a security profile on the Developer Console, you must add settings for the app that will use Login with Amazon with that profile. You can then get an API key and finish configuring the Login with Amazon Component in your app.      Complete the steps in the “Adding an Android App to a Security Profile” section on the Register your Android app with Login with Amazon page. Note the following:          For the package name, open the AndroidManifest.xml file (located in your app &gt; manifests) in Android Studio. The package name is listed at the top. By default, the package name is com.amazon.android.calypso. However, you most likely changed the package name when you customized your app.      To get the MD5 value for the Signature field, see the following section, Getting Your App’s Signature.            Get your API key by following the steps in the “Retrieving an Android API Key” section on the Register your Android app with Login with Amazon page.        After you get the API key, go into the LoginWithAmazonComponent &gt; assets folder in Android Studio and open the api_key.txt file. Delete all the default text that appears in that file, and then paste your API key.  Getting Your App’s SignatureYour apps must be signed in order to interact with the Login with Amazon service. Before you release your app, your signature is stored in a debug keystore. After you release your app, your signature is stored in a release keystore. The Login with Amazon service will use your app’s signature to construct the API key that is necessary to configure the Login with Amazon Component.If you’re testing out your app (that is, you haven’t yet released it to the Amazon Appstore), Android Studio automatically generates a signature for your APK file. While you’re in the coding/testing phase, you can use this signature to test the Login with Amazon functionality. When you officially release your app, you will need to generate a new API key based on the signature from the release keystore.For more information about signatures, see Android App Signatures and API Keys. See also Sign Your App in the Android documentation.To get the MD5 value from your signature, you use a Java utility called keytool. To use keytool to get your signature’s MD5 value:      Add keytool to your PATH:          Locate the path to keytool. keytool is in the Home/bin directory of your JDK location. For example, on a Mac, the path is /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin. (The exact path depends on your version of the JDK. Update this path based on your version.)              Add this location to your PATH. On a Mac, you can use a command such as the following:        echo 'export PATH=$PATH:/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin' &gt;&gt; ~/.bash_profile                For Windows users, use Windows methods for adding tools to your PATH.                  With keytool in your PATH, browse to the folder where the debug.keystore resides. This path is as follows:    /Users/&lt;your username&gt;/.android/debug.keystore        Replace &lt;your username&gt; with your username.        Run the following keytool command, replacing &lt;alias&gt; with androiddebugkey and &lt;keystore.filename&gt; with debug.keystore:    keytool -list -v -alias &lt;alias&gt; -keystore &lt;keystore.filename&gt;        The password is android.    This alias and password correspond with the debug keystore file Android Studio automatically produces.    The Certificate fingerprint appears and looks something like this:    Alias name: androiddebugkeyCreation date: Jun 13, 2016Entry type: PrivateKeyEntryCertificate chain length: 1Certificate[1]:Owner: C=US, O=Android, CN=Android DebugIssuer: C=US, O=Android, CN=Android DebugSerial number: 1Valid from: Mon Jun 13 22:56:54 PDT 2016 until: Wed Jun 06 22:56:54 PDT 2046Certificate fingerprints:     MD5:  20:91:A5:45:ED:F7:D5:9A:03:65:33:66:AD:02:27:E8     SHA1: B7:73:5F:AF:28:68:40:AB:31:59:03:A2:46:AB:D6:44:85:2A:C1:0E     SHA256: 05:E3:7C:82:42:04:4A:0A:DC:98:6A:1C:B3:21:64:9F:AC:CD:3E:CD:B1:57:3F:EA:C0:35:0E:32:8D:39:D5:A6     Signature algorithm name: SHA1withRSA     Version: 1        Copy the value for MD5.  Enter this value in the Signature field as required in the Get the Login with Amazon API Key section.",
        "url": "fire-app-builder-login-with-amazon-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-amazon-media-player-component-html": {
        "title": "Amazon Media Player Component",
        "tags": "[]",
        "content": "The Amazon Media Player is based on the open source ExoPlayer, which was developed by Google for Android. The Amazon Media Player builds on ExoPlayer to provide a robust and stable media player that is compatible on Fire TV devices.The functionality in Amazon Media Player closely mirrors that in ExoPlayer. For example, Amazon Media Player supports SmoothStreaming, DASH, HLS, Dolby, captions, and more. For details about what Amazon Media Player supports, look at the documentation for ExoPlayer. The minimum Android SDK required is API level 19 (KitKat).The aim with Amazon Media Player is to develop higher level player APIs that abstract away the complex ExoPlayer APIs for core playback scenarios. Amazon Media Player provides you with a mostly fixed set of APIs that you can use even when ExoPlayer changes its APIs with version upgrades.Configure Amazon Media Player ComponentThere aren’t any options to customize the Amazon Media Player Component. You simply load the component following the general instructions here: Load a Component in Your App.If you have another media player component already loaded, you must remove it. See Remove a Component for details. Note: You can load only one component per interface. For example, you cannot load both the Amazon Media Player component and another media player component, because both components use the same UAMP interface. For a list of the components by interface, see Components Overview.",
        "url": "fire-app-builder-amazon-media-player-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-brightcove-media-player-component-html": {
        "title": "Brightcove Media Player Component",
        "tags": "[]",
        "content": "By default the Amazon Media Player is configured in Fire App Builder. However, if you have a specific need to use the BrightCove MediaPlayer, you can also choose to use this media player instead. There aren’t any feature differences between the two. If your media or app infrastructure is somehow coupled closely with BrightCove, you can simply choose to load it instead of Amazon Media Player.When the user clicks the Watch Now button on the Content Renderer screen, the BrightCove Media Player plays the content:Configure the BrightCove Media PlayerThere aren’t any options to customize the BrightCove Media Player Component. You simply load the component following the general instructions here: Load a Component in Your AppYou most likely already have the Amazon Media Player Component (AMZNMediaPlayerComponen) loaded in your app. You must remove this component from your app to load the BrightCove Media Player. See Remove a Component for details. Note: You can load only one component per interface. For example, you cannot load both the Amazon Media Player component and another media player component, because both components use the same UAMP interface. For a list of the components by interface, see Components Overview.",
        "url": "fire-app-builder-brightcove-media-player-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-amazon-in-app-purchase-component-html": {
        "title": "Amazon In-App Purchasing Component",
        "tags": "[]",
        "content": "The Amazon In-App Purchasing Component uses Amazon’s In-App Purchasing (IAP) API to integrate two different purchasing options in your app:  Daily Pass: Allows uses to watch any media in your app for a day (starting from the time of purchase for 24 hours). This is similar to an unlimited movie rental for 24 hours.  Go Premium: Allows users to pay a subscription fee to watch any media in your app during the subscription time period. You define the subscription time period when you set up the in-app items in the Amazon Developer Console.With the In-App Purchasing Component, you don’t have to worry about handling transactions with users. Users make purchases through their Amazon account, which they set up when they configure their Fire TV. The In-App Purchasing API takes care of all of the transaction details within your app. Note: You can customize the button text that says “Daily Pass” or “Go Premium.” More details about how to customize the UI strings are provided in “Customize the Button Text.”  The User Experience with Amazon In-App Purchasing Component  Notes and Limitations with In-App Purchasing  Amazon In-App Purchasing Component Workflow  Configuration Overview          Daily Pass (Consumables) and Go Premium (Subscriptions)      Amazon In-App Purchasing Component Configuration        Step 1. Create an App in the Developer Portal  Step 2. Create a Consumable (Daily Pass) In-App Item  Step 3. Create a Subscription (Go Premium) In-App Item  Step 4. Download and Push the JSON Data File  Step 5. Enable the In-App Purchasing Component in your App  Step 6. Map In-App Items to Content in Your App  Step 7. Customize the Button Text  Step 8. Set Up the App Tester          Simulate Calls      Adjust In-App Items      Reset Purchases        Implementing Additional Security Through the Receipt Verification Service  Submitting In-App Items to ProductionThe User Experience with Amazon In-App Purchasing ComponentAfter you implement the Amazon In-App Purchase Component in your app, users see a “Daily Pass” and “Go Premium” button on the Content Details screen (instead of a Watch Now button).Figure 1. Options to either subscribe or purchase a daily pass appear to the user on the Content Details screen.When a user clicks the “Go Premium” or “Daily Pass” button, the user is prompted to make a purchase using his or her Fire TV account. For example, if the user clicks “Go Premium,” the following screen appears:Figure 2. Subscription options dialog box that appears to users.If a user clicks “Daily Pass,” the following screen appears:Figure 3. Rental options dialog box that appears to users. Note: When you configure the in-app purchasing items, you can customize the text that displays in these dialog boxes.The user completes the transaction through this Fire TV dialog box using his or her Amazon account, which the user entered when setting up Fire TV. When the transaction is finished, the user sees this screen:Figure 4. The order is completed.The user can now start watching the content.Notes and Limitations with In-App PurchasingNote the following details with the Amazon In-App Purchase component:  You must offer both Daily Pass (24-hour access) and Go Premium (subscription) options for your media.  When users purchase Daily Pass or Go Premium, they get access to all the media in your app. You can’t individually separate out some items for subscription or rental while keeping other items free.  If users are in the middle of a movie when their Daily Pass or Subscription expires, the users will be able to finish their movie. The In-App Purchasing component won’t stop their movie.  You cannot offer multiple subscription types for the same media. For example, you can’t offer both an SD or HD option to watch content, nor can you offer monthly or yearly subscriptions.  Daily Pass can be used only on the device in which the purchase was made. A user cannot log into another Fire TV device and expect the Daily Pass to work.  Go Premium subscriptions work across devices (meaning a user can buy a subscription in one Fire TV device and get the same benefits on another Fire TV device). However, users who log into another device will need to restart the app before the subscription takes effect.  If a user purchases a Daily Pass, but then the Fire TV app crashes and the data is lost, the user will no longer have access to Daily Pass on the app. However, with Go Premium (subscriptions), app crashes will not void the user’s access after he or she restarts the app.  If a user subscribes to content and then clicks the Back button, he or she will see the Go Premium button again. But if the user tries to subscribe a second time, the app will recognize that the user is already a subscriber and will provide access to the media.Amazon In-App Purchasing Component WorkflowThe following steps describe the payment workflow for the Amazon In-App Purchasing Component:  When the app starts, the app uses the In-App Purchasing API to fetch the existing purchases for the current logged-in user and updates the products with the latest receipts.  On a Content Details screen, the user clicks either a Daily Pass or Go Premium button (assuming the user hasn’t yet purchased the media).  The app makes a call to the In-App Purchasing API to perform the transaction with the user for the items. The user completes the purchase through the Fire TV account options the user has already set up.  If the transaction is successful, the In-App Purchasing API returns a receipt ID from the transaction to the app.  (Optional) To ensure the receipt is valid, you can set up your own service to send a request to the Receipt Verification service and check if the receipt ID is valid.  If the receipt ID is valid, the app lets the user view the media.Configuration OverviewTo set up the In-App Purchasing Component, you create a Daily Pass item (consumable) and Go Premium item (subscription) in the In-App Items section of the Developer Portal. You configure your app with the SKU information for these items. The component sends the necessary information to the In-App Purchasing API.The Amazon In-App Purchasing Component uses a wrapper over the IAP API. Only a limited feature set from IAP is available; as such, the documentation here is a modified subset of the IAP documentation.Daily Pass (Consumables) and Go Premium (Subscriptions)In-App Purchasing offers 3 types of items: consumables, entitlements, and subscriptions. Only consumables and subscriptions are relevant to the In-App Purchasing Component in Fire App Builder (this component is a wrapper on top of the IAP API, so not all of the IAP API features apply). Both consumable and subscription items (not entitlements) map to the Amazon In-App Purchase Component.Here’s the difference between consumables and subscriptions:  Consumables (mapped to Daily Pass) are consumed within the app and can be purchased multiple times. Consumables are mapped to “Daily Pass” in Fire App Builder. Choose this type of item if you want users to have access to all your media for a 24-hour access period.  Subscriptions (mapped to Go Premium) offer access to a premium set of content or features for a limited period of time. Subscriptions are mapped to “Go Premium” in Fire App Builder. Choose this type of item if you want users to have access to all your media throughout the subscription period.Amazon In-App Purchasing Component ConfigurationTo configure the In-App Purchase Component, follow these steps:  Step 1. Create an App in the Developer Portal  Step 2. Create a Consumable (Daily Pass) In-App Item  Step 3. Create a Subscription (Go Premium) In-App Item  Step 4. Download and Push the JSON Data File  Step 5. Enable the In-App Purchasing Component in your App  Step 6. Map In-App Items to Content in Your App  Step 7. Customize the Button Text  Step 8. Set Up the App TesterStep 1. Create an App in the Developer PortalIf you have already created an app, you can skip this section jump to the next.  Log in to the Developer Portal.  Click Add a New App and select Android in the “Choose a Platform” dialog box. Then click Next.      Complete the basic fields for your app:          App title: The name of your app.      App SKU: A unique identifier for your app (for example, mycalypsomediapp1234). The SKU has a max length of 150 characters and can contain the characters a-z, A-Z, 0-9, underscores, periods, and dashes. SKUs are case-sensitive.      Category: Choose a category appropriate for your app and media.        For Customer Support Contact, select Use my default support information or customize the fields. Then click Save.Step 2. Create a Consumable (Daily Pass) In-App Item  Log in to the Developer Portal, go to the Dashboard, and click your app.  Click the In-App Items tab in your app.      Click the Add a Consumable button (for Daily Pass).    Figure 5. Rental options dialog box that appears to users.        Enter values for the fields defined in the following table:                Field      Description                  Title      A name to refer to this item. This title doesn’t appear to users. Type Daily Pass for convenience.              SKU      A unique-to-your-app string that becomes the ID for the item. For example, “com.amazon.example.iap.mydailypassitem”. The SKUs used by your app must match the SKUs that you submit to the Amazon Appstore. The same SKU character requirements as before (when you created an app) apply here too.              Content delivery      Choose No additional file required since the content to be delivered is included as part of the app.              Click Save.     Note: You must save the information that you have entered on one tab before moving to the next tab.        Click the Availability &amp; Pricing tab and complete the details as described in the following table.                Field      Description                  Are you charging for this consumable / entitlement?      Select Yes, my base price is… A field displays allowing you to set the base price and currency for the item. After you set the base price, you can manually set the price for other currencies, or allow the Amazon Appstore to set those prices for you, based on conversion rates and taxes. Valid prices (in USD) can either be $0.00 or range from $0.99 to $99.00.              When would you like this item to be available?      Specify a date (IAP uses the PST time zone) for the item to become available in your app. If you leave this field blank, the item will become available as soon as it is approved by the Amazon Appstore.          Click Save.  Click the Description tab.      Complete the Display Title and Description fields.    These fields appear in the dialog box after users click Daily Pass:    Figure 6. Title and Description fields that appear to users.    Click Save.  Click the Images tab.  Upload the two images as indicated based on the size requirements. Only the 114px image appears in the Daily Pass dialog box users see in the app. In the previous screenshot (Figure 6), the image is simply an orange square. For convenience in creating the 512px image, you can upload this generic image.      Click Save.     Warning: Do not click Submit In-App Item button yet. After you submit the in-app item, you cannot edit or remove it. Only click this button after you have fully tested the functionality and content and are ready to submit your app.  Step 3. Create a Subscription (Go Premium) In-App Item  If necessary, log in to the Developer Portal, go to the Dashboard, and click your app.  Click the In-App Items tab in your app.  Click the Add a Subscription button (for Go Premium). (In the “Subscriptions are not supported by Amazon Underground” prompt, click the Add a Subscription button again.)      Enter values for the fields defined in the following table:                Field      Description                  Title      A name to refer to this item. This title doesn’t appear to users. Type Go Premium for convenience.              SKU      A unique-to-your-app string that becomes the ID for the item. For example, “com.amazon.example.iap.mygopremiumitem.” The SKUs used by your app must match the SKUs that you submit to the Amazon Appstore. The same SKU character requirements as before (when you created an app) apply here too.              Content delivery      Choose No additional file required since the content to be delivered is included as part of the app.              Click Save.     Note: You must save the information that you have entered on one tab before moving to the next tab.        Click the Subscription Periods tab and complete the fields as defined in the following table.                Field      Description                  Subscription Period      Select the subscription duration you want. Subscription periods start on the date of purchase.              SKU      Enter a unique SKU (using the same guidelines as the other SKU fields) that corresponds to this subscription period. For example, “com.amazon.example.calypso.monthly”. This SKU is a child SKU of the SKU that you entered on the item detail page.              Free Trial      If desired, specify an optional free trial period for the subscription.              Are you charging for this subscription?      Select Yes, my base price is…. A field displays allowing you to set the base price and currency for the item. After you set the base price, you can manually set the price for other currencies, or allow the Amazon Appstore to set those prices for you, based on conversion rates and taxes. Valid prices (in USD) can either be $0.00 or range from $0.99 to $99.00.              When would you like this item to be available?      Specify a date (IAP uses the PST time zone) for the item to become available in your app. If you leave this field blank, the item will become available as soon as it is approved by the Amazon Appstore.           Note: Ignore the “Save and Add a Subscription Period” button. The Purchasing Component supports only one subscription period.    Click Save.  Click the Description tab.      Complete the Display Title and Description fields.    These fields appear in the dialog box after users click Go Premium:    Figure 7. Title and Description fields that appear to users.    Click Save.  Click the Images tab.  The image icons are required by the Developer Console, but unlike with Daily Pass (consumables), neither image is used in the Go Premium dialog box users see in the app. For convenience, you can upload this generic 114px image and this generic 512px image image.      Click Save.     Warning: Do not click Submit In-App Item button yet. After you submit the in-app item, you cannot edit or remove it. Only click this button after you have fully tested the functionality and content and are ready to submit your app.  Step 4. Download and Push the JSON Data FileAfter you have configured both the Daily Pass and Go Premium in-app items, you will download a JSON file containing details about your in-app items.  If necessary, log in to the Developer Portal, go to the Dashboard, and click your app.  Click the In-App Items tab in your app.      Click the JSON Data File button to download the JSON file containing your in-app item details.        In your terminal, cd to the directory containing this file.      Push the JSON file to your Fire TV device using the following command:    $ adb push amazon.sdktester.json /mnt/sdcard/        The response will show the following: [100%] /mnt/sdcard/amazon.sdktester.json  Step 5. Enable the In-App Purchasing Component in your AppNow that you’ve created your in-app items in the Developer Console, you need to enable the IAP component in your app.  Load the Amazon In-App Purchasing component into your app. See the Load a Component for details about how to load a component into your app.  In Android Studio (in the Android view), expand the ContentBrowser folder and go to res &gt; values and open the custom.xml file.      Copy the following string:    &lt;bool name=\"is_iap_disabled\"&gt;true&lt;/bool&gt;        (Ignore the override_all_contents_subscription_flag field.)    In your app folder, open the custom.xml file (located in res &gt; values).      Paste the string you copied earlier and change the value to false. Make sure to paste this string inside the resources tags:    &lt;bool name=\"is_iap_disabled\"&gt;false&lt;/bool&gt;         Tip: Note that this is a double negative, so in this case false is actually enabling IAP in your app.    The values in your app’s custom.xml will overwrite any values in the components.  Step 6. Map In-App Items to Content in Your App      In Android Studio (in the Android view), expand the PurchaseInterface folder and go to assets. Then open the skuslist.json file.        For “Go Premium” items, replace the fields in red with your Go Premium item’s SKU value:    {  \"skusList\": [    {      \"sku\": \"testSubSku\",      \"productType\": \"SUBSCRIBE\",      \"purchaseSku\": \"testSubSku\"    },    {      \"sku\": \"RentUnPurchased\",      \"productType\": \"RENT\",      \"purchaseSku\": \"RentUnPurchased\"    }  ],  \"actions\": {    \"CONTENT_ACTION_DAILY_PASS\": \"RentUnPurchased\",    \"CONTENT_ACTION_SUBSCRIPTION\": \"testSubSku\"  }}    Go Premium items are subscriptions.        For “Daily Pass” items, replace the fields in red with your Daily Pass item’s SKU value:    {  \"skusList\": [    {      \"sku\": \"testSubSku\",      \"productType\": \"SUBSCRIBE\",      \"purchaseSku\": \"testSubSku\"    },    {      \"sku\": \"RentUnPurchased\",      \"productType\": \"RENT\",      \"purchaseSku\": \"RentUnPurchased\"    }  ],  \"actions\": {    \"CONTENT_ACTION_DAILY_PASS\": \"RentUnPurchased\",    \"CONTENT_ACTION_SUBSCRIPTION\": \"testSubSku\"  }}    Daily Pass items are rentals.  Step 7. Customize the Button TextYou can customize the “Daily Pass” or the “Go Premium” text that appears on the buttons on the Content Details screen.To customize the text:  Go to ContentBrowser &gt; res &gt; values and open the strings.xml file.      Copy the following strings and paste them into your app’s custom.xml file:    &lt;string name=\"premium_1\"&gt;Go&lt;/string&gt;&lt;string name=\"premium_2\"&gt;Premium&lt;/string&gt;&lt;string name=\"daily_pass_1\"&gt;Daily&lt;/string&gt;&lt;string name=\"daily_pass_2\"&gt;Pass&lt;/string&gt;        You can also copy other strings related to the Purchasing Component here as well:    &lt;string name=\"iap_error_dialog_title\"&gt;Purchase Error&lt;/string&gt;&lt;string name=\"subscription_expired\"&gt;Your subscription expired!&lt;/string&gt;&lt;string name=\"ok\"&gt;Ok&lt;/string&gt;        Customize the string values as desired.Step 8. Set Up the App TesterNow that you’ve set up your in-app items and configured your app, it’s time to test out the integration and see how IAP interacts with your media.To test the in-app items in your app — without actually making purchases and before submitting your app to the Appstore — you need to use the IAP App Tester. The App Tester simulates calls to the In-App Purchasing API using a sandbox server. The App Tester intercepts the outgoing call to the In-App Purchasing API and returns a valid receipt, authorizing the transaction. (For more details, see Installing and Configuring the App Tester.)To set up the App Tester:      Using your computer’s browser, go to the App Tester from the AppStore, get the app (it’s free), and deliver it to your device.    To deliver this app to your device, you must be signed in to Amazon with the same credentials as you used in setting up your Fire TV. Use the “Deliver to” options to deliver the app to your device:    Figure 9. The Delivery options allows you to send the app to your Fire TV device.    On your Fire TV, sync your purchases with your device by going to Settings &gt; My Account &gt; Sync Amazon Content.  From the Fire TV home screen, go to Apps and select Your Apps Library.  Select the Amazon App Tester app and download and install the app from the cloud.  Launch the app after the download completes.      Click the In-App Purchasing API section.    Figure 10. In-App Purchasing API option.    Select 5. IAP Items in JSON File and verify that items from your amazon.sdktester.json file appear here.Simulate CallsWith your app and the testing tool configured, you can now simulate calls to the IAP service.  Using ADB, start your app.  Browse to media in your app.  Click the Daily Pass or Subscribe button.Adjust In-App ItemsYou may want to adjust the Title and Description fields on the Description tab based on how the text appears in your app.You can adjust the text or other features in your in-app items by logging into the Developer Console, clicking your app, and going to the In-App Items tab. As long as you haven’t submitted your app, all the fields remain editable.Reset PurchasesAs you’re testing the functionality, you can reset any Daily Pass or Go Premium purchases by doing the following:  Go to Settings &gt; Applications &gt; Manage Installed Applications &gt; Amazon App Tester.  Select Clear data and Clear cache.Implementing Additional Security Through the Receipt Verification ServiceWhen users purchase a Daily Pass or Subscription to your media, the IAP API returns a receipt to your app indicating whether the transaction was valid. Since your users own the Fire TV device, it’s possible for hackers to re-route the outgoing call to the IAP API and spoof the receipt.To verify that the receipt returned from the IAP API is valid, you can set up your own service to call Amazon’s Receipt Verification Service.Here’s the general process for verifying receipts with the Receipt Verification Service using Fire App Builder:  You set up your own server (using any language/platform) to send the receipt and an accompanying secret to the Receipt Verification Service, asking whether the receipt is valid.  Your app sends a request with the required properties and shared secret to the Receipt Verification Service to check the receipt. The required values can be found in AmazonInAppPurchaseComponent &gt; res &gt; values values.xml.  After verifying the secret, the Receipt Verification Service determines whether the receipt is valid and responds with a true or false answer.This workflow is not included in Fire App Builder. By default, Fire App Builder just makes a call to a dummy service that always returns valid. Specifically, in Fire App Builder, the AReceiptVerifier class (in the AmazonInAppPurchaseComponent folder) is an abstract class that you extend with your own subclass to call the Receipt Verification Service.DefaultReceiptVerificationService is a sample subclass in Fire App Builder that extends AReceiptVerifier. The validateReceipt method inside DefaultReceiptVerificationService implements all the required parameters needed by the Receipt Verification Service:  context:   The application context  requestId: The request id for this request  sku:       SKU for the receipt  userData:  User data of the current user  receipt:   The receipt to validate  listener:  The listener of this request  return: The request idHowever, validateReceipt doesn’t actually call the Receipt Verification Service. Instead, this method just returns a status of successful.You must create your own subclass to extend AReceiptVerifier with an actual call to the Receipt Verification Service. (Alternatively, you can customize the DefaultReceiptVerificationService subclass.)When you create the subclass, you must provide your subclass name in your app’s custom.xml file by doing the following:  Go to AmazonInAppPurchaseComponent &gt; res &gt; values and open the strings.xml file.      Copy the following receipt_verification_service_iap string, and paste it into your app’s custom.xml file (inside app &gt; resources):    &lt;string name=\"receipt_verification_service_iap\"&gt;com.amazon.inapppurchase.DefaultReceiptVerificationService&lt;/string&gt;        In your app’s custom.xml file, update the string’s value with the complete path to your subclass. By default, the DefaultReceiptVerificationService is configured. You can either create a new subclass or simply overwrite the DefaultReceiptVerificationService class.For more details on calling the Receipt Verification Service, see Receipt Verification Service. Note: The level of security you implement depends on the resources you want to expend verifying legitimate transactions. If it makes sense to manage your own server to verify receipts (because your revenue exceeds the cost of managing your own server), you should implement this additional security with the Receipt Verification Service. However, if revenue from your app doesn’t exceed the cost or hassle of managing your own server, you might want to omit this extra setup.Submitting In-App Items to ProductionSo far this documentation has explained how to configure your app in a test environment. When you’re ready to submit your app to the app store, you need to also submit the in-app items.To submit the in-app items:  Log in to the Developer Portal, go to the Dashboard, and click your app.  Click the In-App Items tab in your app.  Click the Submit In-App Item button.After you submit your in-app items, you can no longer edit them. If you need to change the in-app items that have already been submitted, you will need to either create a new version of your app or create a new app and add new in-app items to the app.",
        "url": "fire-app-builder-amazon-in-app-purchase-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-create-a-new-component-html": {
        "title": "Create a New Fire App Builder Component",
        "tags": "[]",
        "content": "In addition to using the existing components, you can create your own components that implement the interfaces. When you create your own components, you will need to write the Java code that implements the interface.To create your own component:      Identify the interface you want to implement. See the Components Overview for a list of the various components and the interfaces each component implements.    For example, if you’re implementing an analytics component, the Components Overview notes that each analytics component implements the IAnalytics interface. Ads components implement the IAds interface, and so on.        Open the interface folder and examine the contents of the interface (or press Shift+Shift and type the interface name to search directly for it).    Continuing with the same example, the IAnalytics.java file is located in AnalyticsInterface &gt; java &gt; com.amazon.analytics &gt; IAnalytics.        Create a new component that implements each of the fields and methods of the interface. The Javadoc for each interface is available as a ZIP file download.    If you look at the Interface IAnalytics Javadoc, you will see that the following fields are required:          major      minor        And the following methods are required:          collectLifeCycleData      configure      trackAction      trackCaughtError      trackState         Tip: For an example, look at how other components have implemented the interfaces.        In your component’s AndroidManifest.xml file, follow the pattern of other Analytics components. The manifest file should contain at least the following elements (customized to your component name):    &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"          package=\"com.amazon.analytics.yourcomponentname\"&gt;        &lt;application            android:allowBackup=\"true\"            android:label=\"@string/app_name\"            android:supportsRtl=\"true\"&gt;            &lt;receiver android:name=\"com.amazon.analytics.yourcomponentname.YourComponentNameModuleInitReceiver\"                  android:enabled=\"true\"                  android:exported=\"false\"&gt;            &lt;intent-filter&gt;                &lt;action android:name=\"android.amazon.module.init\"/&gt;            &lt;/intent-filter&gt;        &lt;/receiver&gt;    &lt;/application&gt;    &lt;/manifest&gt;            In your component’s build.gradle file, again follow the example of the existing components. Your component’s build.gradle file must include the dependencies for at least the following:    dependencies {    compile fileTree(include: ['*.jar'], dir: 'libs')        compile project(':ModuleInterface')    compile project(':AuthInterface')    compile project(':Utils')}            After you finish creating the component, you can load the component into your app. See Load a Component in Your App.  ",
        "url": "fire-app-builder-create-a-new-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-interfaces-and-components-html": {
        "title": "Components Overview",
        "tags": "[]",
        "content": "Fire App Builder includes a number components that implement interfaces. The interfaces define the methods and fields in Fire App Builder; the components implement the interfaces with fully developed code.To use the components, you don’t need to write your own Java code. You just need to customize various string values that have been extracted out of the code into XML files.The main interfaces include the following:  Ads Interface (IAds): Used for displaying ads to users  Analytics Interface (IAnalytics): Used for implementing analytics  Authentication Interface (IAuthentication): Used for authenticating or authorizing user access to media  Purchase Interface (IPurchase): Used for in-app purchasing  UAMP (UAMP): Used for playing mediaIf you need a component that isn’t available, you can create your own component that implements one of the interfaces.  Available Components and Interfaces  Authentication Components  Analytics Components  Ads Components  Purchasing Components  Media Player Components  UI ComponentsAvailable Components and InterfacesIn Android Studio, you won’t see all the components because the Fire App Builder sample app loads only a subset of the available components from the Fire App Builder library, as defined in your app’s Gradle files. Only one component from each interface is loaded.To view the available components on disk, you can browse (using Finder or File Explorer) to the folder on your computer where you downloaded the Fire App Builder project, or just refer to the information here.Authentication ComponentsAuthentication components allow you to identify and authorize users before they take an action in your app. You must have at least one authentication component loaded in your app. The authentication components implement the IAuthentication interface, which you can view in the AuthInterface folder. The following authentication components are available:            Component      Description                  AdobepassAuthComponent      Uses Adobe Pass to authenticate users.              FacebookAuthComponent      Uses Facebook to authenticate users.  By default, this is loaded in the Fire App Builder sample app (but not configured, hence the user receives no prompts).              LoginWithAmazon Component      Uses Login with Amazon to authenticate users.       Note:  If you don’t want to use any login components, leave the FacebookAuthComponent configured as a component with the generic values for this component in your app’s custom.xml file. Fire App Builder requires an Authentication component, and there isn’t a dummy authentication component (like PassThroughAds with the Ads components). Users won’t see anything related to Facebook with this approach.Analytics ComponentsAnalytics components track activities within your app and provide metrics for analysis. Analytics components implement the IAnalytics interface in the AnalyticsInterface folder. Loading an analytics component in your app is optional.            Component      Description                  FlurryAnalyticsComponent      Uses Flurry Analytics to provide analytics.  By default, this component is loaded but not configured in the Fire App Builder sample app.              OmnitureAnalyticsComponent      Uses Omniture to provide analytics.              CrashlyticsComponent      Uses Crashlytics to provide analytics.              LoggerAnalyticsComponent      The Logger Analytics Component is not intended to be used for actual analytics. Instead, this is a dummy analytics component that inserts log messages during events. If you’re not using any other analytics component, use Logger Analytics Component because at least one analytics component must be configured in your app. You can see the log messages triggered by the LoggerAnalytics component by searching for “loggeranalytics” in Logcat.      Ads ComponentsAds components refer to any components that show advertisements in your app. Ads components implement the IAds interface in the AnalyticsInterface folder. Loading an ads component in your app is required. The following ads components are available.            Component      Description                  FreeWheelAdsComponent      Used for displaying Freewheel ads in your app.              VastAdsComponent      Used for displaying VAST ads in your app.              PassThroughAdsComponent      Used only if you don’t want to use any other ads component. Your app must load at least one ads component loaded. This PassThroughAds component satisfies the ads component requirement without affecting the user experience in your app.      If you don’t want to use any of the authentication components listed in the preceding table, use the PassThroughAdsComponent. Your app must have at least one ads component loaded. This dummy component satisfies the ads component requirements without affecting the user experience in your app.Purchasing ComponentsPurchasing components allow users to make payments to either rent or subscribe to content in your app. The purchasing components implement the IPurchase interface in the PurchaseInterface folder. Loading a purchasing component is required. If you don’t want this component active, however, you canThe following purchasing components are available.            Component      Description                  AmazonInAppPurchasingComponent      Uses Amazon In-App Purchasing to allow users to choose Daily Pass (24-hour access) or Go Premium (subscription) to view the media in your app. This component is loaded by default but set as disabled and not configured.      Media Player ComponentsMedia Player components control the media player that is used for media playback in your app. The media components implement the UAMP interface in the UAMP folder. (UAMP stands for Universal Android Media Player.) Loading a media component is required. The following media player components are available.            Component      Description                  AMZNMediaPlayerComponent      Uses the Amazon Media Player, which is based on ExoPlayer. This component is loaded by default in Fire App Builder.      UI ComponentsThe TVUIComponent isn’t an optional component, as it contains much of the user interface and functionality for the app (other than the media player features). It’s created as a component to allow for potentially adding additional UI components for other devices, such as tablets.",
        "url": "fire-app-builder-interfaces-and-components.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-load-a-component-html": {
        "title": "Load a Component in Your App",
        "tags": "[]",
        "content": "For an overview of the available components, see Components Overview. Although documentation for each component is specific, you load all components in the same way.  Remove a Component  Load a Component in Your App          1. Define the Component      2. Compile the Component in Your Project      3. Configure the Component’s Values      Remove a ComponentWith the exception of analytics components, you can load only one component per interface. For example, you cannot load both the VAST Ads component and the Freewheel Ads component, because both components use the same IAds interface.However, all components require you to have a component loaded in your app for that interface. Because of this requirement, some components are dummy components that simply fulfill the requirements of having a component. The following are dummy components:  LoggerAnalyticsComponent  PassThroughAdsComponentThese dummy components don’t do anything. For a list of the component interface groups, see Available Components and Interfaces in Components Overview.Before you load a component in your app, check to make sure you have only one component for that interface. If another component is already loaded (as is probably the case, even if it’s just a dummy component) you must remove it.To remove a component from your app, follow the same steps as listed in the next section, “Load a Component in Your App,” but do the opposite in each step. For example, instead of adding a reference to something like FacebookAuthComponent, you would remove the reference.Load a Component in Your AppTo load a component in your app:  1. Define the Component  2. Compile the Component in Your Project  3. Configure the Component’s Values1. Define the Component Note: These instructions assume you’re in the Android view.First you need to first define the implemented components in the “settings.gradle (Project Settings)” file:  In Android Studio, expand Gradle Scripts.  Open the settings.gradle (Project Settings) file. (This file appears near the bottom of the list.)      Define the implementations that you want to include in your app. In settings.gradle (Project Settings), there are two places to define the components. Each area is identified through the /* Implementations */ comments, which are set off in red here:    include ':app',    /* Frameworks */    ':TVUIComponent',    ':UAMP',    /* Libraries */    ':ContentModel',    ':ContentBrowser',    ':DynamicParser',    ':DataLoader',    ':Utils',    /* Interfaces */    ':PurchaseInterface',    ':AuthInterface',    ':AdsInterface',    ':AnalyticsInterface',    ':ModuleInterface',    /* Implementations */    ':PassThroughAdsComponent',    ':AMZNMediaPlayerComponent',    ':FlurryAnalyticsComponent',    ':LoginWithAmazonComponent',    ':AmazonInAppPurchaseComponent'/* Frameworks */project(':TVUIComponent').projectDir = new File(rootProject.projectDir, '../TVUIComponent/lib')project(':UAMP').projectDir = new File(rootProject.projectDir, '../UAMP')/* Libraries */project(':ContentModel').projectDir = new File(rootProject.projectDir, '../ContentModel')project(':ContentBrowser').projectDir = new File(rootProject.projectDir, '../ContentBrowser')project(':DynamicParser').projectDir = new File(rootProject.projectDir, '../DynamicParser')project(':DataLoader').projectDir = new File(rootProject.projectDir, '../DataLoader')project(':Utils').projectDir = new File(rootProject.projectDir, '../Utils')/* Interfaces */project(':ModuleInterface').projectDir = new File(rootProject.projectDir, '../ModuleInterface')project(':AdsInterface').projectDir = new File(rootProject.projectDir, '../AdsInterface')project(':AuthInterface').projectDir = new File(rootProject.projectDir, '../AuthInterface')project(':AnalyticsInterface').projectDir = new File(rootProject.projectDir, '../AnalyticsInterface')project(':PurchaseInterface').projectDir = new File(rootProject.projectDir, '../PurchaseInterface')/* Implementations */project(':AMZNMediaPlayerComponent').projectDir = new File(rootProject.projectDir, '../AMZNMediaPlayerComponent')project(':PassThroughAdsComponent').projectDir = new File(rootProject.projectDir, '../PassThroughAdsComponent')project(':FlurryAnalyticsComponent').projectDir = new File(rootProject.projectDir, '../FlurryAnalyticsComponent')project(':FacebookAuthComponent').projectDir = new File(rootProject.projectDir, '../FacebookAuthComponent')project(':AmazonInAppPurchaseComponent').projectDir = new File(rootProject.projectDir, '../AmazonInAppPurchaseComponent')    Look in the source directory of the Fire App Builder project to get the exact directory names for each of the components, or just consult the tables that list each component name above.    In the the sample app in Fire App Builder, the following components are implemented by default:          AMZNMediaPlayerComponent      PassThroughAdsComponent      FlurryAnalyticsComponent      FacebookAuthComponent      AmazonInAppPurchaseComponent            Adjust the implementations by adding or removing the components you want to use in your app. Be sure to make the updates in both places that /*Implementations*/ is mentioned.    For the component names, you can either browse to the directory where you downloaded the project (using your File Explorer or Finder) to see the component folders. Or you can use the names as listed in the tables above.        You can implement only one component per interface, so remove any previous components for the same interface.    For example, if you added the LoginWithAmazonComponent, which implements the IAuthentication interface, you must remove any other authentication components (such as AdobepassAuthComponent or FacebookAuthComponent).  2. Compile the Component in Your ProjectAfter defining the component in the settings.gradle file, you must load the component through the “build.gradle (Module: app)” file.  In Android Studio, expand Gradle Scripts.  Open the build.gradle (Module: app) file.      In the dependencies object, include the components you want to include in your app.    By default, Fire App Builder shows these components:    compile project(':TVUIComponent')compile project(':UAMP')compile project(':AMZNMediaPlayerComponent')compile project(':PassThroughAdsComponent')compile project(':FlurryAnalyticsComponent')compile project(':FacebookAuthComponent')compile project(':AmazonInAppPurchaseComponent')        Add or remove the components you want to implement following the same pattern shown here.        You can implement only one component per interface, so remove any previous components for the same interface .    For example, if you added the LoginWithAmazonComponent, which implements the IAuthentication interface, you must remove any other authentication components (such as AdobepassAuthComponent or FacebookAuthComponent).        Resync your project with Gradle by clicking the Resync Project with Gradle Files button .    When the project rebuilds, you will see the new components reflected in the Project pane.    Go to Build &gt; Rebuild Project to get remove the old build artifacts from previous components.3. Configure the Component’s ValuesEach component has a list of customizable strings that have been extracted out into an XML file. Because of this, to customize a component with your app, you merely need supply the right values for the strings. You don’t need to modify the Java classes.However, different components may require a little more setup than others, especially because they usually involve implementing and setting up a third-party service. Because of this, see the documentation for each component for the specifics of how to configure the component:  AdobepassAuthComponent  FacebookAuthComponent  FlurryAnalyticsComponent  OmnitureAnalyticsComponent  CrashlyticsComponent  FreeWheelAdsComponent  VastAdsComponent  AmazonInAppPurchasingComponent  AMZNMediaPlayerComponentThe strings that have been extracted for each component are the most common parameters only. If you need an additional feature within the component that hasn’t been extracted out into a string, you will need to customize it in the component’s class that implements the interface.The XML files for each component are usually located in the component’s res &gt; values folder.The most common values that you would need to customize for each component are extracted out into XML files. Note: Instead of customizing the values directly in the component’s files, copy the strings into your app’s custom.xml file instead. Any settings in your app’s custom.xml file will overwrite the XML file values in the components. This will allow you to incorporate updates to the component when new releases are available.",
        "url": "fire-app-builder-load-a-component.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-end-to-end-process-html": {
        "title": "Beginning-to-End Process for Building an App",
        "tags": "[]",
        "content": "The following steps show the beginning-to-end process for building an app with Fire App Builder. Assuming you already have the requirements, you can build your app by completing the topics in each of the following sections:            1. Get Set Up                         a. Download Fire App Builder and Build the Sample App      Download the Fire App Builder code and build the “Application” in Fire App Builder. Then clone Fire App Builder to create your own app.              b. Connect to Fire TV Through ADB      Connect your computer to your Fire TV device using ADB so you can test your app.              c. Take an App Tour      Get more familiar with the basic features and screens in the sample app in Fire App Builder.                  2. Configure Your Feed                         a. Load Your Media Feed      Load your media feed in the app. Your feed contains all of your media assets, including the titles, descriptions, thumbnails, and media objects.              b. Recipe Configuration Overview      Learn about what recipes are in Fire App Builder and requirements for configuration.              c. Set Up the Category Recipe      Configure how Fire App Builder reads the categories in your feed. Categories organize your content into different groups.              d. Set Up the Contents Recipe      Configure how Fire App Builder reads the content in your feed. Content refers to all the elements in your feed, such as the title, description, and video URLs.              e. Navigator Configuration Overview      Learn about the role of the Navigator file and what needs configuration.              f. Configure Navigator – Token-based Feeds      Associate the categories and contents recipes with the screens in your app’s UI. Follow these instructions if your feed requires a token to access it.              g. Configure Navigator – Open Feeds      Associate the categories and contents recipes with the screens in your app’s UI. Follow these instructions if your feed is openly accessible without a token.                  3. Customize Your App’s Appearance                         a. Customize the Look and Feel of Your App      Customize the appearance of your app through the custom.xml file. You can customize almost every element of the app, from the font to background colors, homepage layout, splash screen, and more.                  4. Add Components                         a. Components Overview      Set up authentication, in-app purchasing, analytics, ads, or the media player by loading already coded components that implement interfaces in Fire App Builder.      When you finish building your app and are ready to submit it to the Amazon Appstore, see Publishing Android Apps to the Amazon Appstore. As you prepare your app for publishing, you will need to take various screenshots and gather Fire TV image assets.",
        "url": "fire-app-builder-end-to-end-process.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-overview-html": {
        "title": "Fire App Builder: A Starter Kit for Java-based Amazon Fire TV and Android Apps",
        "tags": "[]",
        "content": "Fire App Builder provides a Java-based framework that you can use to easily and quickly build streaming media Android apps for Amazon Fire TV.Fire App Builder lets you build an engaging, high-quality media experience on Fire TV following best practices and techniques — without having to develop all the code yourself. Fire App Builder’s code is Java-based and uses Android Studio, Gradle, and other tools common to Android app development.Fire App Builder is released as an open source project on Github (github.com/amzn/fire-app-builder) under the Apache 2.0 license.  How You Work with Fire App Builder  Sample App from Fire App Builder  Who Fire App Builder Is For  Requirements to Work with Fire App Builder  Fire App Builder Features  Fire TV Terminology and Devices  Getting Started  Getting Updates to the Project  Getting Support  Noting Bugs or Feature RequestsHow You Work with Fire App BuilderWhen you create an app with Fire App Builder, you configure the settings for your data feed, screen layouts, and functionality through a series of JSON files. You also construct query syntax to get the categories and contents from your media feed.For authentication, ads, analytics, or in-app purchasing, you can use a variety of pluggable components that implement interfaces. To customize the look and feel of your app, including font, colors, logos, layouts, and other details, you simply update some values in XML or JSON files (rather than coding directly in Java).Overall, Fire App Builder allows you to quickly develop a high quality app without doing Java programming. If you want to extend Fire App Builder with more advanced functionality, you can use Fire App Builder as the underlying framework and build on top of it, since most of Fire App Builder’s components are modular.Sample App from Fire App BuilderFire App Builder contains a sample app (called “Application”) with a home screen that looks as follows:The home screen of the sample app built with Fire App Builder.The sample app in Fire App Builder contains a generic video feed from Lightcast that is used for testing purposes only.Who Fire App Builder Is ForFire App Builder is designed for companies with streaming media assets (similar to Netflix or Hulu) who want to make their content available online through Fire TV and other Android TV platforms. You would be a good fit if you have a video feed where your media assets (movies, shows, or other video content) are published.The media feed can be JSON or XML, but it must be its own feed rather than a Youtube or Vimeo channel. (If it’s XML, it can be a media RSS feed, such as what you submit to iTunes.) The feed can be in any structure — you’ll use query syntax to select the categories and contents from your feed.Additionally, Fire App Builder requires you to configure files using Android Studio, so it’s geared toward developer types who prefer to create their app using Java-based Android (instead of HTML5 web technologies). You can also build on top of the Fire App Builder framework to create more sophisticated apps. Essentially Fire App Builder is the Fire TV SDK for Android Java developers.If you’re more of a content creator instead of a coder, or you just want to build a Fire TV app for your Youtube videos, or if you’re not comfortable working in Android Studio with code (even though no programming skills are required), consider using the Web App Starter Kit for Fire TV instead.Requirements to Work with Fire App BuilderTo develop with Fire App Builder, you will need the following:  Android Studio. See Getting Started with Android Studio and Install Android Studio from the Android documentation for information about setting up the Android Studio development environment on your machine.  Java Development Kit (JDK) 8. You must have the Java SE Development Kit 8 or later on your computer.  Fire TV or Fire TV Stick. You will need to test your app on an actual Fire TV device — either the Fire TV or Fire TV Stick. (Although emulators are possible, they don’t always work and aren’t supported for Fire TV development.) The Fire TV has better performance, so if your media is resource intensive, you’ll want to be sure it plays well on the Fire TV Stick too. (Note that Fire TV does not come with an HDMI cable, so you will need to supply that cable to connect the Fire TV box to your TV.)  Television with HDMI port. You will need a television with an HDMI port that your Fire TV can connect to.  A-to-A USB cable. If you’re using Fire TV (not the stick) and connecting your computer to Fire TV through USB (instead of through a wireless network), you will need an A-to-A USB cable. Instead of using a cable, you can also connect to Fire TV devices through a network. (See Connecting to Fire TV Through ADB.)  Media feed with necessary elements. You will need a media feed (in either JSON or XML format) with video assets as well as the following feed elements: title, ID, description, URL, card image, background image. (The same image can be used for both the card and background.) Any video format supported by Exoplayer is compatible with Fire App Builder.Fire App Builder FeaturesFire App Builder provides the following features:  Five screens: Splash screen, Home (two layouts), Content Details, Content Renderer, and Search.  Search functionality and search results: Text search within your app. Also includes intent filters to integrate with the global Fire TV search if your media is integrated into the Fire TV catalog.  Exoplayer-based Amazon Media Player for streaming media: The media player includes closed captions, HTTP Live Streaming (HLS), bandwidth settings, and more.  Components for ads, analytics, authorization, and in-app purchasing: More than 10 components that you can easily plug into your app and configure through XML files. Some of these components include Amazon in-app purchases, Login with Amazon, Facebook Login, Omniture Analytics, Flurry Analytics, Adobe Pass Authentication, Freewheel ads, and VAST 2.0 ads.Fire TV Terminology and Devices“Fire TV” refers to the Fire TV box, while “Fire TV Stick” refers to the stick version.You can compare the specifications across devices at Fire TV Device Specifications. The Fire TV has more power and faster performance, but the two devices run the same Fire OS and are more or less identical from an end-user’s perspective. Each device has two generations — Generation 2 is the latest.Fire TV also optionally comes in a Gaming Edition. You can also buy a game controller on its own and use it with Fire TV stick. Fire TV Stick (Generation 2) includes the voice remote by default, whereas Fire TV Stick (Generation 1) optionally provided the voice remote.Getting StartedTo get started building an app with Fire App Builder, see Beginning-to-End Process for Building an App with Fire App Builder, which lists the steps needed to develop an app with Fire App Builder.As you follow the instructions in the documentation, note that it’s usually assumed that you’re working in the Android view in Android Studio. If you don’t see a certain folder or path, check the view you’re in.Also, you can find any file by clicking Shift twice and then typing the file name. When you load the file, the path to the file appears just below the row of buttons on the top navigation bar.Getting Updates to the ProjectYou can get updates to the application by watching the Fire App Builder Github repository and running a git pull command to get the latest updates. See Pull Updates from Github for more details.Getting SupportIf you have feedback or questions about Fire App Builder, you can get support through the Fire TV Amazon forums.Noting Bugs or Feature RequestsTo note bugs or make feature requests, you can do so through the Issues tab on the Fire App Builder Github repository. Or you can submit the info to the Fire TV Amazon forums.",
        "url": "fire-app-builder-overview.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-questions-and-answers-html": {
        "title": "Miscellaneous Questions",
        "tags": "[]",
        "content": "The following are common questions about Fire App Builder.  Do apps created with Fire App Builder work on smartphone devices and tablets too, or just TV?  Currently, apps built with Fire App Builder work only on Fire TV and other Android TV platforms. A future enhancement will allow apps built with Fire App Builder to work on other devices as well. This is why the toolkit’s name is “Fire App Builder” and not “Fire TV App Builder.”  What kind of TVs do users need to have to use Fire TV?  Users need a TV with an HDMI port.  How can I implement Google Ads?  You can implement Google ads through the VAST Component, which supports Google ads.  Does Fire App Builder support live feeds?  Yes, you can display any media from your feed. As long as your feed has valid media (live or pre-recorded), it can be played through your app built with Fire App Builder. See Configure Live Streams.  Do I need an actual Fire TV device to develop my app?  Using an actual device during development and testing is highly recommended, but you can also use an emulator with some limitations.  What’s the difference between Fire App Builder and Web Application Starter Kit (WASK)?  Fire App Builder uses Java with Android to create native Java apps, with Android Studio as your IDE. Fire App Builder is intended more for developers who want to build robust streaming media apps (without doing all the programming). WASK is a mobile web app toolkit (using HTML, CSS, JavaScript instead of Java), intended more towards content creators than developers.  Can I submit an app built with Fire App Builder to Google’s Play Store as well as Amazon’s Appstore?  Yes, since both app stores play Android apps, apps built with Fire App Builder work on both the Amazon Appstore and Google Play Store. However, services unique to Amazon or Google will only work in the respective platforms.  How do I use reflection rather than translation when Fire App Builder maps the objects in my feed to its content model?  Reflection is actually used by default, so if you want to select this approach, remove the translator parameter from the categories recipe and the contents recipe.    Additionally, when you configure the matchlist parameter with your recipes, you must map your feed element names to slightly different names. Instead of using @title, @subtitle, @id, @description, @url, @cardImageUrl, @backgroundImageUrl, and @tags, put an “m” before each word and then follow camelcase styling. Specifically, use the following: @mTitle, @mSubtitle, @mId, @description, @mUrl, @mCardImageUrl, @mBackgroundImageUrl, and @mTags.    How can I enable the CEA-608 captions that are available in my HLS live stream?  No, Fire App Builder does not support CEA-608. Fire App Builder passes the responsibility to render captions to AMZNMediaPlayer, which supports CEA-608 (see the relevant code lines here). However, Fire App Builder only does so for vtt and xml extensions. CEA captions have a m3u8 extension, so Fire App Builder ignores this extension and does not inform AMZNMediaPlayer to render the captions.",
        "url": "fire-app-builder-questions-and-answers.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-release-notes-html": {
        "title": "Release Notes",
        "tags": "[]",
        "content": "Version 1.0.0FeaturesThe first release of Fire App Builder was published to Github on October 1, 2016. The first release includes a fully functional Java-based Android TV app that can parse media feeds and play media.The app includes more than a dozen components that allow you to quickly add analytics, in-app purchasing, ads, and media player components in your app. You can also customize the look and feel of your app, including the font, images, colors, and layout, by setting values in XML and JSON files.Known Issues  Facebook Authentication Component. With the Facebook Authentication Component, if users choose “Log in Later” when prompted by the Facebook Authentication Component, they are never asked about logging in later. (Users should be re-prompted after a period of time.)  Recommended Content. Recommended content matches (which are based on tags in the feed) will match unlimited content if many items have the same tags. (The content matches should have an item limit.)  In-App Purchasing Component. With the In-App Purchasing Component, purchases made on other devices won’t be acknowledged in the app until a user either restarts the app or attempts to play the content. (The app should refresh purchased items when the state goes to the background.)  Splash screen. Loading the feed initially can take some time on splash screen. (The initial load time should be faster.)",
        "url": "fire-app-builder-release-notes.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-catalog-integration-html": {
        "title": "Integrate Your Media into the Fire TV Catalog",
        "tags": "[]",
        "content": "When users press the microphone button on a voice-enabled remote, regardless of where users are in Fire TV, this action initiates a global search using the Alexa cloud service (instead of the Leanback library in your app).  Media Requests Through Voice  a. Integrate Your App’s Media with Fire TV Catalog  b. Include a Content ID in Your Feed and Catalog Submission  Configure Your App to Listen for Broadcast Intents  Testing Catalog IntegrationMedia Requests Through VoiceMedia requests through voice (such as saying the TV show you want to watch) always return content from the Fire TV catalog. The search within the catalog takes place in the cloud, not in your app.You can learn more about how search is implemented on Fire TV here. To learn more about Alexa voice capabilities on Fire TV from an end-user’s perspective, see Alexa on Fire TV.If you want your app’s media to appear in these global search results, you must integrate your app’s media into the Fire TV catalog. The Fire TV catalog contains an index of all media content on Fire TV.The process of getting your app’s content into the catalog is called “catalog integration.” Catalog integration involves regularly pushing your content to the catalog service (the catalog service does not read from a feed). This is a task a developer will need to configure — Fire App Builder does not do catalog integration for you. You can learn more about Fire TV catalog integration here.)When a search is initiated, Fire TV sends your app a broadcast for an intent. An intent (short for “intention”) is a message for your app to perform a desired action. Your app must have an intent filter declared in its manifest file that listens for this intent and then acts on it. (You can learn about intent filters in Android’s documentation.) Fire App Builder does have the code that allows your app to listen for the broadcast intents – it just needs to be uncommented when you’re ready to start listening for the intents. (See Configure Your App to Listen for Broadcast Intents below.After you integrate your media into the Fire TV catalog and configure your app’s manifest with intent filtering, if users already have your app installed, your app’s content will appear directly in the search results. If a user doesn’t have your app, a “More Ways to Watch” option appears for users to get your app and view the content.a. Integrate Your App’s Media with Fire TV CatalogFor instructions getting your app’s media into the Fire TV Catalog, see Integrating Your Catalog with Fire TV.The Fire App Builder project has already completed the steps described in Integrating Your App with the Fire TV Home Screen Launcher. You just need to uncomment some code in manifest files as described in the following section.b. Include a Content ID in Your Feed and Catalog SubmissionYour catalog details must have a unique ID for each content item. This unique content ID must correspond with the content IDs in your media feed. If your media feed does not contain unique IDs for each media content item, you must add it.Additionally, your catalog details in the cloud and your media feed (as integrated into your app) must always be in sync.Configure Your App to Listen for Broadcast IntentsTo make your app listen for broadcast intents:  In your app’s folder in Android Studio, expand manifests, open AndroidManifest.xml.      Uncomment the “Launcher Integration intents” section:    &lt;!-- Launcher integration intents --&gt;&lt;!-- Uncomment the below intent filters to enable launcher integration --&gt;    &lt;intent-filter&gt;    &lt;action android:name=\"PLAY_CONTENT_FROM_LAUNCHER\"/&gt;    &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;/intent-filter&gt;&lt;intent-filter&gt;    &lt;action android:name=\"SIGN_IN_FROM_LAUNCHER\"/&gt;    &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;/intent-filter&gt;        Go to ContentBrowser &gt; manifests and open the AndroidManifest.xml file.      Uncomment the launcher integration section:    &lt;!-- Uncomment the below receiver to enable launcher integration --&gt;&lt;receiver android:name=\"com.amazon.android.contentbrowser.helper.LauncherIntegrationBroadcastReceiver\" &gt;    &lt;intent-filter&gt;        &lt;action android:name=\"com.amazon.device.REQUEST_CAPABILITIES\" &gt;        &lt;/action&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;      Testing Catalog IntegrationAfter you have integrated your app with Fire TV’s Home Screen Launcher, you will need to validate your launcher integration before submitting your app to the Amazon Appstore. More details about launcher integration testing are available in Integrating Your App with the Fire TV Home Screen Launcher. Specifically, see the section “Step 6: Test Your Launcher Integration.” To enable this testing for your unpublished app:  Go to ContentBrowser &gt; java &gt; com.amazon.android.contentbrowser &gt; helper and open LauncherIntegrationManager.java.      Replace the value for COM_AMAZON_TV_LAUNCHER with com.amazon.tv.integrationtestonly:    //Replace COM_AMAZON_TV_LAUNCHER value with \"com.amazon.tv.integrationtestonly\" when testing// with integration test app.private static final String COM_AMAZON_TV_LAUNCHER = \"com.amazon.tv.integrationtestonly\";      ",
        "url": "fire-app-builder-catalog-integration.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-live-stream-configuration-html": {
        "title": "Configure Live Streams",
        "tags": "[]",
        "content": "If users watch live content and then return to the content details page, two buttons appear: “Watch Now” and “Watch from Beginning”:However, with live content, you only want the “Watch Now” button even when users return to the content, because live content can’t be rewound to the beginning.  Removing the “Watch from Beginning” button for Live Content          Option 1: Remove the Button Through Navigator.json      Option 2: Remove the Button by Matching a Value in the Feed      Removing the “Watch from Beginning” button for Live ContentTo remove the “Watch from Beginning” button for live content, you have two options:  Option 1: Remove the Button Through Navigator.json: Use this approach if all the media within a specific recipe configuration is live content, and you don’t have any tags within your feed that identify the content as live.  Option 2: Remove the Button by Matching a Value in the Feed: Use this approach if only some of the content in your feed is live streamed, and your feed has tags that identify the content that is live.Option 1: Remove the Button Through Navigator.json  Open the Navigator.json file (in app &gt; assets).      Within the categories object that contains recipes for your live feed, add a recipeConfig object with a liveContent parameter set to true. Here’s an example that shows some context:        {      \"categories\": {        \"name\": \"Hardcoded Category Name\"      },      \"contents\": {        \"dataLoader\": \"recipes/LightCastDataLoaderRecipe1.json\",        \"dynamicParser\": \"recipes/LightCastAllContentsRecipe.json\"      },      \"recipeConfig\": {        \"liveContent\": true      }    }  ],  \"graph\": {    \"com.amazon.android.tv.tenfoot.ui.activities.SplashActivity\": {      \"verifyScreenAccess\": false,      \"verifyNetworkConnection\": true,      \"onAction\": \"CONTENT_SPLASH_SCREEN\"    },    \"com.amazon.android.tv.tenfoot.ui.activities.ContentBrowseActivity\": {  Now for this recipe (LightCastAllContentsRecipe in the above code sample), the “Watch from Beginning” button won’t be shown when users return to the media after previously watching it.Option 2: Remove the Button by Matching a Value in the FeedIf your media feed includes tags that identify media as live content, you can configure the matchList parameter to identify these tags when you configure your Contents recipe.For example, suppose an item in your feed looks like this, with the &lt;live&gt;true&lt;/live&gt; tag:&lt;item&gt;  &lt;id&gt;1&lt;/id&gt;  &lt;title&gt;Nullamtus&lt;/title&gt;  &lt;link&gt;http://www.developer.amazon.com/&lt;/link&gt;  &lt;pubdate&gt;Wed, 14 Jan 2015 00:36:00 +0000&lt;/pubdate&gt;  &lt;description&gt;Sed a sagittis urna, a fermentum ligula. In sagittis sagittis libero, ut tincidunt sapien egestas.&lt;/description&gt;  &lt;image&gt;https://raw.githubusercontent.com/amzn/web-app-starter-kit-for-fire-tv/master/src/common/assets/images/l1.jpg&lt;/image&gt;  &lt;category&gt;Lifestyle&lt;/category&gt;  &lt;url&gt;http://example.com./myvideos/sample.mp4&lt;/url&gt;  &lt;live&gt;true&lt;/live&gt;&lt;/item&gt;In your Content recipe, you can now target the live tag and match it to live:{  \"cooker\": \"DynamicParser\",  \"format\": \"xml\",  \"translator\":\"ContentTranslator\",  \"model\": \"com.amazon.android.model.content.Content\",  \"modelType\": \"array\",  \"query\": \"rss/channel/item\",  \"matchList\": [    \"title/#text@title\",    \"id/#text@id\",    \"description/#text@description\",    \"url/#text@url\",    \"image/#text@cardImageUrl\",    \"image/#text@backgroundImageUrl\",    \"live/#text@live\"  ]}Now for these content items, the “Watch from Beginning” button won’t be shown when users return to the media after previously watching it.For more details on using the matchList parameter, see Configure the Content Recipe.",
        "url": "fire-app-builder-live-stream-configuration.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-pulling-updates-from-github-html": {
        "title": "Pull Updates from Github",
        "tags": "[]",
        "content": "You can stay updated about the latest commits to Fire App Builder by watching and starring the project in Github. You can also periodically check the Release Notes page in the documentation. Note: If this is the first time you’re cloning and building the project, see Download Fire App Builder and Build an App instead of this topic. (This topic addresses how to apply updates to an existing project.)  Getting Updates  Resolving Merge Conflicts  Git ResourcesGetting UpdatesWhen new versions of Fire App Builder are released and pushed out to Github, you can get the new version’s updates and integrate the code into your project using the common git pull technique used with Github workflows.First change to your fire-app-builder directory (or whatever you’ve named it). Then pull the latest changes into your repository:cd fire-app-buildergit pullWhen you run a git pull command, git downloads the latest updates from the original repository and attempts to merge the updates into your code.Resolving Merge ConflictsIf changes in the original repository’s files conflict with changes you’ve made to your local copy, git will not automatically overwrite your local copies with the updates. Instead, git will show you merge conflicts for the affected files and remove the affected files from its tracking. You will then need to resolve the merge conflicts, add the files back into git tracking, and commit your update.After you run git pull, if you see merge conflicts, pen the files with merge conflicts. Carrots (»»») and («««) indicate areas where conflicts occur. Manually edit the files to remove the carrots. Then add the file back into git tracking with git add &lt;filename&gt;, where  is the name of the file you're adding back in.See Resolving a merge conflict from the command line for details on how to resolve merge conflicts.Git ResourcesHere are some good resources for learning git:  git’s documentation  git - the simple guide  git Tutorials from Atlassian",
        "url": "fire-app-builder-pulling-updates-from-github.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-querying-json-html": {
        "title": "Querying JSON",
        "tags": "[]",
        "content": "When you set up your recipes, you used Jayway JsonPath syntax for the query parameter. You can learn more about the JSON query syntax here: Jayway JsonPath.To get a better sense of how the query syntax words, you can use the Jayway JsonPath Evaluator. Specifically, see the Operators section to understand how the various syntax ($, @, *, .., .&lt;name&gt;, [?(&lt;expression&gt;)]) targets specific elements in your JSON.The following sections provide examples about how to construct Jayway JsonPath queries.  JSON Path Query Example 1  JSON Path Query Example 2  JSON Path Query Example 3  Example 4JSON Path Query Example 1In this example, we’ll step through some Jayway JsonPath queries in more detail.  Open the urlFile.json (in app &gt; assets).      Copy the first URL:    http://www.lightcast.com/api/firetv/channels.php?app_id=257&amp;app_key=0ojbgtfcsq12&amp;action=channels_videos        Paste this URL into a browser and press Return to see the contents.  Copy the contents and prettify the JSON using a tool such as jsonprettyprint.com.  Copy the prettified JSON and paste it into the Jayway JsonPath Evaluator.      In the Go! box, enter the query to get all categories:    $..categories[*]            Click Go!    The result shows all the categories from the feed.    [   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Underwater\",   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Attractions\",   \"Bahamas Islands\",   \"Bahamas Attractions\",   \"Bahamas Underwater\",   \"Bahamas Islands\",   \"Bahamas Attractions\",   \"Bahamas Islands\",   \"Bahamas Islands\",   \"Bahamas Attractions\",   \"Bahamas Weddings\",   \"Bahamas Weddings\",   \"Bahamas Attractions\",   \"Bahamas Underwater\",   \"Bahamas Islands\",   \"Bahamas Attractions\",   \"Bahamas Islands\",   \"Bahamas Weddings\",   \"Bahamas Islands\",   \"Bahamas Underwater\"]        With this particular feed, each media object lists its category, so the query shows numerous “Bahamas Islands” results (one for each media object containing this category).    Extracting all categories from a feed using Jayway JsonPath query syntax.    The syntax $..categories[*] means to start in the root directory ($) and look in all subdirectories (..) for the key categories. This key must contain an array ([]), but the array can containing anything (*).    If you were to switch the query to $..title[*], nothing would match because title isn’t a key containing an array in the feed. To retrieve all titles, you would use $..title.    The DynamicParser class in the Fire App Builder code will remove duplicates when putting these categories into a map.     Tip: See the Path Examples in the JsonPath documentation to get a better sense of the variety of queries you can use to target specific elements in your feed.  JSON Path Query Example 2Here’s another potential feed structure for media:{     \"total\":\"13\",   \"results\":[        {           \"id\":\"45454333\",         \"title\":\"'Sample video title1\",         \"link\":\"http:\\/\\/example.com\\/assets\\/some\\/media\\/path\\/myvideo1.mp4\",         \"pubDate\":\"Tue, 01 Oct 2016 18:29:52 +0530\",         \"media:thumbnail\":\"http:\\/\\/example.com\\/assets\\/some\\/someimage1.jpg\",         \"media:duration\":\"1913\",         \"description\":\"This is a sample description1\",         \"media:filepath\":\"http:\\/\\/example.com\\/videos\\/1234\\/myvideo1.mp4\",         \"media:fullimage\":\"http:\\/\\/example.com\\/videos\\/1234\\/thumbnail1.jpg\",         \"media:keywords\":\"some, sample, keywords,random\"      },      {           \"id\":\"44545333\",         \"title\":\"'Sample video title 2\",         \"link\":\"http:\\/\\/example.com\\/assets\\/some\\/media\\/path\\/myvideo2.mp4\",         \"pubDate\":\"Tue, 01 Sep 2016 18:29:52 +0530\",         \"media:thumbnail\":\"http:\\/\\/example.com\\/assets\\/some\\/someimage2.jpg\",         \"media:duration\":\"1945\",         \"description\":\"This is a sample description 2\",         \"media:filepath\":\"http:\\/\\/example.com\\/videos\\/1234\\/myvideo2.mp4\",         \"media:fullimage\":\"http:\\/\\/example.com\\/videos\\/1234\\/thumbnail2.jpg\",         \"media:keywords\":\"some, sample, keywords,random\"      },           {           \"id\":\"4543434333\",         \"title\":\"'Sample video title3\",         \"link\":\"http:\\/\\/example.com\\/assets\\/some\\/media\\/path\\/myvideo3.mp4\",         \"pubDate\":\"Tue, 01 Aug 2016 18:29:52 +0530\",         \"media:thumbnail\":\"http:\\/\\/example.com\\/assets\\/some\\/someimage3.jpg\",         \"media:duration\":\"1955\",         \"description\":\"This is a sample description\",         \"media:filepath\":\"http:\\/\\/example.com\\/videos\\/1234\\/myvideo3.mp4\",         \"media:fullimage\":\"http:\\/\\/example.com\\/videos\\/1234\\/thumbnail3.jpg\",         \"media:keywords\":\"some, sample, keywords,random\"      }         ]}Let’s say you wanted to select the media:thumbnail values for all the items. You could use this syntax:$..results[*].media:thumbnailThis syntax says to start at the root, look recursively in all the items, match everything within the results array, and select the media:thumbnail element. The following gets returned:[   \"http://example.com/assets/some/someimage1.jpg\",   \"http://example.com/assets/some/someimage2.jpg\",   \"http://example.com/assets/some/someimage3.jpg\"]JSON Path Query Example 3Instead of using the feed from Fire App Builder, in this example you will capture content from a more complicated feed structure.      Copy the following feed and insert it into the Jayway JsonPath Evaluator.    {\"brand\": \"myChannel\",  \"version\": \"2.0\",  \"creationDate\": 1462590933,    \"containers\": [        {            \"type\": \"movie.Container\",            \"subtype\": \"movies\",            \"common\": {                \"title\": \"Movies\"            },            \"movies\": [                {                    \"subtype\": \"movie\",                    \"cat\": \"romance\",                    \"availableDate\": 1351631300,                    \"expirationDate\": 1364764900,                    \"common\": {                        \"authId\": \"1234\",                        \"title\": \"Sample Movie Title\",                        \"subtitle\": \"My sample subtitle for the movie\",                        \"description\": \"This is a description for the movie. It describes the basic plot and story.\",                        \"tags\": [                            \"Some\",                            \"Tags\",                            \"Here\"                        ],                        \"promotionalText\": \"\",                        \"theshareURL\": \"http://yourcompany.com/mymovieurl1\",                        \"imageUrls\": {                            \"1000x500_portal\": \"http://www.yourcompany.com/moviethumbl.jpg\"                        }                    }                }            ]        },        {            \"type\": \"movie.Container\",            \"subtype\": \"movies\",            \"common\": {                \"title\": \"Movies\"            },            \"movies\": [                {                    \"subtype\": \"movie\",                    \"cat\": \"adventure\",                    \"availableDate\": 1351631400,                    \"expirationDate\": 1364765900,                    \"common\": {                        \"authId\": \"5678\",                        \"title\": \"Sample Movie Title 2\",                        \"subtitle\": \"Another sample subtitle for the movie\",                        \"description\": \"This is another sample movie title.\",                        \"tags\": [                            \"Some\",                            \"Tags\",                            \"Here\"                        ],                        \"promotionalText\": \"\",                        \"theshareURL\": \"http://yourcompany.com/mymovieurl2\",                        \"imageUrls\": {                            \"1000x500_portal\": \"http://www.yourcompany.com/moviethumb2.jpg\"                        }                    }                }            ]        }    ]}            In the Go! box, enter the following:    $.containers[?(@.type == 'movie.Container')].movies[*].cat        Here’s what this query says:                            Query syntax          What it means                                      $          Start at the root level                          .containers[          Match all instances of the key “containers” that contains an array (with specific contents) at the root level                          ?(@.type == 'movie.Container')]: Create a filter that matches on the key type where type is equal to movie.Container.                                     .movies[*]          Match all content in the movies array.                          .cat          Match the cat within the movies array.                          Click Go!    The result retrieves the cats:     [    \"romance\",    \"adventure\" ]      Example 4Suppose your feed structure looks like this:[  {    \"ChannelLang\": \"English\",    \"VideoId\": \"239870\",    \"VidTitle\": \"Top Stories\",    \"videoKeywords\": \"news, stories, crime,\",    \"videoDescription\": \"This is my video description.\",    \"slug\": \"top-news-stories\",    \"duration\": 4318,    \"image\": \"http:\\/\\/example.com\\/2016\\/11\\/43434.jpg\",    \"thumb\": \"http:\\/\\/example.com\\/2016\\/11\\/43434_thumb.jpg\",    \"vidUrl\": \"http:\\/\\/example.com\\/2016\\/10\\/myvideo.mp4\",    \"created\": \"2016-11-02 23:08:42\",    \"vidcategory\": \"Adventure\"  },  {    \"ChannelLang\": \"English\",    \"VideoId\": \"239870\",    \"VidTitle\": \"Top Stories\",    \"videoKeywords\": \"news, stories, crime,\",    \"videoDescription\": \"This is my video description.\",    \"slug\": \"top-news-stories\",    \"duration\": 4318,    \"image\": \"http:\\/\\/example.com\\/2016\\/11\\/43434.jpg\",    \"thumb\": \"http:\\/\\/example.com\\/2016\\/11\\/43434_thumb.jpg\",    \"vidUrl\": \"http:\\/\\/example.com\\/2016\\/10\\/myvideo.mp4\",    \"created\": \"2016-11-02 23:08:42\",    \"vidcategory\": \"Adventure\"  },   {     \"ChannelLang\": \"English\",     \"VideoId\": \"239870\",     \"VidTitle\": \"Top Stories\",     \"videoKeywords\": \"news, stories, crime,\",     \"videoDescription\": \"This is my video description.\",     \"slug\": \"top-news-stories\",     \"duration\": 4318,     \"image\": \"http:\\/\\/example.com\\/2016\\/11\\/43434.jpg\",     \"thumb\": \"http:\\/\\/example.com\\/2016\\/11\\/43434_thumb.jpg\",     \"vidUrl\": \"http:\\/\\/example.com\\/2016\\/10\\/myvideo.mp4\",     \"created\": \"2016-11-02 23:08:42\",     \"vidcategory\": \"Adventure\"   }]The following query would target the category:$..vidcategory",
        "url": "fire-app-builder-querying-json.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-querying-xml-html": {
        "title": "Querying XML",
        "tags": "[]",
        "content": "When you set up your recipes, you used XML query syntax for the query parameter. XML queries use XPath expressions. You can learn more about the XPath syntax here. You can also test out your XPath expressions using this XPath Tester / Evaluator.Once you get the result from XPath, you use matchList selectors to select specific elements in the query result. The matchList selectors don’t use XPath syntax but rather a custom Amazon syntax to target the right elements. The purpose of the matchList selector is to correlate an element in your feed with the Fire App Builder content model so that the right item can be displayed in the Fire App Builder UI.The examples on this page demonstrate a variety of both XPath queries and matchList selectors. In each example, first a query is used to target specific elements from your feed. Then a matchList parameter is used to select the elements from the query’s returns.With the matchList parameter, there’s not an evaluator (as there is with XPath) where you can plug in the syntax and see the result. The only way is to look at how your app builds in Android Studio.  Example 1  Example 2  Example 3Example 1Suppose your XML document looks like this:&lt;doc&gt;     &lt;title&gt;My catagory title&lt;/title&gt;     &lt;p pid=\"1\"&gt;My category&lt;/p&gt;     &lt;p&gt;my category&lt;/p&gt; &lt;/doc&gt;A query for doc/title would result in the following:Element='&lt;title&gt;My catagory title&lt;/title&gt;'A query for doc/p[2] would result in the following:Element='&lt;title&gt;My catagory title&lt;/title&gt;'A query for doc/p[@pid=\"1\"] would result in the following:Element='&lt;p pid=\"1\"&gt;My category&lt;/p&gt;'Example 2Now let’s look at a more complex XML feed:&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;rss version=\"2.0\"&gt;  &lt;channel&gt;    &lt;title&gt;Generic mrss feed&lt;/title&gt;    &lt;link&gt;http://www.developer.amazon.com/&lt;/link&gt;    &lt;description&gt;Generic mrss data&lt;/description&gt;    &lt;item&gt;      &lt;id&gt;1&lt;/id&gt;      &lt;title&gt;Nullamtus&lt;/title&gt;      &lt;link&gt;http://www.developer.amazon.com/&lt;/link&gt;      &lt;pubdate&gt;Wed, 14 Jan 2015 00:36:00 +0000&lt;/pubdate&gt;      &lt;description&gt;Sed a sagittis urna, a fermentum ligula. In sagittis sagittis libero, ut tincidunt sapien egestas.&lt;/description&gt;      &lt;image&gt;https://raw.githubusercontent.com/amzn/web-app-starter-kit-for-fire-tv/master/src/common/assets/images/l1.jpg&lt;/image&gt;      &lt;category&gt;Lifestyle&lt;/category&gt;    &lt;/item&gt;    &lt;item&gt;      &lt;id&gt;2&lt;/id&gt;      &lt;title&gt;Ut at augue&lt;/title&gt;      &lt;link&gt;http://www.developer.amazon.com/&lt;/link&gt;      &lt;pubdate&gt;Wed, 14 Jan 2015 00:36:00 +0000&lt;/pubdate&gt;      &lt;description&gt;Phasellus vulputate tellus vitae volutpat viverra. Praesent posuere rutrum erat nec suscipit. Fusce interdum porta porta. Integer vulputate malesuada dictum.&lt;/description&gt;      &lt;image&gt;https://raw.githubusercontent.com/amzn/web-app-starter-kit-for-fire-tv/master/src/common/assets/images/l2.jpg&lt;/image&gt;      &lt;category&gt;Travel&lt;/category&gt;    &lt;/item&gt;    &lt;item&gt;      &lt;id&gt;3&lt;/id&gt;      &lt;title&gt;Quisque porttitor augue&lt;/title&gt;      &lt;link&gt;http://www.developer.amazon.com/&lt;/link&gt;      &lt;pubdate&gt;Wed, 14 Jan 2015 00:36:00 +0000&lt;/pubdate&gt;      &lt;description&gt;Pellentesque vel metus sem. Aenean porta elementum sagittis.&lt;/description&gt;      &lt;image&gt;https://raw.githubusercontent.com/amzn/web-app-starter-kit-for-fire-tv/master/src/common/assets/images/l3.jpg&lt;/image&gt;      &lt;category&gt;Sports&lt;/category&gt;    &lt;/item&gt;   &lt;/channel&gt;&lt;/rss&gt;A query for rss/channel/item/category/text() would result in the following:Text='Lifestyle'Text='Travel'Text='Sports'Example 3Here’s one more feed:&lt;rss version=\"2.0\" xmlns:media=\"http://search.yahoo.com/mrss/\"  xmlns:creativeCommons=\"http://samplesite.com/mymrssfeed\"&gt;  &lt;channel&gt;    &lt;title&gt;Content Mix for US News-in-Pictures 9x16&lt;/title&gt;    &lt;description&gt;Screenfeed Content Server&lt;/description&gt;    &lt;lastBuildDate&gt;Mon, 08 Dec 2014 22:55:16 GMT&lt;/lastBuildDate&gt;&lt;ttl&gt;5&lt;/ttl&gt;     &lt;item&gt;      &lt;title&gt;Taylor Swift&lt;/title&gt;      &lt;guid isPermaLink=\"false\"&gt;1&lt;/guid&gt;      &lt;pubDate&gt;Mon, 08 Dec 2014 22:55:16 GMT&lt;/pubDate&gt;      &lt;category&gt;News&lt;/category&gt;      &lt;media:content url=\"http://samples.screenfeed.com/1.jpg\" type=\"image/jpeg\"&gt;        &lt;media:title type=\"plain\"&gt;1080x1920 - English - with caption&lt;/media:title&gt;        &lt;media:credit&gt;Â© 2014 Thomson Reuters&lt;/media:credit&gt;        &lt;media:thumbnail url=\"http://samples.screenfeed.com/public/us-news-in-pictures/1080x1920/h9xnRIN9CUGiTWNQBBrjOw-1080x1920h-1.jpg\" /&gt;      &lt;/media:content&gt;    &lt;/item&gt;        &lt;item&gt;      &lt;title&gt;Melanie Martinez&lt;/title&gt;      &lt;guid isPermaLink=\"false\"&gt;1&lt;/guid&gt;      &lt;pubDate&gt;Mon, 1 Dec 2014 12:35:56 GMT&lt;/pubDate&gt;      &lt;category&gt;Trending&lt;/category&gt;      &lt;media:content url=\"http://samples.screenfeed.com/2.jpg\" type=\"image/jpeg\"&gt;        &lt;media:title type=\"plain\"&gt;1080x1920 - English - with caption&lt;/media:title&gt;        &lt;media:credit&gt;Â© 2014 Thomson Reuters&lt;/media:credit&gt;        &lt;media:thumbnail url=\"http://samples.screenfeed.com/public/us-news-in-pictures/1080x1920/h9x4985398UGiTWNQBBrjOw-1080x1920h-2.jpg\" /&gt;      &lt;/media:content&gt;    &lt;/item&gt;  &lt;/channel&gt;&lt;/rss&gt;A query for rss/channel/item/category/text() would result in the following:Text='News'Text='Trending'A query for /rss/channel/item would result in the following:Element='&lt;item&gt;  &lt;title&gt;Taylor Swift&lt;/title&gt;  &lt;guid isPermaLink=\"false\"&gt;1&lt;/guid&gt;  &lt;pubDate&gt;Mon, 08 Dec 2014 22:55:16 GMT&lt;/pubDate&gt;  &lt;category&gt;News&lt;/category&gt;  &lt;media:content xmlns:media=\"http://search.yahoo.com/mrss/\" url=\"http://samples.screenfeed.com/1.jpg\" type=\"image/jpeg\"&gt;    &lt;media:title type=\"plain\"&gt;1080x1920 - English - with caption&lt;/media:title&gt;    &lt;media:credit&gt;Â© 2014 Thomson Reuters&lt;/media:credit&gt;    &lt;media:thumbnail url=\"http://samples.screenfeed.com/public/us-news-in-pictures/1080x1920/h9xnRIN9CUGiTWNQBBrjOw-1080x1920h-1.jpg\" /&gt;  &lt;/media:content&gt;&lt;/item&gt;'Element='&lt;item&gt;  &lt;title&gt;Melanie Martinez&lt;/title&gt;  &lt;guid isPermaLink=\"false\"&gt;1&lt;/guid&gt;  &lt;pubDate&gt;Mon, 1 Dec 2014 12:35:56 GMT&lt;/pubDate&gt;  &lt;category&gt;Trending&lt;/category&gt;  &lt;media:content xmlns:media=\"http://search.yahoo.com/mrss/\" url=\"http://samples.screenfeed.com/2.jpg\" type=\"image/jpeg\"&gt;    &lt;media:title type=\"plain\"&gt;1080x1920 - English - with caption&lt;/media:title&gt;    &lt;media:credit&gt;Â© 2014 Thomson Reuters&lt;/media:credit&gt;    &lt;media:thumbnail url=\"http://samples.screenfeed.com/public/us-news-in-pictures/1080x1920/h9x4985398UGiTWNQBBrjOw-1080x1920h-2.jpg\" /&gt;  &lt;/media:content&gt;&lt;/item&gt;'",
        "url": "fire-app-builder-querying-xml.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-troubleshooting-html": {
        "title": "Troubleshooting",
        "tags": "[]",
        "content": "First consult the Known Issues section to see if any bugs you’re experiencing are known.If you can’t resolve your issue, see the Fire TV and Fire TV Stick categories on the Support Forums.Build ErrorsProblem: You try to build the project but get an error that says:Error: Content is not allowed in prologThis error is related to Windows. When you cloned the Github repo, git didn’t have symbolic linking configured to true. As a result, the symlinks used for some of the XML files didn’t copy down with the right content.Resolution: Configure git to use symbolic links:git config –global core.symlinks true Then re-clone the repo and build the project again. You can verify that symlinks are working by looking at the strings.xml file in Utils &gt; src &gt; main &gt; res &gt; values &gt; strings.xml &gt; strings.xml (en-rUS). If you see normal content, symlinks are working. In contrast, if there’s just a short reference and nothing else, symlinks aren’t working.",
        "url": "fire-app-builder-troubleshooting.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "fire-app-builder-use-an-android-tv-emulator-html": {
        "title": "Use an Android TV Emulator to Run Your App",
        "tags": "[]",
        "content": "When you develop your app with Fire App Builder, you should use an actual Fire TV device to test your app. See Connecting to Fire TV Through ADB for details. However, if you’re in a situation where you can only use an emulator, you can get by if you accept some limitations with the emulator. The emulator will work, but you can’t click the media player buttons with your mouse.Mouse clicks generate motion events, which aren’t supported by media played in Fire App Builder (you’ll see an error in logcat that says “java.lang.ClassCastException: android.view.MotionEvent cannot be cast to android.view.KeyEvent”). As a result, the app will crash on the emulator if you use your mouse to click the media player’s buttons.Instead of using your mouse on the media playback screen, to return to the previous screen after playing media, click the Back button on the right of the emulator (as indicated by the arrow in the following screenshot).Don’t click the media player’s buttons with your mouse. Outside of media playback, you can use your mouse to click wherever you want.To configure an emulator:When you configure the Android TV emulator, you must select at least API Level 23 or 24. You have flexibility with the other settings (resolution, size, and so on). (If you choose API Level 24, you’ll be prompted to install Instant Run, which is a requirement for this API level.)To set up an Android TV emulator for your app:  Go to Tools &gt; Android &gt; AVD Manager, or click the AVD Manager button  on the top navigation bar.      Click the + Create Virtual Device button.     Note: You can select one of the default TV profiles, or you can customize the settings by following the steps below. If you select a default TV profile, skip ahead to step 12 where you select a system image.    In the Category column, select TV.  Click the New Hardware Profile button.  In the Device Name, type something like fire_tv_emulator. (Avoid using parentheses in the name, as this may cause errors.)  For the Device Type, select Android TV.  For the Screen size, type the screen size you want (for example, 40).  For the Resolution, type the resolution you want (for example, 1280 x 720).  For the Supported device states, select only Landscape (clear the Portrait check box).  Click Finish.  In the “Choose a device definition” dialog box, select the emulator you just created and click Next.  In the Release Name column, select at least Marshmallow API Level 23 or higher. If you haven’t downloaded this system image yet, click Download to download it. (If you select API Level 22 or lower, media playback will fail in the emulator.)  Click Next and then click Finish.The emulator is now listed as an option in your virtual devices. Note: If you chose a default TV profile, you must rename the device to remove any parentheses in the name. These parentheses cause an error when you run your app. (You’ll see an error that says the \"virtual device name contains invalid characters.\") To rename your virtual device, while viewing your virtual devices, click the Edit button  under the Actions column on the right. Then rename the device.Run your app by clicking the Run ‘app’ button . Select the virtual device you created:Now you can use the emulator as usual. Just be careful when you play media. When you play media, don’t click the buttons on the media player with your mouse. Instead, either use your keys or use the buttons to the right of the emulator as shown in the earlier screenshot.",
        "url": "fire-app-builder-use-an-android-tv-emulator.html",
        "product": "Fire App Builder"
      }
      ,
      
    
          
      "amazon-fling-frequently-asked-questions-html": {
        "title": "Amazon Fling Frequently Asked Questions",
        "tags": "[]",
        "content": "  What platforms are supported by the Amazon Fling SDK?   The SDK is supported on Fire OS, Android, and iOS.  What type of media can my app send to Amazon Fire TV?  With the SDK, you can send anything your custom Amazon Fire TV receiver app can play back.  How can I set the volume or mute the built-in media player receiver?  The built-in media player receiver does not support the mute and volume API calls at this time. A custom media player is required to use these APIs.  How do the autoplay and playInBg options work when calling setMediaSource with the built-in media player receiver?  The built-in media player receiver does not support these options at this time. A custom media player is required to use these options.  How do I use the setPlayerStyle API to customize the style of the built-in media player receiver?  The built-in media player receiver does not support setting the player style at this time. A custom media player is required to use this API.  What does sendCommand do when sent to the built-in media player receiver?  The built-in media player receiver does not support the sendCommand API call. The intention of this API call is to allow custom receivers to receive information that can not be included in other API calls.  A custom media player is required to use this API.  Do you have resources or guidelines for design?  Yes, please visit UX Guidelines.   How can I get additional information?  If you have questions about the SDK please visit our forum.",
        "url": "amazon-fling-frequently-asked-questions.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "android-remote-install-html": {
        "title": "Integrating Remote Install into Your Android App",
        "tags": "[]",
        "content": "To enable this feature in your mobile app for Fire OS or Android, implement the API and add permissions to your Android manifest. This document describes both these steps. See Understanding the Amazon Fling Service for a high-level overview of the features and functions our SDK provides. See also the controller sample app, part of the SDK, for details on your controller implementation.Before you start, make sure you’ve set up your development environment. See Setting Up Your Amazon Fling Development Environment for Android for more details.  Remote Installation Overview  Modifying the Android Manifest          Fire OS Devices      Non-Fire OS Android Devices        Initializing Underlying Framework and Discovering Amazon Fire TV  Installing Apps with RemoteInstallServiceRemote Installation OverviewThere are four steps for creating or modifying your controller mobile app to support Remote Install:  Modifying your Android manifest to include network permissions.  Initializing underlying framework and discovering available Fire TV devices.  For a selected Fire TV device, add logic to check if your app is installed on it.  Add UI flow to allow the user to initiate install of your Fire TV app. Modifying the Android ManifestThe API requires some permissions to be added to your Android manifest (AndroidManifest.xml). Specifically, the API needs these permissions to communicate over networks:  android.permission.INTERNET: Allows applications to open network sockets.  android.permission.ACCESS_WIFI_STATE: Allows applications to access information about Wi-Fi networks.  android.permission.ACCESS_NETWORK_STATE: Allows applications to access information about networks.  android.permission.CHANGE_WIFI_MULTICAST_STATE: Allows applications to enter Wi-Fi Multicast mode. (Android (non-Fire OS) only)In addition, Fire OS devices require a uses-library element to refer to the WhisperPlay shared library. Non-Fire OS Android devices should not include this tag.Fire OS DevicesAdd the uses-permission and uses-library elements as in the following example:  &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"[YOUR PACKAGE NAME]\"    android:versioncode=\"1\"    android:versionname=\"1.0\"&gt;    &lt;!-- Android Network Access Permissions --&gt;    &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;    &lt;application&gt;        ...        &lt;uses-library android:name=\"com.amazon.whisperplay.contracts\" android:required=\"true\" /&gt;        ...        &lt;/application&gt;    ...&lt;/manifest&gt;Non-Fire OS Android DevicesAdd the uses-permission elements as in the following example. Do not include the uses-library element for the WhisperPlay shared library.&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"[YOUR PACKAGE NAME]\"    android:versioncode=\"1\"    android:versionname=\"1.0\"&gt;    &lt;!-- Android Network Access Permissions --&gt;    &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;    &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\"/&gt;    ...&lt;/manifest&gt;Initializing Underlying Framework and Discovering Amazon Fire TVUse the InstallDiscoveryController class to create a controller and to discover and connect to Amazon Fire TV over the network. Get an instance of InstallDiscoveryController in your onCreate() method:@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate();    ...    mController = new InstallDiscoveryController(this);}The IInstallDiscoveryListener interface allows you to receive updates when an install service on an Amazon Fire TV device (RemoteInstallService) is discovered, updated, or no longer reachable by your app. Implement this interface to add behavior such as adding or removing a device to your list of discovered devices, or updating your user interface. The callback methods are called from worker thread and user interface elements shouldn’t be updated inside of calling.private InstallDiscoveryController.IInstallDiscoveryListener mDiscovery = new InstallDiscoveryController.IInstallDiscoveryListener() {    @Override    public void installServiceDiscovered(RemoteInstallService remoteInstallService) {        //add remote install service to the application’s remote install service list.    }    @Override    public void installServiceLost(RemoteInstallService remoteInstallService) {        //remove remote install service from the application’s remote install service list.    }    @Override    public void discoveryFailure() {}};Call the start() method in your onResume() method, and the stop() method in onPause(). The start() method takes one argument: an object that implements IInstallDiscoveryListener.@Overrideprotected void onResume() {    super.onResume();    …   mController.start(mDiscovery);}@Overrideprotected void onPause() {    super.onPause();    …   mController.stop();}Installing Apps with RemoteInstallServiceThe RemoteInstallService interface represents an install service running on a remote Fire TV device. Once your app discovers Fire TV  devices running this service, your app gets an object that implements this interface. Use that RemoteInstallService object to install an app or check the version of an app on the Fire TV device.When checking the version of an app if the app is not install the RemoteInstallService.PACKAGE_NOT_FOUND string will be returned. Once your app has called the installASIN method the Fire TV will launch the Appstore page associated with that ASIN (Amazon Standard Identification Number).The user will then need to finish the installation with the a Fire TV remote. If the ASIN is invalid the Fire TV will show an error popup. The ASIN of an application can be found on its product information page on amazon.com under the Product Details section. Some applications could have different products for different regions and therefore could have multiple ASINs.The RemoteInstallService.AsyncFuture interface allows your getAsync() method to add a completion listener (RemoteInstallService.FutureListener). The AsyncFuture interface implements java.util.concurrent.Future, which means you can also check to see if the computation is complete, to wait for its completion, and to retrieve the result of that computation.RemoteInstallService mSelectedFireTV; //It needs to be set with discovered instance by discovery.private void checkInstalledPackageVersion() {    mSelectedFireTV.getInstallPackageVersion(\"com.amazon.whisperplay.fling.media.player\").getAsync(                                             new RemoteInstallService.FutureListener&lt;string&gt;() {        @Override        public void futureIsNow(Future&lt;String&gt; future) {            try {                String version = future.get();                if (version.equals(RemoteInstallService.PACKAGE_NOT_FOUND)) {                    Log.i (\"LOG\", \"package not installed\");                } else {                    Log.i (\"LOG\", \"version = \" + version);                }            } catch (InterruptedException e) {                Log.e(\"LOG\", \"InterruptedException\", e);            } catch (ExecutionException e) {                Log.e(\"LOG\", \"ExecutionException\", e);            }        }    });}private void installPackage() {    mSelectedFireTV.installASIN(\"B0128SSCMO\").getAsync(new RemoteInstallService.FutureListener&lt;void&gt;() {        @Override        public void futureIsNow(Future&lt;Void&gt; future) {            try {                future.get();            } catch (InterruptedException e) {                Log.e(\"LOG\", \"InterruptedException\", e);            } catch (ExecutionException e) {                Log.e(\"LOG\", \"ExecutionException\", e);            }        }    });}",
        "url": "android-remote-install.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "designing-amazon-fling-ux-html": {
        "title": "Designing Amazon Fling UX",
        "tags": "[]",
        "content": "Amazon Fling allows you to send media sources from your mobile application to the Amazon Fire TV. Your app on the mobile device is the controller, while the app that plays your content on the Fire TV is the player.This document describes the UX design guidelines and recommendations for controller applications.  User Interface Design Guidelines  Controller App Operation          Amazon Fire TV Discovery State Visualization      Primary Use Cases                  Connect to Amazon Fire TV and Start Playback          Continue Local Playback on Amazon Fire TV          Control Playback on the Amazon Fire TV                    User Interface Design GuidelinesThe goals of these guidelines are to provide a consistent user experience across all applications and platforms using Amazon Fling and improve discoverability of the operation.Controller app:  The Amazon Fling button should be easily discoverable and accessible to the user.   The Amazon Fling button should reflect the state of discovery of and connection to the Amazon Fire TVs - these states are as follows:          No Fire TVs available in the network      Fire TVs discovered      Connected to a Fire TV        Interface should show the playback state and basic remote controls. The recommended playback control icons should be used to render the control buttons  Please refer to the recommended icon archive.Controller App OperationFor your controller app to work, the mobile device and the Amazon Fire TV must be on the same Wi-Fi network. The mobile application is responsible to show whether there are Fire TVs available on the network. If there are Fire TVs available on the network, your application allows the user to pick the desired Fire TV from the list of available Fire TVs. Once the user selects the Fire TV to play the media on, your app retrieves the current state of that Fire TV and presents it to the user. At this point, the user is able to start playing back on this Fire TV and control the playback on the Fire TV.The screenshots below are from the iOS FlingSample application in our SDK, and are as close to the Android FlingSample app as possible.Amazon Fire TV Discovery State VisualizationNo Fire TV DiscoveredAt Least 1 Fire TV DiscoveredConnected to a Fire TVThe table above shows how the Amazon Fling button should be rendered for different states of the Amazon Fire TV discovery process. The table below references icons that are available in the recommended icon archive.Discovery StateIcon RepresentationNo Fire TVs discoveredNo iconAt least one Fire TV discovered Connected to the Fire TV Primary Use CasesThis functionality supports the following primary use cases:  Connect to Amazon Fire TV and then start playback  Continue playback on the Fire TV  Control playback on the Fire TVConnect to Amazon Fire TV and Start PlaybackIn this use case, the controller first connects to the Fire TV and then sends the media URL to the Fire TV to render.Continue Local Playback on Amazon Fire TVIn this sequence, the controller streams the media and plays it locally. During the playback, the user picks a Fire TV to send the media URL to. The controller should play on one device only (e.g. show the video thumbnail on the mobile device) and indicate that remote playback is in progress by showing the connected Amazon Fling button.Control Playback on the Amazon Fire TVYour controller app may follow the shown UI guidelines for visualizing playback control. The icons are available in the recommended icon archive.Big Buck Bunny is copyright 2008, Blender Foundation / www.bigbuckbunny.org and is licensed under the Creative Commons Attribution License 3.0. Elephants Dream is copyright 2006, Blender Foundation/ Netherlands Media Art Institute/www.elephantsdream.org and is licensed under the Creative Commons Attribution License 2.5.",
        "url": "designing-amazon-fling-ux.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "iap-entitlements-webapps-html": {
        "title": "Integrate Entitlements Into Web Apps",
        "tags": "[]",
        "content": "Entitlement represents a one-time purchase to unlock access to features or content within an app or game.  Entitled Content Overview?  Sample Implementation          ButtonClicker Sample Code Entitlements      Entitled Content Overview?Entitled content includes any type of content that you sell within your app that requires access rights. This type of content is available anywhere the customer is logged into the Amazon Client. The entitled content does not expire. If Amazon needs to rescind the entitled content, your app will be notified via an observable event.Customers purchase a specific entitlement only once. The entitled content is granted to the customer’s Amazon account. That entitled content is used to access the content from any eligible device the customer has linked to their account.Entitled content typically include items such as:  Additional levels for a game  Access to a previously purchased item like a magazine issue  Unlocking functionality already in your appThe PurchasingManager grants the entitlement; you do not have to do anything outside of initiating the purchase. Through the PurchasingManager you can retrieve purchase data and revoked entitlements to determine if a customer has an entitlement for a specific SKU.Sample ImplementationThe following sample code is an excerpt of the Button Clicker Sample App showing the relevant logic for integrating entitled content. In the app, button colors are purchasable entitled content items. The complete app and source code is provided as part of the Amazon Web App Resources.ButtonClicker Sample Code Entitlements/**     * Button Clicker     * Sample Implementation of the In-App Purchasing APIs     * © 2013, Amazon.com, Inc. or its affiliates.     * All Rights Reserved.     * Licensed under the Apache License, Version 2.0 (the \"License\").     * You may not use this file except in compliance with the License.     * A copy of the License is located at     * http://aws.amazon.com/apache2.0/     * or in the \"license\" file accompanying this file.     * This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or     * implied.     * See the License for the specific language governing permissions and limitations under the License.     */    // This is a simple model view controller setup to deal with    // the fact that the onPurchaseResponse can get called at any    // time.    //    // The fact that responses can come at any time is important to    // understand when using the API. Your web app could have been    // shut down prior to a receipt being delivered for instance. The    // next time your application runs the receipt will be delivered    // upon initializing the API in this case.    // Model Data    var activeButton = \"\";    var hasRedButton = false;    var hasGreenButton = false;    $(function() {        initialize();    });    // Setup    function initialize() {        amzn_wa.enableApiTester(amzn_wa_tester);        refreshPageState();        // Setup button press handlers        $(\"#redButton\").click(function() { redButtonPressed(); });        $(\"#greenButton\").click(function() { greenButtonPressed(); });        document.addEventListener(\"amazonPlatformReady\", function(oData) {            // Ensure we can call the IAP API            if (amzn_wa.IAP == null) {                console.log(\"Amazon In-App-Purchasing only works with Apps from the Appstore\");            } else {                // Registers the appropriate callback functions                amzn_wa.IAP.registerObserver({                        // Called the the IAP API is available                        'onSdkAvailable': function(resp) {                            if (resp.isSandboxMode) {                                // In a production application this should trigger either                                // shutting down IAP functionality or redirecting to some                                // page explaining that you should purchase this application                                // from the Amazon Appstore.                                //                                // Not checking can leave your application in a state that                                // is vulnerable to attacks. See the supplied documention                                // for additional information.                                alert(\"Running in test mode\");                            }                            // You should call getPurchaseUpdates to get any purchases                            // that could have been made in a previous run.                            amzn_wa.IAP.getPurchaseUpdates(amzn_wa.IAP.Offset.BEGINNING);                        },                        // Called as response to getUserId                        'onGetUserIdResponse': function(resp) {},                        // Called as response to getItemData                        'onItemDataResponse': function(data) {},                        // Called as response to puchaseItem                        'onPurchaseResponse': function(data) { onPurchaseResponse(data); },                        // Called as response to getPurchaseUpdates                        'onPurchaseUpdatesResponse': function(resp) { onPurchaseUpdatesResponse(resp); }                });            }        });    }    // Controller    // Excercises entitlements    function redButtonPressed() {        if (hasRedButton) {            activeButton = \"red\";        } else {            buyButton(\"sample.redbutton\");        }        refreshPageState();    }    // Excercises entitlements    function greenButtonPressed() {        if (hasGreenButton) {            activeButton = \"green\";        } else {            buyButton(\"sample.greenbutton\");        }        refreshPageState();    }    function buyButton(buttonName) {        if (amzn_wa.IAP == null) {            alert(\"You cannot buy this button, Amazon In-App-Purchasing works only with Apps from the Appstore.\");        } else {            alert(\"Calling purchaseItem: \" + buttonName);            amzn_wa.IAP.purchaseItem(buttonName);        }    }    // Handler functions that are called from the callbacks    // purchaseItem will cause a purchase response with one receipt    function onPurchaseResponse(e) {        if (e.purchaseRequestStatus == amzn_wa.IAP.PurchaseStatus.SUCCESSFUL) {            handleReceipt(e.receipt);        } else if (e.purchaseRequestStatus == amzn_wa.IAP.PurchaseStatus.ALREADY_ENTITLED) {            amzn_wa.IAP.getPurchaseUpdates(amzn_wa.IAP.Offset.BEGINNING)        }        refreshPageState();    }    // getPurchaseUpdates will return an array of receipts    function onPurchaseUpdatesResponse(e) {        for (var i = 0; i &lt; e.receipts.length; i++) {            handleReceipt(e.receipts[i]);        }        refreshPageState();    }    // In either case, the contents of the receipt are handled in the same way    function handleReceipt(receipt) {        alert(receipt.sku);        if (receipt.sku == \"sample.redbutton\") {            // Entitlement            hasRedButton = true;        } else if (receipt.sku == \"sample.greenbutton\") {            // Entitlement            hasGreenButton = true;        }    }    // Make the view (HTML) look like the model    function refreshPageState() {        var button = $(\"#theButton\");        var redButton = $(\"#redButton\");        var greenButton = $(\"#greenButton\");        setClass(redButton, \"locked\", !hasRedButton);        setClass(greenButton, \"locked\", !hasGreenButton);        setClass(redButton, \"active\", activeButton == \"red\");        setClass(greenButton, \"active\",  activeButton == \"green\");        if (activeButton != \"\") {            button.css(\"background-color\", activeButton);        } else {            button.css(\"background-color\", \"gray\");        }    }    function setClass(element, className, condition) {        if (condition) {            element.addClass(className);        } else {            element.removeClass(className);        }    }[Next Step: Integrating Subscription Content Into Your App][iap-subscription-webapps]",
        "url": "iap-entitlements-webapps.html",
        "product": "In-App Purchasing"
      }
      ,
      
    
          
      "integrating-amazon-fling-into-your-android-app-html": {
        "title": "Integrating Amazon Fling into Your Android App",
        "tags": "[]",
        "content": "To enable this feature in your mobile app for Fire OS or Android, implement the API and add permissions to your Android manifest. This document describes both these steps. See Understanding the Amazon Fling Service for a high-level overview of the features and functions our SDK provides. See also the controller sample app, which is part of the SDK, for details on your controller implementation.Before you start, make sure you’ve set up your development environment. See Setting Up Your Amazon Fling Development Environment for Android for more details.  Integration Overview  Modifying the Android Manifest          Fire OS Devices      Non-Fire OS Android Devices        Initializing Underlying Framework and Discovering Amazon Fire TV  Flinging Content with RemoteMediaPlayer  Monitoring Remote Player Status with MediaPlayerStatus  Next StepsIntegration OverviewThere are four steps for creating or modifying your controller mobile app to support our SDK:  Modifying your Android manifest to include network permissions.  Initializing underlying framework and discovering available players on Fire TV devices.  Flinging content and controlling that content.  Monitoring the status of that content.Modifying the Android ManifestThe API requires some permissions to be added to your Android manifest (AndroidManifest.xml). Specifically, the API needs these permissions to communicate over networks:  android.permission.INTERNET: Allows applications to open network sockets.  android.permission.ACCESS_WIFI_STATE: Allows applications to access information about Wi-Fi networks.  android.permission.ACCESS_NETWORK_STATE: Allows applications to access information about networks.  android.permission.CHANGE_WIFI_MULTICAST_STATE: Allows applications to enter Wi-Fi Multicast mode. (Android (non-Fire OS) only)In addition, Fire OS devices require a uses-library element to refer to the WhisperPlay shared library. Non-Fire OS Android devices should not include this tag.Fire OS DevicesAdd the uses-permission and uses-library elements as in the following example:  manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"[YOUR PACKAGE NAME]\"    android:versioncode=\"1\"    android:versionname=\"1.0\"&gt;    &lt;!-- Android Network Access Permissions --&gt;    &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;    &lt;application&gt;        ...        &lt;uses-library android:name=\"com.amazon.whisperplay.contracts\" android:required=\"true\" /&gt;        ...        &lt;/application&gt;    ...&lt;/manifest&gt;Non-Fire OS Android DevicesAdd the uses-permission elements as in the following example. Do not include the uses-library element for the WhisperPlay shared library.manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"[YOUR PACKAGE NAME]\"    android:versioncode=\"1\"    android:versionname=\"1.0\"&gt;    &lt;!-- Android Network Access Permissions --&gt;    &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;    &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\"/&gt;    ...&lt;/manifest&gt;Initializing Underlying Framework and Discovering Amazon Fire TVUse the DiscoveryController class to create a controller and to discover and connect to Amazon Fire TV over the network. Get an instance of DiscoveryController in your onCreate() method:@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate();    setContentView(R.layout.activity_main);    ...    mController = new DiscoveryController(getApplicationContext());}The IDiscoveryListener interface allows you to receive updates when a player on an Amazon Fire TV device (RemoteMediaPlayer) is discovered, updated, or no longer reachable by your app. Implement this interface to add behavior such as adding or removing a device to your list of discovered devices, or updating your user interface. The callback methods are called from worker thread and user interface elements shouldn’t be updated inside of calling.private DiscoveryController.IDiscoveryListener mDiscovery = new DiscoveryController.IDiscoveryListener() {    @Override    public void playerDiscovered(RemoteMediaPlayer player) {        //add media player to the application’s player list.    }    @Override    public void playerLost(RemoteMediaPlayer player) {        //remove media player from the application’s player list.    }    @Override    public void discoveryFailure() {}};Call the start() method in your onResume() method, and the stop() method in onPause(). The start() method takes two arguments: a player service identifier or SID (defined by your custom player app on Fire TV), and an object that implements IDiscoveryListener. The service identifier (SID) must match the target player. For more information on creating the player app on Fire TV, see Integrating Amazon Fling into your Fire TV Application.@Overrideprotected void onResume() {    super.onResume();    …   mController.start(\"YourReceiverServiceID\", mDiscovery);}@Overrideprotected void onPause() {    super.onPause();    …   mController.stop();}Flinging Content with RemoteMediaPlayerThe RemoteMediaPlayer interface represents a player running on a remote Fire TV device. Once your controller app discovers target devices for flinging, your controller app gets an object that implements this interface. Use that RemoteMediaPlayer object to fling media from your app to the player application on the target device.The RemoteMediaPlayer.AsyncFuture interface allows your getAsync() method to add a completion listener (RemoteMediaPlayer.FutureListener). The AsyncFuture interface implements java.util.concurrent.Future, which means you can also check to see if the computation is complete, to wait for its completion, and to retrieve the result of that computation.private StatusListener mListener = new Monitor();private static final long MONITOR_INTERVAL = 1000L;private void fling(final RemoteMediaPlayer target, final String name, final String title) {    mCurrentDevice = target;    mCurrentDevice.addStatusListener(mListener).getAsync(new ErrorResultHandler(\"Cannot set status listener\"));    mCurrentDevice.setPositionUpdateInterval(MONITOR_INTERVAL)            .getAsync(new ErrorResultHandler(\"Error attempting set update interval, ignoring\"));    mCurrentDevice.setMediaSource(name, title, true, false).getAsync(new ErrorResultHandler(\"Error attempting to Play\"));}private void doStop() {     if (mCurrentDevice != null) {         mCurrentDevice.stop().getAsync(new FutureListener&lt;void&gt;() {             @Override              public void futureIsNow(Future&lt;void&gt; result) {                  try {                      result.get();                  } catch(ExecutionException e) {                      //handleFailure                  } catch(Exception e) {                      //handleFailure                  }              }         });    }}private class ErrorResultHandler implements FutureListener&lt;void&gt; {    ErrorResultHandler(String msg) {        this(msg, false);     }    @Override     public void futureIsNow(Future&lt;void&gt; result) {         try {             result.get();          } catch(ExecutionException e) {              //handleFailure          } catch(Exception e) {              //handleFailure          }    }}Monitoring Remote Player Status with MediaPlayerStatusImplement the CustomMediaPlayer.StatusListener in your controller app to monitor the status, condition, and position of the flung content on the remote Fire TV player app.Status mStatus = new Status();private static class Status {    public long mPosition;    public MediaState mState;    public MediaCondition mCond;}private class Monitor implements StatusListener {    @Override    public void onStatusChange(MediaPlayerStatus status, long position) {        synchronized (mStatus) {            mStatus.mState  = status.getState();            mStatus.mCond = status.getCondition();            mStatus.mPosition = position;        }    }}The player app on Fire TV uses the MediaPlayerStatus class to set the content state (MediaPlayerStatus.MediaState) and condition (MediaPlayerStatus.MediaCondition). Your controller app can get this status with a state and condition through the StatusListener, and use this information to control the behavior of your app.public enum MediaState {    NoSource, PreparingMedia, ReadyToPlay, Playing, Paused, Seeking, Finished, Error};public enum MediaCondition {    Good, WarningContent, WarningBandwidth, ErrorContent, ErrorChannel, ErrorUnknown};public MediaState getState();public MediaCondition getCondition();Next StepsTo create a custom Fling player for Fire TV, see Integrating Amazon Fling into your Fire TV Application.If you are modifying an existing Google Cast app to support Amazon Fling, see Integrating Amazon Fling with an Existing Android Cast App.If you use Android’s MediaRouter in your app, see Using Amazon Fling with Android MediaRouter.",
        "url": "integrating-amazon-fling-into-your-android-app.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "integrating-amazon-fling-into-your-fire-tv-app-html": {
        "title": "Integrating Amazon Fling SDK into your Fire TV App",
        "tags": "[]",
        "content": "A player is an application on Amazon Fire TV that acts as a server to a mobile device based controller app and allows the controller to play content on the Fire TV. You can implement a customized player that fits your banding and rendering needs.  Integration Overview  Starting Your Amazon Fire TV App Development  Defining the Player SID  Implementing a Listener Service  Creating a Media PlayerIntegration OverviewTo create a new customized player or to enhance your existing Fire TV app to include flinging capability, you must use the player API, which is part of the SDK. The player application must:  Identify itself uniquely to the controllers: The player app must provide a unique service identifier (SID) so that the controller app can discover the Fire TVs hosting this player app.  Announce itself to the framework: The underlying framework enumerates the player applications based on a XML file in the application package. The player app must include this with appropriate metadata.  Listen for incoming controller requests: The player app must implement a service derived from the MediaPlayerHostService in the player API.  Provide implementation of the player interface: The player app must provide an implementation of CustomMediaPlayer to serve incoming control requests from the controller app.See Understanding the Amazon Fling Service for a high-level overview of the features and functions this service provides. See also the player sample app, part of the SDK, for details on your player implementation. Before you start, make sure you’ve set up your development environment. See Setting Up Your Amazon Fling Development Environment for Android for more details.Starting Your Amazon Fire TV App DevelopmentIf you are creating a brand new Fire TV app as a customized player app, it would be good to start with the Amazon Fire TV app development guide here: Getting Started Developing Apps and Games for Amazon Fire TV.While the latest generation of the Amazon Fire TV is based on Fire OS 5 (API 22), please target your applications to API 17, to cover older generation Amazon Fire TVs in the market, which are based on Fire OS 3. If you’re an Android developer, working with the Fire TV platform is easy and familiar. Fire TV uses the same tools and APIs you’re already used to for Android development.uses-sdk android:minSdkVersion=\"10\" android:targetSdkVersion=\"17\"/&gt;Defining the Player SIDYour player app on Fire TV is identified by a unique service identifier (SID). This unique SID is set in your project. The underlying framework broadcasts the SID over the network for mobile device based controller apps to discover. You can make the SID unique by adding “com.your.organization.” prefix to the SID.To define the SID for your app and advertise it to the underlying framework, the following steps must be taken:      Add a file called Whisperplay.xml to your app’s resources, in the res/xml/ directory. The contents of the file should look like this:    &lt;whisperplay&gt;    &lt;services&gt;        &lt;service&gt;            &lt;sid&gt;com.your.organization.custom.player&lt;/sid&gt;            &lt;accessLevel&gt;ALL&lt;/accessLevel&gt;            &lt;startService&gt;com.your.organization.example.ExamplePlayerService&lt;/startService&gt;        &lt;/service&gt;    &lt;/services&gt;&lt;/whisperplay&gt;        Here the &lt;sid&gt; element defines the SID and &lt;startService&gt; element refers to the listener service (see the next section for details).        Add a reference to the WhisperPlay XML file in your AndroidManifest.xml file.    meta-data android:name=\"whisperplay\" android:resource=\"@xml/whisperplay\" /&gt;            Add a “uses” library in your AndroidManifest.xml file    &lt;uses-library android:name=\"com.amazon.whisperplay.contracts\" /&gt;            Implement abstract function getPlayerId() in MediaPlayerHostService. See the next section for details.  Implementing a Listener ServiceThe player app must implement a service that can be started by the underlying framework when a controller app invokes a remote procedure call. This service derives from MediaPlayerHostService, which provides most of the listener functionality. The following methods are left to you to implement:public class ExamplePlayerService extends MediaPlayerHostService {    // Create the media player implementation that will handle remote method invocations    @Override    public CustomMediaPlayer createServiceImplementation() { return new ExamplePlayer(this); }    // Communicate the unique service identifier (SID) of your player app    @Override    public String getPlayerId() { return \"com.your.organization.custom.player\"; }    @Override    public IBinder onBind(Intent intent) { return null; }}public class ExamplePlayer implements CustomMediaPlayer {    //Media player (e.g. Android MediaPlayer)    private MediaPlayer mPlayer;    @Override    public void setMediaSource(String mediaLoc, String metadataJson,                                     boolean autoPlay, boolean playInBg) throws IOException {        //Implementation for your custom player.    }    .    .    .}Creating a Media PlayerYour customized player’s primary function is to render the URLs that are being sent from the controller apps. Your media player must implement the RemoteMediaPlayer API interface so that the controller can use it as its target player. The actual implementation of APIs such as setMediaSource(), play(), pause(), etc. depends on your intended user experience.For a player app that is designed to play videos, please refer to the player sample project in the SDK and see the topics from MediaPlayer, SurfaceView, SurfaceHolder, and AudioManager. If your app is a picture viewer, your media player will ignore the APIs for playable media such as seek().You must also support status listeners. The controller app can subscribe to the status change notifications through the addStatusListener() interface. When the playback status changes, the player app must send the notification to all the current listeners. When a media (audio or video) is playing, it is a good practice to send regular status updates with current position.",
        "url": "integrating-amazon-fling-into-your-fire-tv-app.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "integrating-amazon-fling-into-your-ios-app-html": {
        "title": "Integrating Amazon Fling into your iOS App",
        "tags": "[]",
        "content": "This service provides an asynchronous discovery and control mechanism for your iOS app in the form of a framework. See Understanding the Amazon Fling Service for a high-level overview of the features and functions this service provides. See also the “FlingSample” sample app, part of the SDK, for a sample controller implementation for iOS.Before you start, make sure you’ve set up your development environment. See Setting Up your Amazon Fling Development Environment for iOS  for details.  Initializing and Suspending the Controller App  Implementing Discovery Callbacks  Presenting Remote Players to the User  Working with BFTask  Connecting to and Disconnecting from a Remote Player  Controlling Playback  Next StepsInitializing and Suspending the Controller AppWhen your iOS controller app loads, for example in the ViewController::viewDidLoad method, call DiscoveryController::searchPlayerWithId to initialize the underlying framework and start the discovery. Call DiscoveryController::resume every time the app comes to the foreground, that is, in the applicationDidBecomeActive lifecycle event of the UIApplicationDelegate implementation.@implementation AppDelegate...- (void)applicationDidBecomeActive:(UIApplication *)application {    id myViewController = [self findViewController];    [myViewController resume];}...@implementation ViewController...- (void)viewDidLoad {...    mController = [[DiscoveryController alloc] init];    [mController searchPlayerWithId : @\"amzn.thin.pl\" andListener : self];}- (void)resume {    [mController resume];}The debug logging is disabled by default. To enable the debug logging add the parameter andEnableLogs set to YES when calling searchPlayerWithId. Once the underlying framework is initialized, other operations such as player discovery and media playback and control are possible.When the controller app is to be suspended such as when the user locks the screen, your app must also suspend the underlying framework. Call DiscoveryController::close in the applicationWillResignActive lifecycle event of the UIApplicationDelegate implementation to suspend the underlying framework.@implementation AppDelegate...- (void) applicationWillResignActive:(UIApplication *)application {    id myViewController = [self findViewController];    [myViewController suspend];}...@implementation ViewController...- (void)suspend {    // Make sure that MediaPlayerStatusListener is removed before suspending.    if (mCurrentPlayer != nil) {        [mCurrentPlayer removeStatusListener:self]    }    [mController close];}Implementing Discovery CallbacksAs part of your app’s initialization, the component that creates the DiscoveryController instance should also specify the callback receiver. This object implements the DiscoveryListener interface. The object is passed to the underlying framework in the DiscoveryController::searchPlayerWithId call. Discovery is an ongoing process as long as the DiscoveryController object is live.@interface ViewController : UIViewController&lt;DiscoveryListener&gt;...@implementation ViewController...- (void)deviceDiscovered:(id&lt;RemoteMediaPlayer&gt;)device {    [mDevices addObject:device];    // Update UI}- (void)deviceLost:(id&lt;RemoteMediaPlayer&gt;)device {    [mDevices removeObject:device];    // Update UI}- (void)discoveryFailure {}The remote players are represented as RemoteMediaPlayer objects. Through this interface, your controller app can control the media playback on the remote player.Presenting Remote Players to the UserOnce the players in the vicinity are discovered, the controller app should present the friendly names of to the user.- (NSString *)pickerView:(UIPickerView *)pickerView             titleForRow:(NSInteger)row            forComponent:(NSInteger)component {    if (pickerView == devicePickerView ) {        if (row &lt; [mDevices count]) {            id&lt;RemoteMediaPlayer&gt; dev = [mDevices objectAtIndex:row];            return [dev name];        }    }    return nil;}Working with BFTaskBFTask is a class in the Bolts mobile development framework. Bolts makes it easier to work with asynchronous operations without blocking the UI thread. Our SDK for iOS uses Bolts to handle asynchronous tasks.A BFTask object represents the result of an asynchronous method. Using BFTask, you can wait for an asynchronous method to return a value, and then do something with that value after it has returned. When you are working with our SDK for iOS, it is important to remember that methods that return BFTask are asynchronous.Every BFTask has a method called continueWithBlock: that takes a continuation block. A continuation is a block that will be executed when the task is complete. In many cases, you only want to do more work if the previous task was successful, and propagate any errors to be dealt with later. To do this, use the continueWithSuccessBlock: method instead of continueWithBlock:. Note that you must return either BFTask or nil in every continueWithBlock: and continueWithSucessBlock:.For complete documentation on Bolts, see Bolts-iOS on GitHub. Clicking on this link will send you outside the Amazon Developer Portal.Connecting to and Disconnecting from a Remote PlayerAfter the user picks the player from the list of available players on Fire TV devices, your controller app is ready to interact with that remote player. To implement this interaction, the app needs to know the current player status and listen for changes to that status. Status updates are presented to the controller app in the form of callbacks.Your callback receiver implements the MediaPlayerStatusListener interface. This callback provides the current status of the player in an MediaPlayerStatus object. The current state is returned by the state selector, and the condition selector returns extra information about the state.@interface ViewController : UIViewController&lt;MediaPlayerStatusListener&gt;...@implementation ViewController...- (void)onStatusChange:(MediaPlayerStatus *)status positionChangedTo:(long long)position {    // Update UI with status}To receive the callbacks the app must add a status update listener object to the remote player object. Depending on the logic, the app should disconnect from the last player.-(void)connectToPlayer:(id&lt;RemoteMediaPlayer&gt;)device {    if (mCurrentPlayer == nil) {        mCurrentPlayer = device;    } else if (device != mCurrentPlayer) {        [[mCurrentPlayer removeStatusListener:self] continueWithBlock:^id(BFTask *task) {            if (task.error) {                // Indicate error            }            mCurrentPlayer = device;            return nil;        }];    }    [[mCurrentPlayer addStatusListener:self] continueWithBlock:^id(BFTask *task) {        if (task.error) {            // Indicate error        } else {            // UI update to show connection establishment        }        return nil;    }];}You should disconnect from the current player when the status updates are not needed.-(void)disconnectFromCurrentPlayer {    [[mCurrentPlayer removeStatusListener : self] continueWithBlock:^id(BFTask *task) {        if (task.error) {            // Indicate error        }        return nil;    }];}Controlling PlaybackOnce the player connection is established, your controller app can play and control media playback on that player. The RemoteMediaPlayer object provides local methods to control the playback and volume. All the control actions are asynchronous and your controller app should provide success and failure handler callbacks to each of the control methods if desired. Please note that these callbacks are not on the UI thread and the app must dispatch any UI updates on the main thread.Examples of control actions are below:- (void)playNewMedia : (NSString*)metadata : (NSString*)url {     [[mCurrentPlayer setMediaSourceToURL : url                                 metaData : metadata                                 autoPlay : YES // start playback immediately                      andPlayInBackground : NO  // play in foreground    ] continueWithBlock:^id(BFTask *task) {        if (task.error) {            // Indicate error        }        return nil;    }];}- (IBAction)goBack10s : (id)sender {    [[[mCurrentPlayer getPosition] continuteWithSuccessBlock:^id(BFTask *task) {        long long toPos = [task.result longlongValue];        toPos -= 10000;        if( toPos &lt; 0 ) {            toPos = 0;        }        return [mCurrentPlayer seekToPosition:toPos andMode:ABSOLUTE];    }] continueWithBlock:^id(BFTask *task) {        if (task.error) {            // Indicate error        }        return nil;    }];}Next StepsTo create a custom player for Fire TV, see Integrating Amazon Fling into your Fire TV Application.If you are modifying an existing Google Cast app on iOS to support flinging to Amazon Fire TV, see Integrating Amazon Fling with an Existing iOS Cast App.Please refer to Designing Amazon Fling UX for guidelines on how to design the user interface of your app.",
        "url": "integrating-amazon-fling-into-your-ios-app.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "integrating-amazon-fling-with-an-existing-android-cast-app-html": {
        "title": "Integrating Amazon Fling with an Existing Android App that Uses Google Cast",
        "tags": "[]",
        "content": "Using our SDK, you can talk to Amazon Fire TV devices in a similar manner as you use Google Cast in your app to talk to Chromecast devices.  This page outlines steps to modify an existing app that uses the Google Cast Companion Library to also fling to Amazon Fire TV.Before you start, make sure you follow the steps at Setting Up your Amazon Fling Development Environment for Android to include the required libraries in your project.   Note: All the code in this document is available in the CastWithFlingExample in the samples folder of our SDK package.  Modifying the Android Manifest  Initializing DiscoveryController  Converting Your Device Picker to use RemoteMediaPlayer  Monitoring the Status of the Player with StatusListener  Communicating With the Remote Media PlayerModifying the Android ManifestThe API included in our SDK requires some permissions to be added to your Android manifest (AndroidManifest.xml). After the &lt;manifest&gt; element, add the &lt;uses-permission&gt; elements. Some of these permissions may already be present as they may also be used by applications that use Google Cast.manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"[YOUR PACKAGE NAME]\"    android:versioncode=\"1\"    android:versionname=\"1.0\"&gt;&lt;!-- Android Network Access Permissions --&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\"/&gt;...&lt;/manifest&gt;```For Fire OS devices, also add the &lt;uses-library&gt; element so your application can communicate with the underlying framework on the device.```javaapplication    android:icon=\"@drawable/ic_launcher\"    android:label=\"@string/app_name\"    android:theme=\"@style/AppTheme\" &gt;    &lt;uses-library android:name=\"com.amazon.whisperplay.contracts\" /&gt;    ...&lt;/application&gt;Initializing DiscoveryControllerAmazon Fling service provides similar functionality to Google Cast’s VideoCastManager via different classes:  DiscoveryController, the interface used to discover remote Fire TV devices and players.  RemoteMediaPlayer, the interface that represents a player running on a remote Fire TV device. Use of this interface is described below in Converting Your Device Picker to use RemoteMediaPlayer.To use DiscoveryController, initialize it in your onCreate() method. Replace YourReceiverServiceID with your Amazon Fire TV player’s system ID (SID).private DiscoveryController mController;    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        mController = new DiscoveryController(this);        ...    }    @Override    protected void onResume() {        ...        mController.start(\"YourReceiverServiceID\", mDiscovery);        ...    }    @Override    protected void onPause() {        ...        mController.stop();        ...    }Converting Your Device Picker to use RemoteMediaPlayerThe device picker is the part of your app’s user interface that allows the user to view and pick available remote players. Your controller app uses the RemoteMediaPlayer interface for device discovery and selection through a custom device picker.Cast applications that use the MediaRouterButton class, as in the code below, must be replaced by a custom device picker.    @Override    public boolean onCreateOptionsMenu(Menu menu) {        ...        getMenuInflater().inflate(R.menu.main, menu);        mCastManager.addMediaRouterButton(menu, R.id.media_route_menu_item);        ...    }If your app implements a custom device picker like the code below you must modify that code to support RemoteMediaPlayer.    private MediaRouter mMediaRouter;    private List&lt;CastDevice&gt; mDeviceList = new LinkedList&lt;CastDevice&gt;();    private CastDevice mCurrentDevice;    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        mMediaRouter = MediaRouter.getInstance(this);        ...    }    @Override    protected void onResume() {        ...        mMediaRouter = MediaRouter.getInstance(this);        mMediaRouter.addCallback(mCastManager.getMediaRouteSelector(), mCastCallback,            MediaRouter.CALLBACK_FLAG_REQUEST_DISCOVERY);        ...    }    @Override    protected void onPause() {        ...        mMediaRouter.removeCallback(mCastCallback);    }    private MediaRouter.Callback mCastCallback = new MediaRouter.Callback() {        public void onRouteAdded(android.support.v7.media.MediaRouter router,            android.support.v7.media.MediaRouter.RouteInfo route) {            CastDevice device = CastDevice.getFromBundle(route.getExtras());            if (mDeviceList.contains(device)) {                mDeviceList.remove(device);                ...            } else {                ...            }            mDeviceList.add(device);            triggerUpdate();        }        public void onRouteRemoved(android.support.v7.media.MediaRouter router,            android.support.v7.media.MediaRouter.RouteInfo route) {            CastDevice device = CastDevice.getFromBundle(route.getExtras());            if( mDeviceList.contains(device) ) {                ...                mDeviceList.remove(device);                triggerUpdate();            }        }    };This example uses a list of of RemoteMediaPlayer objects to keep track of the currently selected player device in a list view. The IDiscoveryListener interface is used to listen for when a new player device becomes available or an existing player device is no longer available. The listener is added when starting your controller app in the onResume() method.    private List&lt;RemoteMediaPlayer&gt; mDeviceList = new LinkedList&lt;RemoteMediaPlayer&gt;();    private RemoteMediaPlayer mCurrentDevice;    private DiscoveryController.IDiscoveryListener mDiscovery = new DiscoveryController.IDiscoveryListener() {        @Override        public void playerDiscovered(RemoteMediaPlayer device) {            if (mDeviceList.contains(device)) {                mDeviceList.remove(device);                ...            } else {                ...            }            mDeviceList.add(device);            triggerUpdate();        }        @Override        public void playerLost(RemoteMediaPlayer device) {            if( mDeviceList.contains(device) ) {                ...                mDeviceList.remove(device);                triggerUpdate();                ...            }        }        @Override        public void discoveryFailure() {            ...        }    }The device picker list is updated in the following method that handles device objects from both Google Cast and this SDK.    void triggerUpdate() {        runOnUiThread(new Runnable() {            @Override            public void run() {                final ListView lv = (ListView) findViewById(R.id.listView1);                ArrayAdapter&lt;Object&gt; ad = (ArrayAdapter&lt;Object&gt;) lv.getAdapter();                ad.notifyDataSetChanged();            }        });    }Monitoring the Status of the Player with StatusListenerGoogle Cast provides callbacks to manage application status changes. The Google Cast Companion Library also keeps track of some statuses such as the current media position through the VideoCastConsumerImpl class. Our API provides the StatusListener class to receive status updates based on a given interval. The StatusListener class provides the same functionality as VideoCastConsumerImpl. Add the status listener to your controller app to receive status updates, and set the interval for updates when your status listener is successfully added.The addStatusListener() and setPositionUpdateInterval() methods, as with all remote methods in the API, are asynchronous calls. The API gives the result from these asynchronous calls by providing FutureListener&lt;T&gt;. Chain the getAsync() method with remote methods to get the result. Once the asynchronous task is done, the remote method call invokes the futureIsNow() method from the receiver app.    private StatusListener mListener;    private Status mStatus = new Status();    private static final long MONITOR_INTERVAL = 1000L;    private DiscoveryController.IDiscoveryListener mDiscovery = new DiscoveryController.IDiscoveryListener() {        @Override        public void playerLost(RemoteMediaPlayer device) {            ...            device.removeStatusListener(mListener).getAsync(new FutureListener&lt;Void&gt; {                @Override                public void futureIsNow(Future&lt;Void&gt; voidFuture) {                    //handle asynchronous task                }            });        }    };    @Override    protected void onResume() {        ...        mListener = new Monitor();        ...    }    private static class Status {        public long mPosition;        public MediaState mState;        public MediaCondition mCond;        public synchronized void clear() {            mPosition = -1L;            mState = MediaState.NoSource;        }    }    private class Monitor implements StatusListener {        @SuppressLint(\"NewApi\")        @Override        public void onStatusChange(AmazonMediaStatus status, long position) {            if (mCurrentDevice != null) {                synchronized (mStatus) {                    mStatus.mState = status.getState();                    mStatus.mCond = status.getCondition();                    mStatus.mPosition = position;                    ...                }                ...            }        }    }    ...    private void fling(final Object target, final String name, final String title) {        mCurrentDevice = target;\tmCurrentDevice.addStatusListener(mListener).getAsync(new ErrorResultHandler(\"Cannot set status listener\"));        mCurrentDevice.setPositionUpdateInterval(MONITOR_INTERVAL).getAsync(            new ErrorResultHandler(\"Error attempting set update interval, ignoring”));        mCurrentDevice.setMediaSource(name, title, true, false).getAsync(new ErrorResultHandler(\"Error attempting to Play”));    }    private class ErrorResultHandler implements FutureListener&lt;Void&gt;  {        ErrorResultHandler(String msg) {\t    this(msg, false);        }        @Override        public void futureIsNow(Future&lt;Void&gt; result) {            try {                result.get();            } catch(ExecutionException e) {              //handleFailure            } catch(Exception e) {              //handleFailure            }        }    }Communicating With the Remote Media PlayerThe Google Cast Companion Library provides only the callbacks in VideoCastConsumerImpl to indicate when a remote call is finished.  Some actions your application performs do not provide a direct callback once the remote player has performed the specified action:mCastManager.loadMedia(selectedMedia, true, 0);mCastManager.play();mCastManager.pause();mCastManager.stop();mCastManager.seekAndPlay((int)position);Our SDK provides the option to use listeners when communicating with the remote device, as in the previous section.  This allows you to monitor the result of the call and to handle failure and success situations differently, or with a common failure handler like the one in this example:private void handleFailure( Throwable throwable, final String msg, final boolean extend ) {    Log.e(TAG, msg, throwable);    final String exceptionMessage = throwable.getMessage();    FlingActivity.this.runOnUiThread(new Runnable() {        public void run() {            Toast.makeText(FlingActivity.this, msg+(extend?exceptionMessage:\"\"), Toast.LENGTH_LONG).show();        }    });}private class ErrorResultHandler  implements FutureListener&lt;Void&gt; {    private String mMsg;    private boolean mExtend;    ErrorResultHandler(String msg) {        this(msg, false);    }    ErrorResultHandler(String msg, Boolean extend) {        mMsg = msg;        mExtend = extend;    }    @Override    public void futureIsNow(Future&lt;Void&gt; result) {        try {            result.get();        } catch(ExecutionException e) {            handleFailure(e.getCause(), mMsg, mExtend);        } catch(Exception e) {            handleFailure(e, mMsg, mExtend);        }    }}...mCurrentDevice.stop(new ErrorResultHandler(\"Error Stopping\"));...Or maybe not even handle the asynchronous result at all.mCurrentDevice.setPositionUpdateInterval(MONITOR_INTERVAL, null);mCurrentDevice.setMediaSource(name, title, true, false, null);mCurrentDevice.play(null);mCurrentDevice.pause(null);mCurrentDevice.stop(null);mCurrentDevice.seek(null);",
        "url": "integrating-amazon-fling-with-an-existing-android-cast-app.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "integrating-amazon-fling-with-an-existing-ios-cast-app-html": {
        "title": "Integrating Amazon Fling with an Existing iOS App that uses Google Cast",
        "tags": "[]",
        "content": "Using our SDK, you can talk to Amazon Fire TV devices in a similar manner as you use Google Cast in your iOS apps to talk to Chromecast devices.  This page outlines steps to modify an existing iOS app that uses the Google Cast framework to also fling to Amazon Fire TV.Before you start, make sure you follow the steps at Setting Up your Amazon Fling Development Environment for iOS to include the required frameworks in your project.   Note: All the code in this document is available in the CastHelloVideo-ios-master in the samples folder of the SDK package. This page calls out important code changes you need to make to an app that currently uses Google Cast.Setup and InitializationTo add this functionality in an app that currently uses Google Cast, add the required headers, and add listeners for player discovery and media status.#import &lt;UIKit/UIKit.h&gt;#import &lt;GoogleCast/GoogleCast.h&gt;#import &lt;AmazonFling/DiscoveryController.h&gt;#import &lt;AmazonFling/RemoteMediaPlayer.h&gt;#import &lt;AmazonFling/MediaPlayerStatus.h&gt;@interface HGCVViewController : UIViewController&lt;GCKDeviceScannerListener,                                                 GCKDeviceManagerDelegate,                                                 GCKMediaControlChannelDelegate,                                                 UIActionSheetDelegate,                                                 DiscoveryListener,                                                 MediaPlayerStatusListener&gt;Start the discovery process when the application or view is loaded for the first time.- (void)viewDidLoad {    [super viewDidLoad];    ...    // Initialize AmazonFling    self.controller = [[DiscoveryController alloc] init];    [self.controller searchPlayerWithId:@\"amzn.thin.pl\" andListener:self];    self.devices = [[NSMutableArray alloc] init];Your app receives the results of device discovery in overloaded callbacks.- (void)deviceDiscovered:(id&lt;RemoteMediaPlayer&gt;)device {    NSLog(@\"deviceDiscovered=%@\", [device name]);    [self.devices addObject:device];    dispatch_async(dispatch_get_main_queue(), ^{        [self updateButtonStates];    });}- (void)deviceLost:(id&lt;RemoteMediaPlayer&gt;)device {    NSLog(@\"deviceLost=%@\", [device name]);    [self.devices removeObject:device];    dispatch_async(dispatch_get_main_queue(), ^{        [self updateButtonStates];    });}- (void)discoveryFailure {    NSLog(@\"Discovery failure\");}Your app gets media playback status in another callback:- (void)onStatusChange:(MediaPlayerStatus *)status positionChangedTo:(long long)position {    NSLog(@\"Applciation: onStatusChange Called\");}Lifecycle Event HandlingYour app should suspend device discovery when the app goes into the background, and resume when it comes to foreground:- (void)viewDidAppear:(BOOL)animated {    [super viewDidAppear:animated];    NSLog(@\"viewDidAppear\");    [self.controller resume];}- (void)viewWillDisappear:(BOOL)animated {    [super viewWillDisappear:animated];    NSLog(@\"viewWillDisappear\");    [self.devices removeAllObjects];    [self.controller close];}Presenting Amazon Fire TV Devices to the UserYou can get a list of the names of the remote Amazon Fire TV devices and present those names to the user with the RemoteMediaPlayer proxy object:- (void)chooseDevice:(id)sender {...    UIActionSheet *sheet =        [[UIActionSheet alloc] initWithTitle:NSLocalizedString(@\"Connect to Device\", nil)                                    delegate:self                           cancelButtonTitle:nil                      destructiveButtonTitle:nil                           otherButtonTitles:nil];      for (id&lt;RemoteMediaPlayer&gt; device in self.devices) {          [sheet addButtonWithTitle:[device name]];      }Connect to the PlayerTo connect your app to a player, add a status listener.- (void)connectToFlingDevice {    if (self.selectedFlingPlayer == nil)        return;    __weak HGCVViewController *selfWeak = self;    [self.selectedFlingPlayer addStatusListener:self :^(NSException *failure) {        NSLog(@\"Failed to add status listener.  Error:%@\", failure.reason);    } : ^{        dispatch_async(dispatch_get_main_queue(), ^{            selfWeak.isConnectedToFlingPlayer = YES;            [selfWeak updateButtonStates];        });    }];}Get Media Playback Status on Remote DeviceOnce your app is connected to a remote player it can perform remote operations, such as fetch the media playback status. Communication with the Amazon Fire TV occurs through RemoteMediaPlayer proxy object. Since the SDK provides asynchronous methods for fluid UI, you may have to use serializing mechanisms in place of the Google Cast API calling paradigms you had previously been using.- (NSInteger)flingPlaybackStatus : (UIActionSheet*) sheet {    NSString *friendlyName = [NSString stringWithFormat:NSLocalizedString(@\"Casting to %@\", nil),                              [self.selectedFlingPlayer name]];    sheet.title = friendlyName;    __block NSString* mediaStatus = nil;    NSCondition *waitHandle = [NSCondition new];    [waitHandle lock];    [self.selectedFlingPlayer getStatus:^(NSException *failure) {        NSLog(@\"Failed to get status.  Error:%@\", failure.reason);        [waitHandle signal];    } :^(MediaPlayerStatus *result) {        mediaStatus = [NSString stringWithString:[self mapState:[result getState]]];        [waitHandle signal];    }];    [waitHandle wait];    if (mediaStatus != nil) {        [sheet addButtonWithTitle:mediaStatus];    }    return mediaStatus == nil ? 0 : 1;}Flinging Media to the PlayerIf the selected device is a player, the controller application can set the media playback source and metadata:- (void)flingLoadMedia {    [[self.selectedFlingPlayer setMediaSourceToURL:@\"http://videos.acme.com/url_to_video\"                                         metaData:@\"{\\\"title\\\" : \\\"Big Buck Bunny (2008)\\\"}\" // meta data in JSON format                                         autoPlay:YES  // auto-play                              andPlayInBackground:NO   // play in background    ] continueWithBlock:^id(BFTask *task) {        if (task.error) {            NSLog(@\"Failure to set media source - %@\", task.error);        }        return nil;    }];",
        "url": "integrating-amazon-fling-with-an-existing-ios-cast-app.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "integrating-amazon-fling-with-cast-html": {
        "title": "Integrating Amazon Fling with Apps that Use Google Cast",
        "tags": "[]",
        "content": "You can use this SDK to talk to Fire TV devices in a way that is similar to the way apps that use Google Cast can talk to Chromecast devices.  iOS  AndroidiOSThe following documents will guide you through the process of modifying an iOS app that currently uses Google Cast to also fling to Amazon Fire TV:  Integrating Amazon Fling with an Existing iOS Cast AppAndroidThe following documents will guide you through the process of modifying an Android app that currently uses Google Cast to also fling to Amazon Fire TV:  Integrating Amazon Fling with an Existing Android Cast App",
        "url": "integrating-amazon-fling-with-cast.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "ios-remote-install-html": {
        "title": "Integrating Remote Install into Your iOS App",
        "tags": "[]",
        "content": "This service provides an asynchronous discovery and control mechanism for your iOS app in the form of a framework. See Understanding the Amazon Fling Service for a high-level overview of the features and functions this service provides. See also the remote install sample app, part of the SDK, for a sample implementation for iOS.Before you start, make sure you’ve set up your development environment. See Setting Up your Amazon Fling Development Environment for iOS  for details.  Integration Overview  Initializing and Suspending the App  Implementing Discovery Callbacks  Presenting the Remote Install Service to the User  Working with BFTask  InstallingIntegration OverviewThere are three steps for creating or modifying your controller mobile app to support Remote Install:  Initializing underlying framework and discovering available Fire TV devices.  For a selected Fire TV device, add logic to check if your app is installed on it.  Add UI flow to allow the user to initiate install of your Fire TV app. Initializing and Suspending the AppWhen your iOS app loads, for example in the ViewController::viewDidLoad method, call InstallDiscoveryController::searchInstallServiceWithListener to initialize the underlying framework and start discovery. Call InstallDiscoveryController::resume every time the app comes to the foreground, that is, in the applicationDidBecomeActive lifecycle event of the UIApplicationDelegate implementation.@implementation AppDelegate...- (void)applicationDidBecomeActive:(UIApplication *)application {    id myViewController = [self findViewController];    [myViewController resume];}...@implementation ViewController...- (void)viewDidLoad {...    mController = [[InstallDiscoveryController alloc] init];    [mController searchInstallServiceWithListener : self];}- (void)resume {    [mController resume];}The debug logging is disabled by default. To enable the debug logging add the parameter andEnableLogs set to YES when calling searchInstallServiceWithListener. Once the underlying framework is initialized, other operations such as install service discovery are possible.When the controller app is to be suspended such as when the user locks the screen, your app must also suspend the underlying framework. Call InstallDiscoveryController::close in the applicationWillResignActive lifecycle event of the UIApplicationDelegate implementation to suspend the underlying framework.@implementation AppDelegate...- (void) applicationWillResignActive:(UIApplication *)application {    id myViewController = [self findViewController];    [myViewController suspend];}...@implementation ViewController...- (void)suspend {    [mController close];}Implementing Discovery CallbacksAs part of your app’s initialization, the component that creates the InstallDiscoveryController instance should also specify the callback receiver. This object implements the InstallDiscoveryListener interface. The object is passed to the underlying framework in the InstallDiscoveryController::searchInstallServiceWithListener call. Discovery is an ongoing process as long as the InstallDiscoveryController object is live.@interface ViewController : UIViewController&lt;InstallDiscoveryListener&gt;...@implementation ViewController...- (void)installServiceDiscovered:(id&lt;RemoteInstallService&gt;)device {    [mDevices addObject:device];    // Update UI}- (void)installServiceLost:(id&lt;RemoteInstallService&gt;)device {    [mDevices removeObject:device];    // Update UI}- (void)discoveryFailure {}The remote install services are represented as RemoteInstallService objects. Through this interface, your app can install applications on the remote device.Presenting the Remote Install Service to the UserOnce the players in the vicinity are discovered, the controller app should present the friendly names of to the user.- (NSString *)pickerView:(UIPickerView *)pickerView             titleForRow:(NSInteger)row            forComponent:(NSInteger)component {    if (pickerView == devicePickerView ) {        if (row &lt; [mDevices count]) {            id&lt;RemoteInstallService&gt; dev = [mDevices objectAtIndex:row];            return [dev name];        }    }    return nil;}Working with BFTaskBFTask is a class in the Bolts mobile development framework. Bolts makes it easier to work with asynchronous operations without blocking the UI thread. Our SDK for iOS uses Bolts to handle asynchronous tasks.A BFTask object represents the result of an asynchronous method. Using BFTask, you can wait for an asynchronous method to return a value, and then do something with that value after it has returned. When you are working with our SDK for iOS, it is important to remember that methods that return BFTask are asynchronous.Every BFTask has a method called continueWithBlock: that takes a continuation block. A continuation is a block that will be executed when the task is complete. In many cases, you only want to do more work if the previous task was successful, and propagate any errors to be dealt with later. To do this, use the continueWithSuccessBlock: method instead of continueWithBlock:. Note that you must return either BFTask or nil in every continueWithBlock: and continueWithSucessBlock:.For complete documentation on Bolts, see Bolts-iOS on GitHub. Clicking on this link will send you outside the Amazon Developer Portal.InstallingOnce the install service is discovered, your app can install applications on that device. The RemoteInstallService object provides local methods to check the version of an installed app or install an app. All the control actions are asynchronous and your app should provide success and failure handler callbacks to each of the control methods if desired. Please note that these callbacks are not on the UI thread and the app must dispatch any UI updates on the main thread.Your app can check if the desired application is installed on the selected Amazon Fire TV by calling getInstalledPackageVersion API. If the app is not installed, RIS_PACKAGE_NOT_INSTALLED string will be returned. Once your app has called the installByASIN method the Fire TV will launch the Appstore page associated with that ASIN (Amazon Standard Identification Number).The user will then need to finish the installation with the a Fire TV remote. If the ASIN is invalid the Fire TV will show an error popup. The ASIN of an application can be found on its product information page on amazon.com under the Product Details section. Some applications could have different products for different regions and therefore could have multiple ASINs.Examples of control actions are below:- (void)logInstalledVersion : (NSString*)packageName {    BFTask task = [mCurrentInstallService getInstalledPackageVersion : packageName];    [task waitUntilFinished];    if (task.error == nil) {        if ([(NSString*)task.result compare : RIS_PACKAGE_NOT_INSTALLED] == 0) {            NSLog(@\"Package not installed\");        } else {            NSLog(@\"Received version is %@\", (NSString*)task.result);        }    } else {        // Indicate error    }}- (void)installPackage : (NSString*)asin {    BFTask* task = [mCurrentInstallService installByASIN : asin];    [task waitUntilFinished];    if (task.error != nil) {        // Indicate error    }}",
        "url": "ios-remote-install.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "remote-install-html": {
        "title": "Remote Install",
        "tags": "[]",
        "content": "Remote Install allows you to discover Fire TV devices on the same network. Once a Fire TV is discovered from a user’s mobile device or tablet, you can check if your application is installed on that Fire TV and prompt the user to also install the Fire TV version of your app or game.Remote installation is important for developers looking to increase the user base of their cross platform apps. By leveraging Remote Discovery’s ability to run on iOS and Android devices, you gain a new way to drive user acquisition for your Fire TV products. Conveniently, you can simply add Remote Install to your existing app or game without the need of fully implementing the rest of the Amazon Fling SDK’s APIs. Let’s take a look at what you need to know for getting it up and running.  Implementing Remote Install  iOS  AndroidImplementing Remote InstallThere are only a few steps for creating or modifying your controller mobile app to support Remote Install:  (Android only) Modifying your Android manifest to include network permissions.  Initializing underlying framework and discovering available players on Fire TV devices.  For a selected Fire TV device, add logic to check if your app is installed on it.  Add UI flow to allow the user to initiate install of your Fire TV app.Once your app discovers Fire TV devices running the Remote Install service, your app gets an object that implements the RemoteInstallService interface. You can then use the RemoteInstallService object to install an app or check the version of an app on the Fire TV device.You can check the version of your app using the getInstalledPackageVersion API. Once your app has called the installByProductId method, the Fire TV will launch the Appstore page associated with the provided ASIN (Amazon Standard Identification Number). The user will then need to finish the installation with a Fire TV remote. The need to use the remote to complete the purchase provides the user control of the process. If the ASIN is invalid the Fire TV will show an error popup.iOSThe following documents will guide you through the process for iOS apps:  Integrating Remote Install into Your iOS AppAndroidThe following documents will guide you through the process for Android apps:  Integrating Remote Install into Your Android App",
        "url": "remote-install.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "setting-up-your-amazon-fling-development-environment-for-android-html": {
        "title": "Setting Up Your Amazon Fling Development Environment for Android",
        "tags": "[]",
        "content": "To enable this functionality in your app, you have to integrate our SDK in your development environment. This document describes how to set up your Android Studio projects to include the SDK. Before you start, install the following software packages on your development computer:  Java Development Kit  Android Studio Note: The Android SDK, Android Studio, the Java Development Kit, and certain other development tools are provided by third parties, not by Amazon. Our links for these tools will take you to third-party sites for download and installation of the tools.  Setting up Android Studio          Adding the Amazon Fling Libraries      Adding Additional Libraries (Generic Android Only)        Next StepsSetting up Android StudioTo use our SDK with your Android Studio project, add the JAR file included in the SDK package as a file dependency. Use these steps to set up your Android Studio environment. If you are developing an app for an Android platform that does not run Fire OS, there are additional libraries to add as well.Adding the Amazon Fling Libraries  In Android Studio, create a new project or open an existing one.      Copy the AmazonFling.jar file from the Amazon Fling library package into the libs folder for your project.        Right-click on your project’s root folder and select Open Module Settings to open the project folder.  From the Module tab in Project Structure, select the Dependencies tab.      Click the + button and select the File dependency option. Then, select AmazonFling.jar in the project libs folder.            Under the Dependencies tab check the library scope and make sure it is set as Compile.        Click OK.Adding Additional Libraries (Generic Android Only)If you are developing an app that runs on generic Android devices (not Fire OS devices), use these steps to add additional libraries to your project:      Copy the WhisperPlay.jar file in the /lib/Android/ folder in the Amazon Fling SDK package to the libs folder in your project.    Right-click on your project’s root folder and choose Open Module Settings to open the project folder.  From the Module tab in Project Structure, select the Dependencies tab.  Click the + button and select the File dependency option. Then, select the Whisperplay.jar file in the project libs folder.      Under the Dependencies tab check the library scope and make sure it is set as Compile.        Click OK.Next StepsTo integrate Amazon Fling into your app, see Integrating Amazon Fling into your Android App.If your Android app supports the Google Cast API and you want to use Fling as well, see Integrating Amazon Fling with an Existing Android Cast App.If your app uses Android MediaRouter, see Using Amazon Fling with Android MediaRouter.",
        "url": "setting-up-your-amazon-fling-development-environment-for-android.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "setting-up-your-amazon-fling-development-environment-for-ios-html": {
        "title": "Setting Up your Amazon Fling Development Environment for iOS",
        "tags": "[]",
        "content": "Our SDK for iOS is distributed as an iOS framework which can be linked to your iOS controller app. This document describes how to set up your iOS projects to include these libraries.  System Requirements  Supported Configurations  Download and Install  Setting up Xcode  Next StepsSystem Requirements  MacOS X  Xcode 6+Supported Configurations  iOS build architecture: armv7, arm64, i386, and x86_64  Player discovery: Local network players onlyDownload and Install  Download the Fling SDK from the Amazon developer portal.  Extract contents.Setting up XcodeTo include the iOS framework in your iOS controller app project, choose Project &gt; Add to Project and select the framework directory. Alternatively, you can drag and drop the AmazonFling.framework from the Finder to your app project.When you add an existing framework to your project, Xcode asks you to associate it with one or more targets in your project. Once associated, Xcode automatically links the framework against the resulting executable.You must also add the following system frameworks and libraries to the “Link Binaries” phase of the target in order to build a controller app:  Bolts.framework  CFNetwork.framework  Security.framework  SystemConfiguration.framework Note: Bolts.framework can be found in the /third_party_framework folder inside of the AmazonFling iOS SDK package.In your project’s settings, add the following to “Other Linker Flags”: -lc++Include the required header files in your code using the #include directive. If you are working in Objective-C, you may use the #import directive instead of the #include directive. The two directives have the same results, but the #import directive guarantees that the same header file is never included more than once.#import &lt;AmazonFling/DiscoveryController.h&gt;#import &lt;AmazonFling/MediaPlayerStatus.h&gt;#import &lt;AmazonFling/RemoteMediaPlayer.h&gt;#import &lt;Bolts/BFTask.h&gt;Next StepsTo develop an iOS controller app, see Integrating Amazon Fling into your iOS App.",
        "url": "setting-up-your-amazon-fling-development-environment-for-ios.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "understanding-the-amazon-fling-service-html": {
        "title": "Understanding the Amazon Fling Service",
        "tags": "[]",
        "content": "Amazon Fling is a second-screen service that enables your customers to send media and web content from Fire OS, iOS, and Android mobile devices to Amazon Fire TV devices for display and playback. This document contains an overview of this service and how you can integrate this functionality into your apps.You can download the Fling SDK from the SDK Downloads page.  What Is Amazon Fling?  What Can I Do With the SDK?          Discover Fire TV from your Controller App      Control Playback from your Controller App      Customize Playback for your Fire TV Player App         Next StepsWhat Is Amazon Fling?Amazon Fling is a service on the Amazon Fire TV platform that allows customers to send media and web content to Fire TV from their mobile devices. We provide you with an API that your app can use to communicate with this service. You have to implement the API in your mobile app to create a controller, which enables that app to discover Fire TV devices on the network, and provides the mechanisms to play media content such as video, audio, or photos.On Fire TV, adding support for this API to your Fire TV playback app enables you to handle remote playback events. A Fire TV app that supports this functionality is called a player.The controller service provides these features:  Set the source URL of the media to be rendered.  Get information about that media such as duration, current position, and metadata.  Discover Fire TV devices on the network that support this functionality.  Control media playback (play, pause, stop, seek).  Get the playback status, immediately or with callbacks.  Send custom commands to the Fire TV receiver app for playback.To create a controller app see the guide on Flinging From Fire OS or Android or Flinging From iOS.To integrate remote install into your app see the guide on Remote Install With Fire OS and Android or Remote Install With iOS.When implementing a controller you should follow the UX Guidelines. To integrate the controller with an existing Google Cast application see the guide on Flinging From Cast Apps. To integrate with an existing Android Media Router app see the guide on Flinging From Media Router.To create a player app see the guide on Creating a Player App. The service enables you to completely customize the playback user experience.A Built-In Media Receiver is available for controllers that do not require a customized player.Unity plugins are also available for integration. See Unity Controller Plugin and Unity Player Plugin for more details.In our SDK, we provide a JAR file for Fire OS and Android, and a Framework for iOS.  For details on the APIs see the Android API Docs and the iOS API Docs.The underlying framework of this feature enables apps to find and communicate with Amazon Fire TV devices to render media content sent by that app. With our SDK, you can focus on great user experience in your app while the underlying framework handles network technology, discovery, versioning, and so on.What Can I Do With the SDK?With this SDK, you can do the following:  Discover Fire TV devices from your controller app on a mobile device.  Control playback of the content sent from your controller app.  Customize the user experience of your Fire TV player app.Discover Fire TV from your Controller AppThis SDK enables your controller app on a mobile device (iOS/Android/Fire OS) to find Amazon Fire TV devices available on the same network. The controller asks the underlying framework to discover all the devices with a particular system ID (SID). If the SID is not specified, the SDK discovers all Fire TV devices and communicates with the built-in media receiver.The SDK returns a list of Fire TVs. Each Fire TV has a friendly name (for example, “John’s 2nd Fire TV”), which the app presents to the customer. The customer picks the right Fire TV to fling to by that name.Control Playback from your Controller AppThe SDK allows the controller application to send control commands to the discovered Fire TV. The application can then control the Fire TV as if it is calling methods on the local object returned from the Fire TV discovery process. The controller app can set the source of the content to be rendered on the player, as well as monitor and control the rendering of that content.Customize Playback for your Fire TV Player App To provide a custom user experience, you can develop or enhance a media player application for Fire TV and add support for this SDK. The service defined by your Fire TV player app will automatically be started when a controller begins communicating with it and your player app will communicate with controller apps through your implementation that uses our SDK.Next StepsTo get started working with this API and to start developing controller and player apps, see the appropriate document for your development platform:   Setting Up Your Amazon Fling Development Environment for Android  Setting Up Your Amazon Fling Development Environment for iOSFor any additional questions check the FAQ or the Forum.",
        "url": "understanding-the-amazon-fling-service.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "unity-controller-plugin-html": {
        "title": "Integrating the Amazon Fling Controller In Your Games",
        "tags": "[]",
        "content": "This page will walk you through the steps of setting up your Unity project to include the Amazon Fling Controller Unity plugin. It will also provide instruction on how to use the plugin and additional steps for building for iOS, Android, and Fire OS. For additional information see the FlingSampleApp in the samples folder of the plugins SDK.  Import the Unity Package  Initialize  Method Calls          Synchronized Methods      ASynchronized Methods        Handling Events  Additional Steps for iOS Deployment  Additional Step for Android Deployment  Additional Step for Fire OS DeploymentImport the Unity PackageWhen you import the Amazon Fling Unity package, Unity will override existing files in your project with those in the package. Before importing the Unity package, review the list of included files and compare this list with your current project to check for overlap. If a file exists in both your project and the package, verify that any changes you have made locally are backed up somewhere outside of your project. After you import the package, use your favorite file merging software to compare and merge the differences between the file in the package and the file you had backed up locally.  In Unity, click Assets, click Import Package, and then click Custom Package…  Select the plugin package.  Import the Unity Package.InitializeInitialize the service using the service ID of the service you would like to communicate with on the Fire TV. To communicate with the default media receiver, leave the service ID as null.IAmazonFlingService flingService;flingService = AmazonFlingServiceImpl.Instance;Method CallsSynchronized and ASynchronized methods are used to interact with the library. Since some methods make a call over a network ASync methods are provided to allow the application to continue processing while it is waiting for a response. To initiate a method call, you must perform the following general steps:  If needed, construct the object used to pass input to the operation.  For asynchronous operations, define a callback function that is invoked when a response is ready.  Call the operation, passing in any required input and/or callback function as arguments.Synchronized MethodsUsage ExamplePlayerServiceId serviceId = new PlayerServiceId();serviceId.Id = null;flingService.StartDiscovery (serviceId);            Method      Summary                  void StartDiscovery(PlayerServiceId playerServiceId)      Begins searching for players hosting a service with a service Id matching playerServiceId.Id. playerServiceId.Id can be left as null to search for the default media player.              void StopDiscovery()       Stops searching for devices.      ASynchronized MethodsUsage Exampleprivate void GetDurationCallback(LongResult longResult) {}private void FlingCallbackError(AmazonException e) {}flingService.GetDuration(selectedPlayer, GetDurationCallback, FlingCallbackError);            Method      Summary                  VoidResult SetVolume(SetVolumeParameters setVolumeParameters)      Sets the volume on the player. Note: the default media player does not implement this API.              void IsMute(Player player, BooleanResult booleanResultDelegate, AmazonExceptionDelegate errorDelegate)      Gets the mute status of the player.              void SetMute(MuteParameters, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Sets the mute status of the player. Note: the default media player does not implement this API.              void GetPosition(Player player, LongResult longResultDelegate, AmazonExceptionDelegate errorDelegate)      Returns the position of the media on the player.              void GetDuration(Player player, LongResult longResultDelegate, AmazonExceptionDelegate errorDelegate)      Returns the duration of the media on the player.              void GetStatus(Player player, Status statusDelegate, AmazonExceptionDelegate errorDelegate)      Gets the status of the player.              void IsMimeTypeSupported(IsMimeTypeSupportedParameters isMimeTypeSupportedParameters, BooleanResult booleanResultDelegate, AmazonExceptionDelegate errorDelegate)      Returns a Boolean indicating if the mime type is supported.              void Pause(Player player, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Pauses the media the player.              void Play(Player player, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Plays the media on the player.              void Stop(Player player, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Stops the media on the player.              void Seek(PlayerSeekParameters playerSeekParameters, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Seeks to the desired position on the player.              void SetMediaSource (SetMediaSourceParameters setMediaSourceParameters, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Sets the URL, and MetaData on the player. Also has options to auto play the media when set and play in background.              void SetPlayerStyle(SetPlayerStyleParameters setPlayerStyleParameters, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Sets the style of the media player on the device. Note: the default media player does not implement this API.              void AddStatusListener(Player player, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Adds a listener to the player that will allow it to trigger the OnStatusChanged event.              void RemoveStatusListener(Player player, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Removes the listener to the player.              void SetPositionUpdateInterval(SetPositionUpdateIntervalParameters setPositionUpdateIntervalParameters, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Sets the interval that dictates the amount of time between OnStatusChanged event calls.              void SendCommand(SendCommandParameters sendCommandParameters, VoidResult voidResultDelegate, AmazonExceptionDelegate errorDelegate)      Sends a command to the player. Note: the default media player does not implement this API.              void GetMediaInfo(Player player, PlayerInfo playerInfoDelegate, AmazonExceptionDelegate errorDelegate)      Gets the media info from the player.      Handling EventsTo handle an event, you must perform the following steps:  Define an event handler.  Register your event handler with an event listener.Example:private void PlayerDiscovered(Player args){}flingService.AddPlayerDiscoveredListener(PlayerDiscovered);            Method      Summary                  void AddPlayerDiscoveredListener(PlayerDiscoveredDelegate responseDelegate)      Registers the delegate with the service to be called when a player device is discovered. Returns a player representing a device hosting an Amazon Fling service as a parameter.              void AddPlayerLostListener(PlayerLostDelegate responseDelegate)      Registers the delegate with the service to be called when a player device is no longer available. Returns the player that is no longer available as a parameter.              void AddDiscoveryFailureListener (DiscoveryFailureDelegate responseDelegate)      Registers the delegate with the service to be called when a failure occurs during discovery.              void AddOnStatusChangedListener(OnStatusChangedDelegate responseDelegate)      Registers the delegate with the service to be called when a player has updated status information. Requires you to register a listener with that device using the AddStatusListener method. Returns the player, position and status as a parameter.      Additional Steps for iOS DeploymentAdd Plugin SDK Frameworks to Your Exported iOS Xcode Project:  In Xcode, select your Xcode project root.  Select the target Unity-iPhone.  Click the Build Phases tab.  Open the Link Binary with Libraries foldout.  Click the + at the bottom of this foldout.  Add all frameworks and libraries required by SDK          AmazonFling.framework (located in the framework directory of the SDK)      Bolts.framework (located in the framework directory of the SDK)      AdSupport.framework      Security.framework      Libc++.dylib        Follow iOS SDK’s specific guidelines for importing dependenciesAdditional Step for Android DeploymentThe plugin needs access permissions to communicate over the net, and the below permissions are required to be added to your AndroidManifest.xml:  android.permission.INTERNET: Allows applications to open network sockets.  android.permission.ACCESS_WIFI_STATE: Allows applications to access information about Wi-Fi networks.  android.permission.ACCESS_NETWORK_STATE: Allows applications to access information about networks.  android.permission.CHANGE_WIFI_MULTICAST_STATE: Allows applications to enter Wi-Fi Multicast mode. These permissions can be added manually or by renaming the Plugins/Android/AmazonFlingServiceSampleAndroidManifest.xml file to AndroidManifest.xml.Additional Step for Fire OS DeploymentThe plugin needs access permissions to communicate over the net, and the below permissions are required to be added to your AndroidManifest.xml:  android.permission.INTERNET: Allows applications to open network sockets.  android.permission.ACCESS_WIFI_STATE: Allows applications to access information about Wi-Fi networks.  android.permission.ACCESS_NETWORK_STATE: Allows applications to access information about networks. These permissions can be added manually by creating a Plugins/Android/AndroidManifest.xml file or by renaming and modifying the Plugins/Android/AmazonFlingServiceSampleAndroidManifest.xml file.Remove the Plugins/Android/WhisperPlay.jar and add the following line to the Plugins/Android/AndroidManifest.xml in the application section:uses-library android:name=\"com.amazon.whisperplay.contracts\"&gt;",
        "url": "unity-controller-plugin.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "unity-player-plugin-html": {
        "title": "Integrating the Amazon Fling Player In Your Games",
        "tags": "[]",
        "content": "This page will walk you through the steps of setting up your Unity project to include the Amazon Fling Player Unity Plugin. It will also provide instruction on how to use the plugin. For additional information see the FlingPlayerSampleApp in the samples folder of the plugins SDK.  Import the Unity Package  Initialize the Player  Method Calls  Handling Events  Additional Step for DeploymentImport the Unity PackageWhen you import the Amazon Fling Player Unity package, Unity will override existing files in your project with those in the package. Before importing the Unity package, review the list of included files and compare this list with your current project to check for overlap.If a file exists in both your project and the package, verify that any changes you have made locally are backed up somewhere outside of your project. After you import the package, use your favorite file merging software to compare and merge the differences between the file in the package and the file you had backed up locally.  In Unity, click Assets, click Import Package, and then click Custom Package…  Select the plugin package.  Import the Package.Initialize the PlayerInitialize the service using a unique service ID. This service ID will need to match the service ID in the whisperplay.xml file described in the additional steps section.IAmazonFlingPlayerService flingPlayerService;flingPlayerService = AmazonFlingPlayerServiceImpl.Instance;StartServiceParameters startServiceParameters = new StartServiceParameters();startServiceParameters.PlayerId = \"your.unique.service.id\";flingPlayerService.StartService(startServiceParameters);Method CallsTo initiate a method call, you must perform the following general steps:  If needed, construct the object used to pass input to the operation.  Call the operation, passing in any required input as arguments.Example:MediaPlayerInfo mediaPlayerInfo = new MediaPlayerInfo ();mediaPlayerInfo.Source = setMediaSourceParameters.Source;mediaPlayerInfo.Metadata = setMediaSourceParameters.MetadataJson;flingPlayerService.UpdateMediaPlayerInfo(mediaPlayerInfo);            Method      Summary                  void StartService(StartServiceParameters startServiceParameters)      Starts the player service to allow controllers to interact with it. The startServiceParameters.PlayerID used will need to match the service ID of the controller trying to connect to it.              void UpdateVolume(Volume volume)      Updates the volume of the player service.              void UpdateMute (Mute mute)      Updates the mute status of the player service. This method will trigger a callback to any status listeners added by a controller.              void UpdatePosition(Position position)      Updates the position of the player service. This method will trigger a callback to any status listeners added by a controller.              void UpdateDuration(Duration duration)      Updates the duration of the player service. This method will trigger a callback to any status listeners added by a controller.              void UpdateMediaState(MediaState mediaState)       Updates the media state of the player service. This method will trigger a callback to any status listeners added by a controller.              void UpdateMediaCondition(MediaCondition mediaCondition)      Updates the media condition of the player service. This method will trigger a callback to any status listeners added by a controller.              void AddSupportedMimeType(MimeType mimeType)      Adds a mime type to the player service’s mime type list. The list is used when a controller calls the IsMimeTypeSupported() API on the controller.              void UpdateMediaPlayerInfo(MediaPlayerInfo mediaPlayerInfo)      Updates the media player info of the player service. This method will trigger a callback to any status listeners added by a controller.      Handling EventsTo handle an event, you must perform the following steps:  Define an event handler.  Register your event handler with an event listener.Example:private void SetMediaSourceCallback(SetMediaSourceParameters setMediaSourceParameters) {}flingPlayerService.AddSetMediaSourceListener(SetMediaSourceCallback);            Method      Summary              void AddSetVolumeListener(SetVolumeDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to set the volume.              void AddSetMuteListener(SetMuteDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to set the mute status.              void AddPauseListener(PauseDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to pause the media.              void AddPlayListener(PlayDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to play the media.              void AddStopListener(StopDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to stop the media.              void AddSeekListener(SeekDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to seek the media.              void AddSetMediaSourceListener(SetMediaSourceDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to set the media source.              void AddSetPlayerStyleListener (SetPlayerStyleDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a request to set the player style.              void AddSendCommandListener(SendCommandDelegate responseDelegate)      Registers the delegate with the player service to be called when a controller sends a command.      Additional Step for DeploymentThe player needs access permissions to communicate over the net, and the below permissions are required to be added to your AndroidManifest.xml:  android.permission.INTERNET: Allows applications to open network sockets.  android.permission.ACCESS_WIFI_STATE: Allows applications to access information about Wi-Fi networks.  android.permission.ACCESS_NETWORK_STATE: Allows applications to access information about networks.These permissions can be added manually or by renaming the Plugins/Android/AmazonFlingPlayerServiceSampleAndroidManifest.xml file to AndroidManifest.xml.The player also needs access to the WhisperPlay library on Fire TV and needs to tell the library what activity/service to start when a controller device tries to communicate with your app. WhisperPlay will start the activity/service for you if it is not already running. This is achieved by adding the following lines to your AndroidManifest.xml file. These permissions are also already included in the manifest file in the plugin, which you can rename and use.uses-library android:name=\"com.amazon.whisperplay.contracts\"/&gt;&lt;meta-data android:resource=\"@xml/whisperplay\" android:name=\"whisperplay\"/&gt;The whisperplay.xml file located in the Android/res/xml/ directory of the plugin specifies the activity/service that will be called if a controller device tries to use your service when it is not running. It also tells the player what service id to expect to connect to after it starts the application. You should update this file to have your unique service id in the &lt;sid&gt; section and the activity/service you would like to start in the &lt;startAction&gt; section (this is by default set to the activity defined in the AmazonFlingPlayerServiceSampleAndroidManifest.xml file):&lt;whisperplay&gt;    &lt;services&gt;        &lt;service&gt;            &lt;sid&gt;your.unique.service.id&lt;/sid&gt;            &lt;accessLevel&gt;ALL&lt;/accessLevel&gt;            &lt;startAction&gt;com.unity3d.player.UnityPlayerNativeActivity&lt;/startAction&gt;        &lt;/service&gt;    &lt;/services&gt;&lt;/whisperplay&gt;",
        "url": "unity-player-plugin.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "using-amazon-fling-with-android-mediarouter-html": {
        "title": "Using Amazon Fling with Android MediaRouter",
        "tags": "[]",
        "content": "The MediaRouter framework in Android enables your app to direct the output of media playback to a specific device. The API included in the SDK provides a FlingMediaRouteProvider class for controller apps, which makes it easy to integrate this functionality into your MediaRouter-based app.  Integrating FlingMediaRouteProvider  Discovering Media Devices With MediaRouter  Using RemotePlaybackClient To Fling Content  Using sendControlRequest() To Fling Content  Getting Status UpdatesIntegrating FlingMediaRouteProviderThe FlingMediaRouteProvider class can be integrated into your app by adding the following lines to your existing activity:import com.amazon.whisperplay.fling.provider.FlingMediaRouteProvider;...    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        MediaRouter.getInstance(this).addProvider(new FlingMediaRouteProvider(this, \"acme.fling.player\"));        ...    }MediaRouter provides routes to Amazon Fire TV apps implementing the service ID you provide. Change the service ID in the example above (acme.fling.player) to the service ID of your Amazon Fire TV application. The FlingMediaRouteProvider class provides all of the functionality accessible through RemotePlaybackClient, except queuing. Applications sending control intents directly to the route instead of using a RemotePlaybackClient support these standard MediaControlIntent intents:  MediaControlIntent.ACTION_PLAY  MediaControlIntent.ACTION_SEEK  MediaControlIntent.ACTION_GET_STATUS  MediaControlIntent.ACTION_PAUSE  MediaControlIntent.ACTION_RESUME  MediaControlIntent.ACTION_STOP  MediaControlIntent.ACTION_START_SESSION  MediaControlIntent.ACTION_GET_SESSION_STATUS  MediaControlIntent.ACTION_END_SESSIONIn addition, these intents provide additional functionality not provided by the default intents. More information on required intent extras and the extras returned from these intents can be found in the API documentation provided with the SDK (Javadocs).  FlingMediaControlIntent.ACTION_MUTE  FlingMediaControlIntent.ACTION_UNMUTE  FlingMediaControlIntent.ACTION_GET_IS_MUTE  FlingMediaControlIntent.ACTION_GET_MEDIA_INFO  FlingMediaControlIntent.ACTION_SEND_COMMAND  FlingMediaControlIntent.ACTION_SET_PLAYER_STYLE  FlingMediaControlIntent.ACTION_GET_IS_MIME_TYPE_SUPPORTEDDiscovering Media Devices With MediaRouterMediaRouter can be used to control device discovery on your controller app. Obtain a MediaRouter object with getInstance():    private MediaRouter mMediaRouter;    ...        mMediaRouter = MediaRouter.getInstance(this);After you get an instance of MediaRouter, add the provider, as documented in the previous section. Then, create a MediaRouteSelector and a MediaRouter.Callback to handle discovering devices, and then add them to MediaRouter. Note: The FlingMediaRouteProvider only provides routes if you are using the control category MediaControlIntent.CATEGORY_REMOTE_PLAYBACK when creating your MediaRouteSelector. The code sample below uses the flag MediaRouter.CALLBACK_FLAG_PERMFORM_ACTIVE_SCAN to continuously look for devices while the callback is registered.    private MediaRouter.Callback mMediaRouterCallback = new MediaRouter.Callback() {        public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo route) {            //your code for handling when a new route is discovered here        }        public void onRouteRemoved(MediaRouter router, MediaRouter.RouteInfo route) {            //your code for handling when a route is no longer available        }    };    ...        mMediaRouter.addProvider(new FlingMediaRouteProvider(this, \"acme.fling.player\"));        MediaRouteSelector mediaRouteSelector = new MediaRouteSelector.Builder()                .addControlCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK)                .build();        mMediaRouter.addCallback(mediaRouteSelector, mMediaRouterCallback,                MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);When device routes have been discovered your app can interact with those routes with a RemotePlaybackClient object, or with playback control requests.  Volume control is covered in the next section.Using RemotePlaybackClient To Fling ContentInitialize a RemotePlaybackClient object with the route provided by MediaRouter. In this example, the mCurrentRoute variable is a MediaRouter.RouteInfo instance provided by the onRouteAdded() method in your MediaRouter.Callback.    private MediaRouter.RouteInfo mCurrentRoute;    private RemotePlaybackClient mClient;    ...        mCurrentRoute.select();        mClient = new RemotePlaybackClient(getApplicationContext(), mCurrentRoute);Once the RemotePlaybackClient object is created your app can communicate with the remote device. Any calls to your remote device must include an asynchronous callback, which is called when the provider has received a response and has finished processing.The callback provides some variables such as sessionId, and a Bundle with data. See the RemotePlaybackClient and MediaControlIntent classes for details on the data provided by each call and for additional methods.mClient.startSession(null, new RemotePlaybackClient.SessionActionCallback() {    @Override    public void onResult(Bundle data, String sessionId, MediaSessionStatus sessionStatus) {        //code handling a successful result here    }    @Override    public void onError(String error, int code, Bundle data) {        //code handling failure here    }});Uri mUri = \"http://www.leanbackplayer.com/videos/360p/elephants_dream_640x360_2.30.mp4\";//build the metadata bundle that includes closed captioning informationBundle metadataBundle = new Bundle();metadataBundle.putString(MediaItemMetadata.KEY_TITLE, \"Elephants Dream\");metadataBundle.putString(MediaItemMetadata.KEY_ARTWORK_URI, \"http://en.wikipedia.org/wiki/Elephants_Dream#mediaviewer/File:Elephants_Dream_s5_both.jpg\");metadataBundle.putString(FireTVBuiltInReceiverMetadata.KEY_TYPE, \"video/mp4\");metadataBundle.putString(FireTVBuiltInReceiverMetadata.KEY_DESCRIPTION, \"Elephants Dream is the world?s first open movie, made entirely with open source graphics software such as Blender, and with all production files freely available to use however you please, under a Creative Commons license.\");metadataBundle.putString(FireTVBuiltInReceiverMetadata.KEY_NO_REPLAY, \"false\");ArrayList&lt;Bundle&gt; ccTracks = new ArrayList&lt;&gt;();Bundle track = new Bundle();track.putString(FireTVBuiltInReceiverMetadata.KEY_TRACK_SOURCE, \"http://www.leanbackplayer.com/subtitles/elephants_dream/english_en.vtt\");track.putString(FireTVBuiltInReceiverMetadata.KEY_TRACK_KIND, \"subtitles\");track.putString(FireTVBuiltInReceiverMetadata.KEY_TRACK_SOURCE_LANGUAGE, \"en-US\");track.putString(FireTVBuiltInReceiverMetadata.KEY_TRACK_LABEL, \"English\");ccTracks.add(track);  metadataBundle.putParcelableArrayList(FireTVBuiltInReceiverMetadata.KEY_TRACKS, tracks);String mItemID;mClient.play(mUri, \"video/mp4\", metadataBundle, 0, null, new RemotePlaybackClient.ItemActionCallback() {\t@Override\tpublic void onResult(Bundle data, String sessionId, MediaSessionStatus sessionStatus, String itemId, MediaItemStatus itemStatus) {\t\tmItemID = itemId;\t}});mClient.pause(null, new RemotePlaybackClient.SessionActionCallback() {});mClient.resume(null, new RemotePlaybackClient.SessionActionCallback() {});mClient.stop(null, new RemotePlaybackClient.SessionActionCallback() {});//seek to 10 seconds from the beginningint mPosition = 10000;mClient.seek(mItemID, mPosition, null, new RemotePlaybackClient.ItemActionCallback() {});mClient.endSession(null, new RemotePlaybackClient.SessionActionCallback() {});Using sendControlRequest() To Fling ContentOnce you obtain a MediaRouter.RouteInfo object from MediaRouter.Callback you can call the sendControlRequest() method directly. To use this method, build an Intent for the command you wish to send, and include a MediaRouter.ControlRequestCallback object.The callback is called when your request has received a response and has finished processing, and returns a Bundle containing the data you requested. The bundle data and additional actions not listed here are described at MediaControlIntent.Implementing fling with the sendControlRequest() method requires more work than using RemotePlaybackClient, as it requires you to manage your session ID and create intents for every request.String mSessionID;String mItemID;//Start SessionIntent intent = new Intent(MediaControlIntent.ACTION_START_SESSION);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {    @Override    public void onResult(Bundle data) {        mSessionID = data.getString(MediaControlIntent.EXTRA_SESSION_ID);    }});//PlayUri mUri = \"http://distribution.bbb3d.renderfarming.net/video/mp4/bbb_sunflower_1080p_30fps_normal.mp4\";Intent intent = new Intent(MediaControlIntent.ACTION_PLAY).setDataAndType(mUri, \"video/mp4\");intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {    @Override    public void onResult(Bundle data) {        mSessionID = data.getString(MediaControlIntent.EXTRA_SESSION_ID);        mItemID = data.getString(MediaControlIntent.EXTRA_ITEM_ID);    }});//PauseIntent intent = new Intent(MediaControlIntent.ACTION_PAUSE);intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {});//ResumeIntent intent = new Intent(MediaControlIntent.ACTION_RESUME);intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {});//StopIntent intent = new Intent(MediaControlIntent.ACTION_STOP);intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {});//SeekIntent intent = new Intent(MediaControlIntent.ACTION_SEEK);intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);intent.putExtra(MediaControlIntent.EXTRA_ITEM_ID, mItemID);intent.putExtra(MediaControlIntent.EXTRA_ITEM_CONTENT_POSITION, 10000); //10 seconds into the videomCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {});//End SessionIntent intent = new Intent(MediaControlIntent.ACTION_END_SESSION);intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {});Getting Status UpdatesStatus updates from the MediaRouter.RouteInfo object can be obtained in two ways: from direct requests, or by setting up a listener. Direct requests work similarly to what was described in the previous section.mCurrentRoute.getStatus(mItemID, null, new RemotePlaybackClient.ItemActionCallback() {    @Override    public void onResult(final Bundle data, String sessionId, MediaSessionStatus sessionStatus, String itemId, MediaItemStatus itemStatus) {        //handle status here    }});Intent intent = new Intent(MediaControlIntent.ACTION_GET_STATUS);intent.putExtra(MediaControlIntent.EXTRA_SESSION_ID, mSessionID);intent.putExtra(MediaControlIntent.EXTRA_ITEM_ID, mItemID);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {    @Override    public void onResult(Bundle data) {        //get status from bundle and use it here    }});You can add a listener when starting the session or playing content when using sendControlRequest(). If you’re using RemotePlaybackClient the listener can be added with the setStatusCallback() method. Set the listener before the session is created or any play commands are issued.//using RemotePlaybackClientmClient.setStatusCallback(new RemotePlaybackClient.StatusCallback() {    @Override    public void onItemStatusChanged(Bundle data,                String sessionId, MediaSessionStatus sessionStatus,                String itemId, MediaItemStatus itemStatus) {        //update status here    }    @Override    public void onSessionStatusChanged(Bundle data,                String sessionId, MediaSessionStatus sessionStatus) {        //update status here    }    @Override    public void onSessionChanged(String sessionId) {        //update status here    }});//using sendControlRequestString ACTION_RECEIVE_MEDIA_STATUS_UPDATE = \"acme.fling.player.ACTION_RECEIVE_MEDIA_STATUS_UPDATE\";mSessionStatusUpdateIntent = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);mMediaStatusBroadcastReceiver = new BroadcastReceiver() {    @Override    public void onReceive(Context context, Intent intent) {        //handle status update here    }};mMediaStatusBroadcastIntentFilter = new IntentFilter(ACTION_RECEIVE_MEDIA_STATUS_UPDATE);intent = new Intent(ACTION_RECEIVE_MEDIA_STATUS_UPDATE);intent.setComponent(getCallingActivity());mMediaStatusUpdateIntent = PendingIntent.getBroadcast(this, 0, intent,PendingIntent.FLAG_UPDATE_CURRENT);...Intent intent = new Intent(MediaControlIntent.ACTION_START_SESSION);intent.putExtra(MediaControlIntent.EXTRA_ITEM_STATUS_UPDATE_RECEIVER, mMediaStatusUpdateIntent);mCurrentRoute.sendControlRequest(intent, new MediaRouter.ControlRequestCallback() {}); Note: There is a bug in the MediaRouteProvider object used by Cast devices that causes onItemStatusChanged() in RemotePlaybackClient.StatusCallback to never be called due to a missing session ID. This method receives updates properly for FlingMediaRouteProvider. FlingMediaRouteProvider also triggers the item status update every time the media position changes (maximum 1 call per second), although this may not be the case for all MediaRouteProvider instances.",
        "url": "using-amazon-fling-with-android-mediarouter.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "working-with-built-in-receiver-on-fire-tv-html": {
        "title": "Working with the Built-in Receiver on the Fire TV Platform",
        "tags": "[]",
        "content": "The Amazon Fire TV and Fire TV Stick have a built-in receiver application that supports Amazon Fling service. This means your controller app can send supported media content over to the Fire TV and Fire TV Stick without the need for a specific companion Fire TV application.Your controller application can discover the Fire TV or Fire TV Stick using the publically available unique service identifier (SID) of the built-in receiver and send media content to it.This page describes how you can achieve that and what you can do with this built-in receiver.  Discovering the Built-in Receiver          On Android/Fire OS      On iOS        Playing Media Content on the Built-in Receiver          Supported Media Types      How to Control Playback?      Format of the Metadata JSON      Discovering the Built-in ReceiverThe built-in receivers on the Fire TV and Fire TV Stick are identified by the service identifier (SID) \"amzn.thin.pl\".To discover these receivers, you can use the following code snippets to search:On Android/Fire OSmController = new DiscoveryController(this);mController.start(\"amzn.thin.pl\", mDiscoveryListener);On iOSmController = [DiscoveryController alloc];[mController open:@\"amzn.thin.pl\" : self];Playing Media Content on the Built-in ReceiverThe built-in receiver on the Fire TV and Fire TV Stick provides a rich set of features to your controller app. You can do the following:  Send video clips, audio clips, as well as images  If your app provides closed captioning for video content, closed captioning may be displayed on the Amazon Fire TV  Show title and description of the media clips  Show album art when playing audio  Control how the end of playback is handled, in case you want to send media clips continuously Note: The built-in media player receiver does not support the mute and volume API calls at this time.Supported Media TypesThe built-in receiver on the Amazon Fire TV and Fire TV Stick can play any media type supported by the Fire TV platform. The detailed list of content types is available here: Fire TV Device Specifications.How to Control Playback?The setMediaSource API allows you to control how the playback works on the built-in receiver. The metadataJson parameter of this API is responsible for setting values for UI elements on the playback interface.Format of the Metadata JSONIn your controller application, please send the metadata JSON string that conforms to the following format:{    \"type\" : string, // required (if not present, video is assumed)    \"title\" : string, // optional    \"description\" : string, // optional    \"poster\" : string, // optional – URL of the album art for an audio media source    \"tracks\" : // optional – subtitles presented to the user        [ // Array of subtitle objects            {                \"src\" : string, // required – URL of the WebVTT file                \"kind\" : string, // required – always \"subtitles\"                \"srclang\" : string, // required – language code                \"label\" : string // required – what is shown on the UI            }, …        ],    \"noreplay\": true|false, //optional}",
        "url": "working-with-built-in-receiver-on-fire-tv.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
      "fire-tv-accessibility-html": {
        "title": "Accessibility - Fire TV",
        "tags": "[]",
        "content": "This page discusses the concepts and terminology related to implementing accessibility features for Fire OS. Note: Before you begin, Amazon recommends reading through the Android documentation for accessibility to familiarize yourself with these terms and concepts. See Making Applications Accessible.  Overview of Fire OS Accessibility Objects and Events          AccessibilityEvent      AccessibilityNodeInfo      AccessibilityNodeProvider      AccessibilityDelegate        Path of an Accessibility Event          Standard Views      Custom Views        Setting a view’s importance  Managing an AccessibilityNodeInfo Object  Implementing Virtually Accessible Descendants          Creating Virtually Accessible Descendant Views      Management of a Virtually Accessible Descendant view        Best Practices for Fire OS Accessibility  Related ResourcesOverview of Fire OS Accessibility Objects and EventsThis section contains an introduction to the terms and their definitions for the objects and events that you will use when implementing accessibility in your app.AccessibilityEventAn AccessibilityEvent is a message from an application to an assistive technology indicating that something happened in the UI. Examples of UI changes that could trigger an accessibility event include focus changes, a window appearing or disappearing, or an on-screen object changing locations.Also see the Android documentation for AccessibilityEvents.AccessibilityNodeInfoAn AccessibilityNodeInfo is a snapshot of the accessibility information related to an on-screen component and provides mostly one-way communication between your app and the assistive technology. The assistive technology also has very limited communication back to the app via accessibility actions.After your application creates and returns an AccessibilityNodeInfo, the assistive technology and accessibility framework will not see any further changes to that node, so at that point you can discard the node. If the underlying object represented by the node changes, send an appropriate accessibility event indicating the change, reflecting the updated characteristics of the object in the node returned from the next call to either createAccessibilityNodeInfo or onInitializeAccessibilityNodeInfo.In the app, on the server side, reference nodes using a combination of an Android view and a virtual descendant number. If the node represents the view itself, the virtual descendant number is -1 (AccessibilityNodeProvider.HOST_VIEW_ID).An app can add descriptive information about an AccessibilityNodeInfo object in that object’s getExtras Bundle, which VoiceView can read by calling AccessibilityNodeInfo.getExtras().Also see the Android documentation for AccessibilityNodeInfo.AccessibilityNodeProviderAn AccessibilityNodeProvider is an interface which creates an AccessibilityNodeInfo either for a view or for the virtually accessible descendant of a view.Also see the Android documentation for AccessibilityNodeProvider.AccessibilityDelegateAn AccessibilityDelegate  is an interface that can initialize accessibility events, nodes for views, or virtual accessible descendants. Use AccessibilityDelegates to proxy or augment accessibility information in one view from information in another. For example, a parent list can provide accessibility information for a list item.Also see the Android documentation for AccessibilityDelegate.Path of an Accessibility Event This section discusses the path of accessibility events for standard and custom views.Standard ViewsThe visual elements that make up the user interface of a Fire OS app are called Views. For example consider a simple app that has a single text element, a TextView with the text “hello world”. In this example, the TextView is a child of a RelativeLayout. RelativeLayout is a child of ViewRootImpl, the class that is always the root of an app’s View hierarchy. Since a TextView is a standard Android view, the default behavior of the TextView is to send appropriate accessibility events when VoiceView is running.The following process describes the path of an accessibility event created within this simple app:   The app’s code calls textView.setText(\"new text\") a few seconds after the app opens.  The TextView creates a TYPE_WINDOW_CONTENT_CHANGED AccessibilityEvent and requests that its parent, the RelativeLayout, send the event.  The RelativeLayout then passes the event up to its parent, the ViewRootImpl, and requests that it send the event to the framework.  The ViewRootImpl sends the event to the Accessibility Framework by calling the AccessibilityManager’s sendAccessibilityEvent().  The AccessibilityManager passes the event to the AccessibilityManagerService, which then passes the event out of the Accessibility Framework and into VoiceView.  When VoiceView processes the TYPE_WINDOW_CONTENT_CHANGED AccessibilityEvent, it calls the event object’s getSource() method.  This will trigger the Accessibility Framework to call the TextView's createAccessibilityNodeInfo() method, which returns an AccessibilityNodeInfo object containing the text “new text”.  The Accessibility Framework then passes the AccessibilityNodeInfo object to VoiceView.  Finally, VoiceView becomes aware of the TextView’s change from “hello world” to “new text”, and if a customer uses linear navigation to hear the text of the TextView, VoiceView will correctly speak “new text”.Custom ViewsIf your app uses a custom view instead of a standard view, you must uphold this pattern of informing VoiceView of the state of your widget. When doing so, do not try to send an AccessibilityNodeInfo object to VoiceView, or update a local copy of the AccessibilityNodeInfo in your app; these approaches will not work.Remember, when you change the state of a custom widget:DO  Send an AccessibilityEvent by calling requestSendAccessibilityEvent() on your custom view’s parent.  Ensure the variables pointed to in your custom view’s createAccessibilityNodeInfo() function contain updated values. VoiceView calls createAccessibilityNodeInfo() when VoiceView receives your AccessibilityEvent.DO NOT  Try to send an AccessibilityNodeInfo to VoiceView.  Keep references to AccessibilityNodeInfo objects outside of your createAccessibilityNodeInfo() function and then update these objects. VoiceView does not have any way to reference to these objects and will never see your updates to them.In the Android documentation, be sure to review a code example demonstrating correct use of the AccessibilityDelegate and AccessibilityNodeProvider classes where the createAccessibilityNodeInfo() function is implemented.Setting a view’s importanceTo ensure that accessibility events are handled properly, make sure to set the importance for accessibility for each Android view. Set the state of view’s importance for accessibility either in an XML layout with the android:importantForAccessibility attribute or programmatically with the View.setImportantForAccessibility method. You can set importance to yes, no, no_hide_descendants, or auto (default). Views that are not tagged as important do not have corresponding accessibility nodes, and additionally, the framework drops any accessibility events sent by them.If your view is sending appropriate accessibility events, but VoiceView doesn’t seem to be responding correctly, verify that your view is tagged as important for accessibility.Managing an AccessibilityNodeInfo ObjectOne important aspect of Fire OS and Android accessibility is the management of AccessibilityNodeInfo objects. When the Android accessibility framework, which runs in the app’s process, receives a request for a particular node, the framework first checks to see if the node is in its cache:  If the node exists in the cache, it is returned, and no call to create the node is made to the app. Because of this, your app must diligently notify the framework and assistive technologies whenever the accessibility information about a component changes. Otherwise, the framework returns stale information to the assistive technologies.  To indicate that a node has changed and is no longer valid, send an accessibility event of type AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED.  If the node is not already in the cache depends, the node could be created, depending on how it was requested. Several possible actions by the assistive technology can trigger the creation of an AccessibilityNodeInfo object:          Receiving an accessibility event, and requesting its source.      Requesting the root node of the active window.      Requesting the parent or child node of a particular node.      Implementing Virtually Accessible DescendantsThis section discusses how to implement virtually accessible descendant views.Creating Virtually Accessible Descendant ViewsBoth AccessibilityDelegate and AccessibilityNodeProvider can provide accessibility for on-screen components that are not represented by backing views. An example of such a component is the AOSP on-screen keyboard whose keys are drawn on a canvas. Note that when implementing a virtual node tree, the ExploreByTouchHelper support library provided by Android might not work as expected.Apps reference AccessibilityNodeInfo objects in by the view hosting the node and a virtual view ID. A virtual view ID of -1 (AccessibilityNodeProvider.HOST_VIEW_ID) references the host view itself. When creating nodes, you can add virtual children using the AccessibilityNodeInfo.addChild() method and specifying both the host view and the virtual view ID of the virtual child. Similarly, when creating child nodes, you can set a virtual parent by specifying the host view and the parent virtual view ID in the call to AccessibilityNodeInfo.setParent().Management of a Virtually Accessible Descendant viewWhen you initially create virtual views, they are only referenced by their IDs and have no associated accessibility information (text, content description, etc.). When the accessibility framework requests that your app create the appropriate node, input the corresponding accessibility information into the AccessibilityNodeInfo. As a result, make sure that your app tracks which virtual view ID represents which portion of your custom widget.Add the IDs of the child or parent nodes, and the framework later requests that your application actually create those nodes. Do not simply add child nodes to a container node.Best Practices for Fire OS AccessibilityTo ensure the best user experience for apps with accessibility features, follow these guidelines:  AccessibilityNodeInfo text: The text of an AccessibilityNodeInfo should only return the on-screen text of an object.  Labels for onscreen items: All important onscreen items should have labels. Make sure that when testing with VoiceView, you touch all onscreen items and that you hear an appropriate description read. If a description is missing, add the appropriate text or content description to the item’s AccessibilityNodeInfo.  Content descriptions: Use the content description for items that do not have on-screen text (for example, alt text for an image), or to augment the on-screen text to provide additional context to the user. However, avoid putting too much content into the content description to avoid overwhelming the user.  Accessibility event usage: Avoid using the AccessibilityEvent.TYPE_ANNOUNCEMENT event type to convey on-screen activity. Preferably, use a combination of accessibility events and corresponding changes to the AccessibilityNodeInfo to communicate information about on-screen changes.Related Resources  Understanding assistive Technologies for Fire OS  Implementing Future VoiceView Accessibility Features",
        "url": "fire-tv-accessibility.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-assistive-technologies-html": {
        "title": "Assistive Technologies - Fire TV",
        "tags": "[]",
        "content": "Accessibility is the degree to which a product or service can be used by a customer with a particular disability. Accessible products and services enable users with disabilities to easily and efficiently use those products and services.  Accessibility Overview  Available Fire OS Assistive Technologies  Activating and Using Assistive Technologies for Fire OS          Activating and Using VoiceView on Fire Tablets      Activating VoiceView on Fire TV      Activating the Screen Magnifier on Fire Tablets        Differences between VoiceView on Fire OS and TalkBack on Android  Related ResourcesAccessibility OverviewAccessible systems have three major components:  Application being made accessible  Accessibility framework  Assistive technologyAssistive technologies help a person with a disability accomplish a task or use a product. Examples of assistive technologies include screen reading software for blind users, screen magnification software for users with low vision, or wheel chairs for users who are unable to walk.This page provides a conceptual over view of the assistive techonologies that are available from Amazon for your Fire OS apps.Available Fire OS Assistive TechnologiesFire OS currently supports several assistive technologies:  VoiceView: Enable a blind user to interact with objects on the screen via speech output and either touch or keyboard input.  Screen Magnifier: Enable a vision-impaired person to view an enlarged version of the screen.  Large Font: Increase the font size throughout most of the UI.  Color Inversion: Easily view and read content on your Fire tablet with the provided high-contrast color combinations for text and background colors.  Color Correction: Adjust the screen’s color output to help people with colorblindness distinguish more colors.  Stereo to Mono Audio: Switch the stereo audio setting to mono on your Fire tablet to direct the audio into a specific ear bud.  System Closed Captioning: Customize the appearance of closed captions for Amazon Instant Videos and web videos in the Silk Browser.Currently all technologies are available on Fire Tablets. Fire TV only supports VoiceView.Activating and Using Assistive Technologies for Fire OSThis section describes how users can enable the available assistive technologies on each supported device.Activating and Using VoiceView on Fire TabletsTo activate VoiceView on a Fire Tablet, navigate to Settings &gt; Accessibility &gt; VoiceView, and enable VoiceView. Alternatively, you can hold down the power button until the power dialog appears, then press and hold two fingers to the screen.To use VoiceView on a Fire Tablet:  Touch an item on the screen to move the VoiceView cursor to that item.          When an item has VoiceView’s focus, a green rectangle will appear, surrounding the item.      When a user moves the VoiceView cursor to an item, VoiceView speaks the item’s description.        Double-tap anywhere on the screen to activate the item in the focus of the VoiceView cursor. ORInstead of touching items to move the VoiceView cursor, you can move sequentially through all items on the screen by swiping right to move to the next item, and swiping left to move to the previous item.Activating VoiceView on Fire TVTo activate VoiceView on Fire TV:      Enable VoiceView by holding down the Back and Menu keys on the Fire TV remote for 2 seconds.    VoiceView has two navigation modes available: Standard Navigation Mode or Enhanced Navigation Mode. You can switch to Standard Navigation Mode by holding down the Menu key. Note that in Standard Navigation Mode, VoiceView’s cursor will only move among actionable items, such as buttons.         In Enhanced Navigation Mode, press the Right and Left directional keys on the remote  to move VoiceView’s cursor, shown as the green focus rectangle, to an item.         Press the Select key to activate an item.     Note: Left and Right move the cursor in an order that is logically, not visually, determined.  For example, they will move the cursor to the next and previous items in a list, regardless of whether that list is displayed horizontally or vertically. Enhanced Mode also allows access to reach items you cannot reach otherwise such as descriptive text that is not actionable.  Activating the Screen Magnifier on Fire TabletsNote that the Screen Magnifier is not currently available on Fire TV. To activate the Screen Magnifier on Fire Tablets:  With the screen magnifier enabled, triple-tap with one finger to show an enlarged view of the screen.  Pan around the screen by dragging two fingers.  Triple-tap with one finger to exit the enlarged view of the screen.Differences between VoiceView on Fire OS and TalkBack on AndroidWhile Fire OS’s VoiceView and Android’s TalkBack are both accessibility services that interact with the Android accessibility framework, VoiceView is a completely distinct screen reader from TalkBack, as opposed to a modification of TalkBack.  This section discusses the differences between these two accessibility services:  Focus behavior in new windows: When a new window opens, VoiceView always places accessibility focus somewhere onscreen.  TalkBack does not place focus anywhere on a new window, and instead waits for the user to touch the screen and places focus at that location.  Linear navigation across windows: VoiceView allows linear navigation across window boundaries, while TalkBack does not.  Consider the bottom navigation bar on a tablet, which is actually a window that contains three buttons.          In VoiceView, swiping left will move the cursor to the last item in the main content window.      In TalkBack, swiping left from the Back button in the bottom navigation bar on TalkBack will not allow you to linearly navigate out of the bottom navigation bar and will produce an “end” earcon.        Granular navigation across objects: VoiceView allows granular navigation across objects, while TalkBack does not.  Consider a screen containing three objects with titles “Cat, “Dog”, and “Monkey”.          When navigating by word, VoiceView moves seamlessly from “Cat” to “Dog” to “Monkey”.      Conversely, TalkBack will stop on “Dog” and not navigate to the next word.      Similarly, when navigating by character, if you swipe down to move to the next character after landing on the “g” of “Dog”, VoiceView will move to the “C” of “Cat”. TalkBack plays a sound indicating the end of text in this case.            Text navigation: When navigating through text, VoiceView announces the character or word after the caret, TalkBack announces the character or word that the caret has passed over.  Note that VoiceView’s behavior is consistent with the behavior of screen readers on the Windows platform, which is the platform with which most blind users are familiar.    Sorting on-screen objects: TalkBack typically sorts on-screen objects in a left to right, top to bottom order, based on the coordinates of the objects’ top-left corners. VoiceView typically sorts on-screen objects in a left to right, top to bottom order, based on the coordinates of the objects’ centers.Related Resources  Implementing Future VoiceView Accessibility Features  Implementing Accessibility in Fire OS",
        "url": "fire-tv-assistive-technologies.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-preview-future-voiceview-accessibility-features-html": {
        "title": "PREVIEW: Implementing Future VoiceView Accessibility Features - Fire TV",
        "tags": "[]",
        "content": "The VoiceView accessibility feature of Fire OS enables vision-impaired users to navigate the Fire TV user interface. With VoiceView, visually impaired users are able to use the Up, Down, Left, and Right buttons on the remote to move the input focus around the screen.When the focus changes, VoiceView speaks the currently focused item. This functionality is similar to the “Standard Navigation” mode of the previous version of VoiceView.This page discusses the user experience (UX) recommendations for implementing VoiceView in your app.  Checklist for VoiceView Implementation          Technical Implementation Recommendations      User Experience (UX) Recommendations        Overview of VoiceView Behavior          Using the Menu button with VoiceView      Navigating with VoiceView        Navigating with Review Mode          Using Review Mode with WebViews      Navigating Focus Granularity Options in Review Mode        Implementing VoiceView          Implementing VoiceView for Static or Non-focusable Content      Implementing VoiceView for Orientation Text      Implementing VoiceView for Usage Hints        Related ResourcesChecklist for VoiceView ImplementationUse the following checklists to ensure that your Fire TV app implements the VoiceView screen reader to meet the standards recommended by Amazon for the upcoming Fire TV software release.Technical Implementation RecommendationsYour app should implement the following aspects of VoiceView:  Verify that your app’s UI is compatible with the Android Accessibility Framework.  Implement Content Descriptions so that VoiceView can read descriptions for images, buttons, and other on-screen objects.  Add Usage Hints to list and grid content so that VoiceView can help guide the interactions of vision-impaired users.  Implement Described By for static content, so that VoiceView can read that content when the associated object gains focus.User Experience (UX) RecommendationsYour app should implement the following UX recommendations for VoiceView:  VoiceView reads the content for items that gain focus, including all information that is visually represented onscreen, such as a title or episode number.  VoiceView reads Orientation Text and Usage Hints to help users learn how to navigate the screen UI.  VoiceView reads static content either automatically through Described By text, manually when a user either presses the Menu button, or manually when a user enters Review Mode and steps through on-screen items.  VoiceView reads setup information, including activation URLs and codes.  VoiceView supports features and tasks such as program selection, program information, playback, and CC settings.Overview of VoiceView BehaviorUsers can navigate the Fire TV user interface and VoiceView-enabled apps using the Menu button and other controls.Using the Menu button with VoiceViewUse the following conventions for the Menu button when VoiceView is enabled:  To enable or disable VoiceView, press the Back and Menu buttons at the same time for two seconds.  When VoiceView is enabled, VoiceView controls the Menu button and the Play/Pause button (when VoiceView is speaking).  The system or app receives double-press events from the Menu button.  Single-pressing the Menu button initiates the reading of information from the screen in the following order:          Usage hints      Orientation text      Described By text      All other static content      Navigating with VoiceViewUse the following navigation conventions when VoiceView is enabled:  When VoiceView reads Usage hints, Orientation text, Described By text, and all other static content, the user can control navigation using the Rewind and Fast Forward buttons.  When a user accesses a screen for the first time, VoiceView automatically reads the Orientation text first.  When a user moves focus to a control after pausing, VoiceView reads Usage hints and Described by text.  When speaking, the Play/Pause button silences VoiceView.          If a movie or music is playing and VoiceView is speaking, pressing Play/Pause one time silences VoiceView.      After VoiceView is silenced, pressing Play/Pause a second time pauses the playing media.        VoiceView only reads static content not marked as Described By text when a user presses the Menu button.Navigating with Review ModeVoiceView’s Review Mode allows a user to explore the grid layout of a Fire TV screen in detail, similarly to using linear navigation with a screen reader on a tablet. Use the following conventions for using Review Mode in your app:  Press-and-hold the Menu button to enter Review Mode, which will be announced by VoiceView.  The Left and Right buttons on the directional controller control linear navigation.  If a user presses Select when a non-actionable item is in focus, VoiceView speaks “Item not selectable.”  Press-and-hold the Menu button a second time to exit Review Mode.  After exiting Review Mode, the focus for accessibility returns to the previous cached location of keyboard focus, and VoiceView repeats an announcement of that focus.Using Review Mode with WebViewsA WebView can represent a complex UI within an application, containing both actionable items, such as links, and non-actionable items, such as static text and images. VoiceView supports WebViews because they are frequently used by many apps in the Amazon Appstore. In a VoiceView-enabled WebView, a user can use Review Mode to be able to navigate through the actionable items and gauge the context of the static content items. Note that Described By content is not available in WebViews.Navigating Focus Granularity Options in Review ModeWhen you first enable Review Mode, the level of granularity defaults to moving by individual controls. Press Up or Down to cycle through the available granularity options, such as character, word, control, or window. Granularity options in web content include link, list, or heading. Use the following conventions to navigate the various granularity options:  Press Left to return to the previous item at the currently selected granularity.  Press Right to move to the next item.  The granularity level is reset to “control” when you enter Review Mode.Implementing VoiceViewThis section discusses guidelines for implementing VoiceView for the following types of content:  Static/non-focusable content  Orientation text  Usage hintsImplementing VoiceView for Static or Non-focusable ContentVoiceView has implemented a separate navigation scheme for static or non-focusable content, which enables vision-impaired users to easily navigate this type of content using the Menu, Fast Forward, and Rewind buttons. Additionally, VoiceView supports markup that apps can use to associate static content with a selectable item.To associate a piece or container of static content with an item:  Set the key for com.amazon.accessibility.describedBy in the extras bundle from the AccessibilityNodeInfo for the item.      Set the value to be a string containing a space-delimited list of the view Ids of the containers or views which contain the description of this item.    When VoiceView encounters an item with the com.amazon.accessibility.describedBy key set, it will request a list of AccessibilityNodeInfo objects for the view Ids specified by the com.amazon.accessibility.describedBy value. VoiceView then reads the appropriate text or content descriptions, depending on your verbosity settings.  The following examples explain how a user would navigate static content in two different scenarios:Example 1: Consider a Fire TV movie details view where the movie title, year, duration, star ratings, etc. are all static content. The user presses Menu to prompt VoiceView to speak this content. The user then navigates using the Fast Forward and Rewind buttons.Example 2: Consider a Fire TV launcher screen that is used to navigate a movie catalogue. The text at the top of the screen updates to show the title, description, rating, and other information. Because this non-focusable content updates each time that the user selects a movie, the node containing the selected movie should be described by with the describedBy extra.Implementing VoiceView for Orientation TextTo help new users understand how Fire TV screens are laid out, VoiceView supports Orientation Text. The key for the com.amazon.accessibility.orientationText extra configures theOrientation Text for an AccessibilityNodeInfo.  The first time a user encounters an AccessibilityNodeInfo, VoiceView reads the text.  On subsequent visits, users can request context information by pressing the Menu button, which causes VoiceView to read the Orientation Text.Example: The first time a user lands on the main Fire TV home page, VoiceView reads, “Launcher. Use left and right to move between items on menus. Then use up and down to move between categories such as New Releases or Action Movies. Use left and right to move between items in the category.” Implementing VoiceView for Usage HintsFor users without visual impairment, the layout of a screen provides visual cues as to how to navigate and interact with that screen. For example, if item A is located above item B on a screen, the user might intuitively know to press the Down button to navigate from A to B. However, visually impaired users might require additional hints to aid their interactions with a screen. To help with this issue, VoiceView supports a set of extras that define Usage Hints to help with navigation within a screen:KeyValueExamplecom.amazon.accessibility.usageHint.remote(Fire TV only)String describing how to use or navigate the item using a remote.\"Press left and right to find an item.\"com.amazon.accessibility.usageHint.touch(Fire Tablets only)Description of how to interact with an item using a touch screen.\"Double tap to select. Double tap and hold for options.\"Example: Consider a screen with a multi-row grid of content, and the first of those rows is in focus, for example “Customers Also Watched”. In this case, use com.amazon.accessibility.usageHint.remote with the text such as “Press Left and Right to find an item, press Up and Down to move between collections of items.”Related Resources  Understanding assistive Technologies for Fire OS  Implementing Accessibility in Fire OS",
        "url": "fire-tv-preview-future-voiceview-accessibility-features.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "amazon-fire-game-controller-input-html": {
        "title": "Game Controller Input",
        "tags": "[]",
        "content": "Amazon Fire TV game controllers (as well as other controllers that conform to the Bluetooth HID gamepad profile) have specific buttons, Android motion, and key event constants. Use this information tocapture input events in your app.For guidelines on button behavior for all supported controllers, see Controller Behavior Guidelines. For information on handling input for Amazon Fire TV remote controls, see Amazon Fire TV Remote Input.  Buttons  Capturing Input  Primary and Secondary Input Events  Input Event ReferenceButtonsThe Amazon Fire TV (2nd Generation) Game Controller has these buttons:The Amazon Fire TV (1st Generation) Game Controller has these buttons:Capturing InputGame controllers used with Amazon Fire TV generate Android KeyEvent events for digital button presses (such as the A button), and MotionEvent events for analog control movement (such as a joystick action).You can handle simple button input with standard Android event listener interfaces and callbacks (onClick(), onFocusChange(), and so on).To capture specific button press events in your View, override input event handlers such as onKeyDown().Test for the input constants from the KeyEvent class to capture specific keys. For example, to capture a press from the A button, use this code:@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event){    boolean handled = false;    switch (keyCode){        case KeyEvent.KEYCODE_BUTTON_A:                // ... handle selections                handled = true;                break;     }     return handled || super.onKeyDown(keyCode, event);}To capture motion events, override the onGenericMotionEvent() event in your View. Use the input constants from the MotionEvent class to determine which control generated the movement, and the events in the MotionEvent class such as getAxisValue() to determine the values for the motion:@Overridepublic boolean onGenericMotionEvent(MotionEvent event){    // get changes in value from left joystick    float deltaX = event.getAxisValue(MotionEvent.AXIS_X);    float deltaY = event.getAxisValue(MotionEvent.AXIS_Y);    if (deltaX &gt; 0.5 &amp;&amp; deltaY &gt; 0.5) {        // do something        handled = true;    }    return handled || super.onGenericMotionEvent(event);}Primary and Secondary Input EventsSome game controller actions on Fire TV devices may raise more than one input event for a single action. For example, the D-Pad on the Amazon Fire TV game controller is an analog directional control (producing motion events), but a digital control on the Fire TV remote controls (producing key events).Similarly, the selection action is the A button on a game controller, but it is the D-Pad center button on Fire TV remotes. Some game controller actions on Amazon Fire TV first raise a primary input event (usually a motion event). Then, if those events are not handled by your app, they raise a second input event (usually a key event). Both of the primary and secondary input events are listed in the Input Event Reference table below.Secondary input events can help you simplify the process of handling game controller input. If your app is interested only in button and D-Pad events from a game controller, the secondary events enable you to ignore motion events altogether and only deal with key events.Similarly, because the A button generates both KEYCODE_BUTTON_A and KEYCODE_DPAD_CENTER, if your app supports the center D-Pad button on the Fire TV remotes, you do not have to also test for the A button.Note that your app may behave as if it is receiving double input if you do not properly handle the primary input events. Make sure your input event handlers return true if you have captured and handled an event. The secondary input event is not generated if the first has been captured.Input Event ReferenceThe following table describes the motion and key event constants for each game controller button, the suggested user experience behavior for those buttons, and the default behavior of those buttons in Amazon Fire TV user interface.Digital buttons report key events (KeyEvent), and analog controls report motion events (MotionEvent). See controller-behavior-guidelines for information on suggested behavior for controller input in your app. Note: Do not capture or throw away input events for any buttons you do not use in your app. Allowing the system to handle unused events enables background behavior such as media playback and volume control.The events listed in the Secondary Event column are raised in addition to the events in the MotionEvent or KeyEvent columns, if your app does not handle that primary event. See Primary and Secondary Input Events (above) for information on these secondary events.In this table, a game is an app that was submitted to the Amazon Appstore in the games category and installed onto the device from the Amazon Appstore.            Game Controller Button      MotionEvent      KeyEvent      Secondary Event      Default Behavior                  Home      none      none      none      For games with GameCircle support, launch the GameCircle overlay. For games without GameCircle support, display a “Game Paused” dialog. For all other apps, return the user to Home.                    Back      none      KEYCODE_BACK      none      Return the user to the previous operation or screen (Activity).              Menu      none      KEYCODE_MENU      none      Invoke the Android context menu (OptionsMenu).              GameCircle (Fire Game Controller 1st Generation Only)      none      none      none      For games with GameCircle support, launch the GameCircle overlay. For games without GameCircle support, display a “Game Paused” dialog. For all other apps, return the user to the Games screen of the launcher.              A      none      KEYCODE_BUTTON_A      KEYCODE_DPAD_CENTER      Select the item with the current focus.              B      none      KEYCODE_BUTTON_B      KEYCODE_BACK      Go back to the previous screen (Activity) (Same as Back).              X      none      KEYCODE_BUTTON_X      none      Do nothing.              Y      none      KEYCODE_BUTTON_Y      none      Do nothing.              Left (D-Pad) Right (D-Pad)      AXIS_HAT_X (&gt;0 is right)      none      KEYCODE_DPAD_LEFT KEYCODE_DPAD_RIGHT      Move the focus left or right in the user interface.              Up (D-Pad) Down (D-Pad)      AXIS_HAT_Y (&gt;0 is down)      none      KEYCODE_DPAD_UP KEYCODE_DPAD_DOWN      Move the focus upward or downward in the user interface.              Left Stick (Left/Right)      AXIS_X (&gt;0 is right)      none      KEYCODE_DPAD_LEFT KEYCODE_DPAD_RIGHT (if movement is &gt;.5)      Move the focus in the user interface in the given direction.              Left Stick (Up/Down)      AXIS_Y (&gt;0 is down)      none      KEYCODE_DPAD_UP KEYCODE_DPAD_DOWN (if movement is &gt;.5)      Move the focus in the user interface in the given direction.              Left Stick Press      none      KEYCODE_BUTTON_THUMBL      none      Play/Pause.              Right Stick (Left/Right)      AXIS_Z (&gt;0 is right)      none      none      Do nothing.              Right Stick (Up/Down)      AXIS_RZ (&gt;0 is down)      none      none      Do nothing.              Right Stick Press      none      KEYCODE_BUTTON_THUMBR      none      Play/Pause.              Play/Pause (Fire Game Controller 1st Generation Only)      none      KEYCODE_MEDIA_PLAY_PAUSE      none      Play/Pause.              Rewind (Fire Game Controller 1st Generation Only)      none      KEYCODE_MEDIA_REWIND      none      Rewind.              Fast Forward (Fire Game Controller 1st Generation Only)      none      KEYCODE_MEDIA_FAST_FORWARD      none      Fast forward.              Left Trigger (L2)      AXIS_BRAKE      none      none      Volume Up.              Left Shoulder (L1)      none      KEYCODE_BUTTON_L1      none      Rewind.              Right Trigger (R2)      AXIS_GAS      none      none      Volume Down.              Right Shoulder (R1)      none      KEYCODE_BUTTON_R1      none      Fast Forward.      ",
        "url": "amazon-fire-game-controller-input.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "amazon-fire-tv-remote-input-html": {
        "title": "Remote Input",
        "tags": "[]",
        "content": "All buttons, Android events, and behavior guidelines are the same for all remotes — with the exception of the voice search (microphone) button, which is only available on some remotes.For suggested guidelines on button behavior for all supported controllers, see Controller Behavior Guidelines. For information on handling input from the Amazon Fire Game Controller, see Amazon Fire TV Game Controller Input.  Buttons  Capturing Input  Input Event ReferenceButtonsMost Amazon Fire TV remote controls have these buttons. Some Fire TV remotes do not include the microphone or voice search buttons.Remote controlCapturing InputAll Amazon Fire TV remote controls generate KeyEvent events for button presses, as any Android input device does. You can handle controller button input with standard Android event listener interfaces and callbacks (onClick(), onFocusChange(), and so on). Neither the Amazon Fire TV Remote nor the Voice Remote raises motion events (from the Android MotionEvent class).To capture specific button press events in your View, override input event handlers such as onKeyDown(). Test for the input constants from the KeyEvent class to capture specific keys.For example, to capture the LEFT, RIGHT, and CENTER D-Pad button (as well as the A button on a game controller), use this code:@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event){boolean handled = false;switch (keyCode){case KeyEvent.KEYCODE_DPAD_CENTER:case KeyEvent.KEYCODE_BUTTON_A:        // ... handle selections        handled = true;        break;case KeyEvent.KEYCODE_DPAD_LEFT:        // ... handle left action        handled = true;        break;case KeyEvent.KEYCODE_DPAD_RIGHT:        // ... handle right action        handled = true;        break;}return handled || super.onKeyDown(keyCode, event);}As with all input events, your listener method should return true to capture the event and handle it, or pass that event on to super.onKeyDown() so that other controls can manage it.Input Event ReferenceThe following table describes the buttons, the Android KeyEvent constants, and the default behavior of those buttons. None of the Amazon Fire TV remotes raises motion events (from the Android MotionEvent class).If you do not capture a specific input event the default behavior occurs.            Button      KeyEvent      Default Behavior                  Home      none      Return the user to the Home screen. This is a system event and cannot be intercepted.              Back      KEYCODE_BACK      Return the user to the previous operation or screen (Activity).              Menu      KEYCODE_MENU      Invoke the Android context menu (OptionsMenu).              Microphone (Search) (Voice Remote only)      none      Invoke the system voice search. This is a system event and cannot be intercepted.              Select (D-Pad Center)      KEYCODE_DPAD_CENTER      Select the user interface item with the current focus.              Up (D-Pad)      KEYCODE_DPAD_UP      Move the focus upward in the user interface.              Down (D-Pad)      KEYCODE_DPAD_DOWN      Move the focus downward in the user interface.              Left (D-Pad)      KEYCODE_DPAD_LEFT      Move the focus left in the user interface.              Right (D-Pad)      KEYCODE_DPAD_RIGHT      Move the focus right in the user interface.              Play/Pause      KEYCODE_MEDIA_PLAY_PAUSE      Control media playback. Play/Pause is a toggle.              Rewind      KEYCODE_MEDIA_REWIND      Rewind or skip backwards in media playback contexts.              Fast Forward      KEYCODE_MEDIA_FAST_FORWARD      Fast Forward or skip ahead in media playback contexts.      ",
        "url": "amazon-fire-tv-remote-input.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "controller-behavior-guidelines-html": {
        "title": "Controller Behavior Guidelines",
        "tags": "[]",
        "content": "When you develop your app for the Amazon Fire TV platform, you can support input from different kinds of controllers. These controllers include the Amazon Fire TV Remote and Voice Remote, the Amazon Fire TV Game Controller, or any other controllers that support the Bluetooth gamepad HID profile.Use the motion and input events from the Remote Input and Game Controller Input to implement controller input for your app.This page provides recommendations for common app functionality across different controllers. None of these guidelines are requirements for publishing an app for Amazon Fire TV, and you may design controller input in the best way that works for your app. We suggest you follow these guidelines to enable a consistent user experience across different controllers, apps, and games. Note: With the exception of the Microphone button, the behavior of all Fire TV remote controls are identical. All of the guidelines in this document that refer to the Fire TV Remote also apply to the Fire TV Voice Remote.  Core Behavior  Navigation and Selection  Media Playback  Volume Control  GameplayCore Behavior            Action      Amazon Fire TV Remote Button      Amazon Fire TV Game Controller Button      Other Game Controller Button      Behavior                  Home      Home      Home      Home (if available)      This is a system event and cannot be captured in your app. When pressed, the system returns the user to Home. For apps categorized as games in the Amazon Appstore, the GameCircle overlay or “Game Paused” screens appear. A second Home press returns the user to Home. Implement onPause() to preserve state in your app or game in case of an unanticipated Home. Implement onResume() to continue when the app resumes. Audio apps may continue playing in the background by requesting the audio focus.              Back      Back      Back      B      Return to the previous operation or screen (Activity), or cancel the current operation or prompt. Capture this event to provide confirmation dialogs. For example, on the main screen of your app, capture Back to provide a “Do you want to Quit” dialog.              Menu      Menu      Menu      Y      Invoke the standard Android context menu (OptionsMenu). Capture this event to provide your own menu, or for any other purpose. If your menu only has one option, you can use Menu as a toggle for that option. In media apps, use Menu to show or hide the playback chrome.              Search      Microphone (Voice Remote only)      N/A      N/A      This is a system event and cannot be captured in your app. When pressed, voice search is invoked. Implement onPause() to preserve state in your app or game when voice search launches, and onResume() to continue after it is complete. In audio apps, pause playback or lower the volume when voice search is active. In video apps, mute the audio or pause playback when voice search is active.              GameCircle      N/A      GameCircle      N/A      This is a system event and cannot be captured in your app. When pressed, the system displays the GameCircle overlay (for games with GameCircle support), a “Game Paused” dialog (for games without GameCircle support), or returns to the Games page in the launcher (for all other apps).  Note: Sideloaded apps always return to the Games page of the Launcher even if they implement GameCircle. Only apps that have been submitted to the Amazon Appstore demonstrate correct GameCircle behavior. You can use Live App Testing to test your GameCircle integration before you submit your app.  Implement  onPause() to preserve state in your app or game when the GameCircle button is pressed. Implement onResume() to continue when the user returns to your game.      Navigation and SelectionThe following table describes the recommended behavior for user interface navigation and selection. For items that show multiple buttons, provide support for both those buttons.            Action      Amazon Fire TV Remote Button      Amazon Fire TV Game Controller Button      Other Game Controller Button      Behavior                  Select/Main Action      D-Pad Center      A      A      Select the item in focus, confirm menu options or prompts, or perform the main game action.              Cancel/Back      Back      Back B      B      Cancel the current operation, or return to the previous screen. Intercept this action to provide confirmation dialogs (“Are you sure you want to quit?”)              UpDownLeftRight      D-Pad      D-PadLeft Stick      D-PadLeft Stick      Move the input focus in the appropriate direction.  On the Amazon Fire Game Controller and other game controllers, the left stick should have the same behavior as the D-Pad.    Media PlaybackThe following table describes the recommended behavior for media playback. Note the following:  If your app does not play media or use the analog sticks or shoulder buttons (L1/R1), do not capture the events for those buttons. Doing so may interfere with the system’s ability to control media playing in the background.  If your app uses a framework such as Unity, you can ignore this recommendation, since the ability to pass key events through to the system is not supported in those frameworks.  If your app or game does use any of these buttons for other purposes, the user may access system media control from the GameCircle overlay (GameCircle button) or in the Fire TV launcher.            Action      Amazon Fire TV Remote Button      Amazon Fire TV Game Controller Button      Amazon Fire Game Controller (1st Generation) Button      Other Game Controller Button      Behavior                  Play/Pause      Play/Pause      ALeft/Right Stick Press      Play/Pause      A      Toggle media play or pause.              Rewind      RewindLeft (D-Pad)Left Shoulder (L1)      Left Shoulder (L1)      RewindLeft (D-Pad)Left Shoulder (L1)      Left (D-Pad) Left Shoulder (L1)      Rewind or skip backwards in media playback contexts. The exact behavior is dependent on the specific media: you can use this button to scrub video, to skip to the previous music track, or move to the previous photo in a slide show.              Fast Forward      FFRight (D-Pad)Right Shoulder (R1)      Right Shoulder (R1)      FFRight (D-Pad)Right Shoulder (R1)      Right (D-Pad)Right Shoulder (R1)      Fast-forward in media playback contexts. The exact behavior is dependent on the specific media: you can use this button to scrub video, to skip to the next music track, or move to the next photo in a sideshow.      Volume ControlYou can stream audio to the headphone jack on the Amazon Fire TV Game Controller. Volume control for audio playback is available with the left and right trigger buttons (L2/R2). Volume control is a system function and cannot be mapped to other buttons in your app.Note the following:  If your app or game does not use these buttons, do not capture those input events. Doing so may interfere with the user’s ability to control the volume.  If your app or game does use those buttons for other purposes, the user may access system volume control from the GameCircle overlay or in the Fire TV launcher.            Action      Amazon Fire TV Game Controller Button                  Volume Up      Left Trigger (L2)              Volume Down      Right Trigger (R2)      GameplayAlthough gameplay user interfaces are highly individual, the following table describes basic recommendations.            Action      Amazon Fire TV Remote Button      Amazon Fire TV Game Controller Button      Other Game Controller Button                  Primary Gameplay Action      D-Pad Center      A      A              Secondary Gameplay Action      no recommendation      B      B      ",
        "url": "controller-behavior-guidelines.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "controller-image-assets-html": {
        "title": "Controller Image Assets",
        "tags": "[]",
        "content": "If your app or game provides instructions or help screens for how to use a controller, you may freely use the controller images and button hints on this page in your app. Download All Images  Icon Hints for Buttons  Amazon Fire TV Voice Remote  Amazon Fire TV Remote  Amazon Fire TV Game Controller  Amazon Fire Game ControllerIcon Hints for ButtonsUse these hints to provide instructions in your app or game, for example:Amazon Fire TV Voice RemoteAmazon Fire TV RemoteAmazon Fire TV Game ControllerAmazon Fire Game Controller",
        "url": "controller-image-assets.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "controller-input-with-unity-html": {
        "title": "Controller Input with Unity",
        "tags": "[]",
        "content": "You can use the Unity development tools to create apps and games for Amazon Fire TV devices as you would any Android device.Although we do not provide a Unity plugin for Fire TV development, there are packages in the Unity Asset Store to enable game controller support. In particular, InControl by Gallant Games is one with which our developers have had great success. InControl is a cross-platform input manager for Unity3D that standardizes control mappings for a variety of common controllers.You can also use the Unity input manager to configure controller input for your game. Use the tables below to map the buttons on the Amazon Fire TV remotes and game controllers with the Unity input manager buttons and axes. Note: The input references in this document apply to Unity 4.3.x and higher, but are subject to change with future Unity releases.  Remote Input  Game Controller Input  Controller NamesRemote InputUse these values in Unity to map the buttons on both the Amazon Fire TV Remote and Voice Remote. See KeyCode for more details about Unity KeyCode values.            Button      Unity Input Manager Value      Unity KeyCode Value                  Home      one (system event)      none (system event)              Back      none (not supported)      KeyCode.Escape              Menu      none (not supported)      KeyCode.Menu              Microphone (Search)      none (system event)      none (system event)              Select (D-Pad Center)      joystick button 0      KeyCode.JoystickButton0              Left (D-Pad)      5th Axis      KeyCode.LeftArrow              Right (D-Pad)      5th Axis      KeyCode.RightArrow              Up (D-Pad)      6th Axis      KeyCode.UpArrow              Down (D-Pad)      6th Axis      KeyCode.DownArrow              Play/Pause      none (not supported)      none (not supported)              Rewind      none (not supported)      none (not supported)              Fast Forward      none (not supported)      none (not supported)      Game Controller InputUse these values in Unity to map the buttons on the Amazon Fire Game Controller. See KeyCode for more details about Unity KeyCode values.            Game Controller Button      Unity Input Manager Value      Unity KeyCode Value                  Home      none (system event)      none (system event)              Back      none (system event)      KeyCode.Escape              Menu      none (system event)      KeyCode.Menu              GameCircle      none (system event)      none (system event)              A      joystick button 0      KeyCode.JoystickButton0              B      joystick button 1      KeyCode.JoystickButton1              X      joystick button 2      KeyCode.JoystickButton2              Y      joystick button 3      KeyCode.JoystickButton3              Left (D-Pad)      5th Axis      none              Right (D-Pad)      5th Axis      none              Up (D-Pad)      6th Axis      none              Down (D-Pad)      6th Axis      none              Left Stick (Left/Right)      X Axis 1st Axis      none              Left Stick (Up/Down)      Y Axis 2nd Axis      none              Left Stick Press      joystick button 8      KeyCode.JoystickButton8              Right Stick (Left/Right)      3rd Axis      none              Right Stick (Up/Down)      4th Axis      none              Right Stick Press      joystick button 9      KeyCode.JoystickButton9              Play/Pause      none (not supported)      none (not supported)              Rewind      none (not supported)      none (not supported)              Fast Forward      none (not supported)      none (not supported)              Left Trigger (L2)      13th Axis      none              Left Shoulder (L1)      joystick button 4      KeyCode.LeftShift KeyCode.JoystickButton4              Right Trigger (R2)      12th Axis      none              Right Shoulder (R1)      joystick button 5      KeyCode.RightShift KeyCode.JoystickButton5      Controller NamesController names are available in Unity with the Input.GetJoystickNames() method. Use these values for each controller:  Remote: \"Amazon Fire TV Remote\"  Voice Remote: \"Amazon Fire TV Remote\"  Game controller: \"Amazon Fire Game Controller\"",
        "url": "controller-input-with-unity.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "gamecontroller-api-html": {
        "title": "GameController API (Deprecated)",
        "tags": "[]",
        "content": "Amazon Fire TV devices support up to seven Bluetooth controllers to be connected to the system at the same time, which enables you to develop multi-player apps and games. To identify controllers and manage input events, use standard Android mechanisms including the InputDevice class and Android event handlers onKeyUp(), onKeyDown() or onGenericMotionEvent()).In the past the Fire TV platform included a custom API to assist with input management of game controllers. As of Fire OS 5, the GameController API is deprecated and will be removed from the platform at a later date. If your app uses the GameController API we strongly suggest you move to using the standard Android (Lollipop, API 22) InputDevice APIs instead.This document describes how to migrate your code from the deprecated GameController API to standard Android input device APIs.  Controllers and Player Numbers  Migrating from the Amazon GameController API  Player Numbers in the GameController API (Deprecated)          Getting Player Numbers by Device ID      Getting Device IDs by Player Number      Getting the Number of Players      Getting GameController Objects by Player        Frame-Based Input Events in the GameController API (Deprecated)          Forwarding Events to GameController      Implementing the Game Loop                  Button Presses                      GameController API Event Constants (Deprecated)Controllers and Player NumbersThe GameController API is used primarily to associate player numbers with attached controllers. Much of this behavior is available in the standard Android InputDevice class through the getControllerNumber() method.Each controller is assigned a unique number when that controller is connected to Fire TV. The number may change if the controller is disconnected and connected again.Input devices such as remote controls that are not game controllers (specifically, that are not indicated by either InputDevice.SOURCE_GAMEPAD or InputDevice.SOURCE_JOYSTICK) have 0 as the controller number.Migrating from the Amazon GameController APIIn Fire OS 5, calls to the Fire TV GameController API still operate as they did previously. However, the GameController API is deprecated and will be removed from the platform at a later date. We strongly suggest that if your app currently uses the GameController API that you migrate your code to use standard Android input device management.To migrate your app from the GameController API:  Remove all references to the GameController class, including the com.amazon.device.gamecontroller package.  Remove GameController.init() from your onCreate() method.  Replace GameController methods for getting the player ID with Android InputDevice.getControllerNumber().  Replace the GameController event constants with standard Android KeyEvent or MotionEvent constants, as in the table below.            GameController Input Constant      Android Key or Motion Event Constant                  GameController.AXIS_STICK_LEFT_X      MotionEvent.AXIS_Y              GameController.AXIS_STICK_LEFT_Y      MotionEvent.AXIS_Y              GameController.AXIS_STICK_RIGHT_X      MotionEvent.AXIS_Z              GameController.AXIS_STICK_RIGHT_Y      MotionEvent.AXIS_RZ              GameController.AXIS_TRIGGER_LEFT      MotionEvent.AXIS_BRAKE              GameController.AXIS_TRIGGER_RIGHT      MotionEvent.AXIS_GAS              GameController.BUTTON_A      KeyEvent.KEYCODE_BUTTON_A              GameController.BUTTON_B      KeyEvent.KEYCODE_BUTTON_B              GameController.BUTTON_X      KeyEvent.KEYCODE_BUTTON_X              GameController.BUTTON_Y      KeyEvent.KEYCODE_BUTTON_Y              GameController.BUTTON_SHOULDER_LEFT      KeyEvent.KEYCODE_BUTTON_L1              GameController.BUTTON_SHOULDER_RIGHT      KeyEvent.KEYCODE_BUTTON_R1              GameController.BUTTON_TRIGGER_LEFT      KeyEvent.KEYCODE_BUTTON_L2              GameController.BUTTON_TRIGGER_RIGHT      KeyEvent.KEYCODE_BUTTON_R2              GameController.BUTTON_STICK_LEFT      KeyEvent.KEYCODE_BUTTON_THUMBL              GameController.BUTTON_STICK_RIGHT      KeyEvent.KEYCODE_BUTTON_THUMBR              GameController.BUTTON_DPAD_UP      KeyEvent.KEYCODE_DPAD_UP              GameController.BUTTON_DPAD_DOWN      KeyEvent.KEYCODE_DPAD_DOWN              GameController.BUTTON_DPAD_LEFT      KeyEvent.KEYCODE_DPAD_LEFT              GameController.BUTTON_DPAD_RIGHT      KeyEvent.KEYCODE_DPAD_RIGHT              GameController.BUTTON_DPAD_CENTER      KeyEvent.KEYCODE_DPAD_CENTER              GameController.BUTTON_AXIS_HAT_X      MotionEvent.AXIS_HAT_X              GameController.BUTTON_AXIS_HAT_Y      MotionEvent.AXIS_HAT_Y      Player Numbers in the GameController API (Deprecated)Although you can connect up to seven Bluetooth game controllers to an Amazon Fire TV device, only four of those controllers are assigned to player numbers. Note that controllers are assigned to player number slots and do not re-shuffle when an individual controller is disconnected, that is, player numbers are not consecutive.The GameController API includes methods to access the player numbers for available game controllers. If your game supports more than four players you can always manage controllers and player numbers inside your game on your own as well. Note: All of the methods in this section throw a NotInitializedException exception if you have not called GameController.init() before using them.Getting Player Numbers by Device IDUse the GameController.getPlayerNumber() static method with an Android device ID to get the player number for that device. You can get an Android device ID with the InputDevice.getDeviceIDs() method, from any key or motion event (InputEvent.getDeviceId()), or from a player number with GameController.getDeviceID().Player numbers are defined system-wide. Not all device IDs may be associated with a player number. If this is the case getPlayerNumber() throws the PlayerNumberNotFoundException exception.int[] ids = InputDevice.getDeviceIds();for (int i=0; i &lt; ids.length; i++) {    try {       int playerNum = GameController.getPlayerNumber(ids[i]);    }   catch (PlayerNumberNotFoundException e) {        // ...    }    // ...}Getting Device IDs by Player NumberThe GameController.getDeviceID() method is the reverse of getPlayerNumber(); given a player number (from 1 to 4), it returns the Android device ID. Not all player numbers may be associated with device IDs. If this is the case GameController.getDeviceID() throws the DeviceNotFoundException exception.for (int n = 0; n &lt; GameController.MAX_PLAYERS; n++) {    try {        int devicenum = GameController.getDeviceID(n + 1);    }    catch (DeviceNotFoundException e) {        // ...    }    // ...}Getting the Number of PlayersUse the GameController.getPlayerCount() static method to get the number of available players. Note that player numbers are not necessarily consecutive, for example, two players may be assigned to slots 2 and 4.int players = GameController.getPlayerCount();Getting GameController Objects by PlayerUse the GameController.getControllerByPlayer() static method with a player number to retrieve a GameController object for use with frame-based event input (see Frame-Based Input Events). Player numbers are assigned by the system and can be from 1 to 4. Not all player numbers may have associated controllers. If this is the case GameController.getControllerbyPlayer() throws the PlayerNumberNotFoundException exception.for (int n = 0; n &lt; GameController.MAX_PLAYERS; n++) {    GameController gameController = null;    try {        gameController =                GameController.getControllerByPlayer(n + 1);    }    catch (PlayerNumberNotFoundException e) {        // ...    }}Frame-Based Input Events in the GameController API (Deprecated)You can always handle input events from controller using the standard Android event-driven programming model, in which your code handles input events as they arrive. The GameController class enables you to use a frame-based input model, in which events are cached and you can query the state of the controller before rendering each frame. With this model, you use the following steps:  Provide your own game loop to replace the standard Android event model.  Forward standard input events to GameController.  For each frame within the loop:          Query the state of each controller for player input.      Render the frame using that input data.       Note: All of the methods in this section throw a NotInitializedException exception if you have not called GameController.init() before using them.Forwarding Events to GameControllerTo use the GameController API to manage your input events, forward key and motion events to the GameController class to handle. Override the onKeyUp(), onKeyDown() and onGenericMotionEvent() methods to pass those events to GameController://Forward key down events to GameController so it can manage state@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) {    boolean handled = false;    try {        handled = GameController.onKeyDown(keyCode, event);    }    catch (DeviceNotFoundException e) {    }    return handled || super.onKeyDown(keyCode, event);}//Forward key up events to GameController so it can manage state@Overridepublic boolean onKeyUp(int keyCode, KeyEvent event) {    boolean handled = false;    try {        handled = GameController.onKeyUp(keyCode, event);    }    catch (DeviceNotFoundException e) {    }    return handled || super.onKeyUp(keyCode, event);}//Forward motion events to GameController so it can manage state@Overridepublic boolean onGenericMotionEvent(MotionEvent event) {    boolean handled = false;    try {        handled = GameController.onGenericMotionEvent(event);    }    catch (DeviceNotFoundException e) {    }    return handled || super.onGenericMotionEvent(event);}Implementing the Game LoopImplement the game loop on your own thread. Inside the run() method for that thread, test for input and render each frame based on that input. Don’t forget to stop and start the thread in your activity’s onPause()) and onResume()) methods.Within the loop, use GameController.startFrame() to reset the input event queue between frames. Here’s a simple example:while (running){    GameController.startFrame();    //Draw the background    //Draw each player    for (int n = 0; n GameController.DEAD_ZONE * GameController.DEAD_ZONE){    //stick angle is greater than the center dead zone    x[n] += Math.round(deltaX * 10);    y[n] += Math.round(deltaY * 10);}Button PressesUse the wasButtonPressed() or wasButtonReleased() methods to test whether button input has occurred since the last frame:if (gameController.wasButtonPressed(GameController.BUTTON_A)    || gameController.wasButtonPressed(GameController.BUTTON_DPAD_CENTER)){    // draw a circle at the current player's x,y position}Use isButtonPressed() to test the current state of any button://Dpad button presses, move the player's position:x[n] += gameController.isButtonPressed(GameController.BUTTON_DPAD_RIGHT) ? +5 : 0;x[n] += gameController.isButtonPressed(GameController.BUTTON_DPAD_LEFT) ? -5 : 0;y[n] += gameController.isButtonPressed(GameController.BUTTON_DPAD_DOWN) ? +5 : 0;y[n] += gameController.isButtonPressed(GameController.BUTTON_DPAD_UP) ? -5 : 0;GameController API Event Constants (Deprecated)The GameController class includes a set of static event constants that represent button and axis event types. These constants are identical to the standard constants from the KeyEvent and MotionEvent classes, but are the same for any controller, and are often more logically named. For example, GameController.BUTTON_A is identical to KeyEvent.KEYCODE_BUTTON_A . Use these constants with the frame-based controller model described in Frame-Based Input Events. Note: For standard controller buttons (Back, Media Play/FF/Rewind), manage those events with standard Android KeyEvent and MotionEvent events. The Home and GameCircle buttons are system events and cannot be captured by your app.            Game Controller Control      Analog Movement: wasAxisChanged() getAxisValue()      Button Presses:  wasButtonPressed()  wasButtonReleased()  isButtonPressed()      Default Behavior (if the event is not handled by your code)                  D-Pad  (Left/Right)      AXIS_HAT_X  (&gt;0 is right)      none      Move the focus in the user interface in the given direction.              D-Pad  (Up/Down)      AXIS_HAT_Y  (&gt;0 is down)      none      Move the focus in the user interface in the given direction.              Left Stick  (Left/Right)      AXIS_STICK_LEFT_X  (&gt;0 is right)      none      Move the focus in the user interface in the given direction.              Left Stick  (Up/Down)      AXIS_STICK_LEFT_Y  (&gt;0 is down)      none      Move the focus in the user interface in the given direction.              Left Stick Press      none      BUTTON_STICK_LEFT      Do nothing.              Right Stick  (Left/Right)      AXIS_STICK_RIGHT_X (&gt;0 is right)      none      Do nothing.              Right Stick  (Up/Down)      AXIS_STICK_RIGHT_Y  (&gt;0 is down)      none      Do nothing.              Right Stick Press      none      BUTTON_STICK_RIGHT      Do nothing.              A      none      BUTTON_A      Select the item with the current focus.              B      none      BUTTON_B      Go back to the previous screen (Activity) (Same as Back).              X      none      BUTTON_X      Do nothing.              Y      none      BUTTON_Y      Do nothing.              Left Trigger (L2)      AXIS_TRIGGER_LEFT      none      Select the item with the current focus.              Left Shoulder (L1)      none      BUTTON_SHOULDER_LEFT      Do nothing.              Right Trigger (R2)      AXIS_TRIGGER_RIGHT      none      Select the item with the current focus.              Right Shoulder (R1)      none      BUTTON_SHOULDER_RIGHT      Do nothing.      ",
        "url": "gamecontroller-api.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "identifying-controllers-html": {
        "title": "Identifying Controllers",
        "tags": "[]",
        "content": "The Amazon Fire TV platform enables users to connect up to seven Bluetooth controllers at the same time. If your app or game supports input from multiple users or players, you need to be able to determine the connected controllers, identify the features of those controllers, and differentiate user input coming from different controllers.The Fire TV platform uses standard Android features of the InputDevice class. The InputDevice class enables you to get a list of all the connected input devices (including controllers) and query the features of an input device.You can also get an input device object from any key or motion event, which enables you to handle input from different controllers or different users as it occurs.  Getting Input Devices and Device IDs          Get All Input Device IDs      Get the Input Device ID from a Key or Motion Event        Identifying Controller Features          Is this Device a Game Controller?      Is this Device a Remote?      Is this Device a Second Screen App?      Getting Input Devices and Device IDsInput devices connected to Amazon Fire TV are represented by the Android InputDevice class. Connected input devices are given a device ID at system boot and when a new device is added.  Input devices in the list of IDs can be actual controllers such as game controllers, or they can represent other forms of input such as the onscreen keyboard. The device IDs themselves are arbitrary and do not uniquely identify a specific controller or controller type.You can get the list of all the available device IDs to determine the number and type of controllers available to your app or game. You can also get device IDs or input device objects from a specific key or motion event, to determine which controller was being used for that event.Get All Input Device IDsYou can get an array of all the available input devices IDs with the static InputDevice.getDeviceIds() method, and then associate those IDs with actual input device objects with InputDevice.getDevice():int[] ids = InputDevice.getDeviceIds();for (int i=0;i &lt; ids.length; i++) {// get an InputDevice object based on the device IDInputDevice device = InputDevice.getDevice(ids[i]);// ...}Note that the list of device IDs you get from the getDeviceIds() method contains only those input devices that are actually connected to the system.  Some Bluetooth controllers may disconnect (sleep) to save power if they have not been used in some time, or a controller may disconnect if it is out of range.Sleeping or otherwise unavailable controllers are not considered connected and are not enumerated in the list of device IDs.  You can listen for controller connect and disconnect events by implementing the InputDeviceListener interface.Get the Input Device ID from a Key or Motion EventYou can get the ID of the device that triggered a key or motion event inside an event handler with the InputEvent.getDeviceId() method:public boolean onKeyDown(int keyCode, KeyEvent event) {int id = event.getDeviceId();InputDevice device = InputDevice.getDevice(id);}Or, just get the input device object itself:public boolean onKeyDown(int keyCode, KeyEvent event) {InputDevice device = event.getDevice();}Identifying Controller FeaturesAndroid input device IDs are arbitrary and do not uniquely identify any controller or controller type.  To determine the type of input device, query the features of that device to determine whether input came from a controller (a remote, game controller, or second screen app), or from some other device.Use the InputDevice.getSources() method to get the features of an input device.  This method returns an integer bitmap that indicates device capabilities and features.  Use the constants defined the InputDevice class to compare that bitmap with the specific features your app is interested in.// get an InputDevice object based on the device IDInputDevice device = InputDevice.getDevice(id);// getSources() gives you an integer bitmap that defines the features of the device;// compare with constants from InputDevice to find controller featuresif ((device.getSources() &amp; InputDevice.SOURCE_CLASS_JOYSTICK != 0 {// this controller has a joystick}You can also get input device feature bitmaps directly from key and motion events with the InputEvent.getSource() method:public boolean onGenericMotionEvent(MotionEvent event) {// did this event come from a joystick?if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {// ... handle input events from controllers with joysticks }// ...}Is this Device a Game Controller?You can identify game controllers (both the Amazon game controller and other game controllers) by testing for both the InputDevice.SOURCE_GAMEPAD and InputDevice.SOURCE_JOYSTICK constants.  Note that this code does not differentiate between an Amazon game controller and a Bluetooth controller from another manufacturer.int hasFlags = InputDevice.SOURCE_GAMEPAD | InputDevice.SOURCE_JOYSTICK;boolean isGamepad = inputDevice.getSources() &amp; hasFlags == hasFlags;Is this Device a Remote?You can identify the Amazon Fire TV Remote or Voice Remote by the InputDevice.SOURCE_DPAD constant.  However, as some keyboards may also identify themselves as having a D-Pad, you should also test for the keyboard type (InputDevice.KEYBOARD_TYPE_NON_ALPHABETIC):int hasFlags =  InputDevice.SOURCE_DPAD;bool isRemote = (inputDevice.getSources() &amp; hasFlags == hasFlags)&amp;&amp; inputDevice.getKeyboardType() == InputDevice.KEYBOARD_TYPE_NON_ALPHABETIC;Is this Device a Second Screen App?You can identify the Amazon Second Screen app with both the InputDevice.SOURCE_MOUSE and InputDevice.SOURCE_TOUCHPAD constants.int hasFlags =  InputDevice.SOURCE_MOUSE | InputDevice.SOURCE_TOUCHPAD;bool isRemote = inputDevice.getSources() &amp; hasFlags == hasFlags;",
        "url": "identifying-controllers.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "supporting-controllers-on-amazon-fire-tv-html": {
        "title": "Controllers Overview",
        "tags": "[]",
        "content": "The Amazon Fire TV platform supports user input from the Amazon Fire TV Remote, the Fire TV Voice Remote, the Fire game controller, and other game controllers that support the Bluetooth HID gamepad profile. All controllers must be paired with the device to be used.All the Amazon Fire TV controllers are Android input devices. You use the same techniques and APIs to manage input from those devices as you would any other Android input device.In particular, simple input from any controller such as navigation or selection can be managed through key events in the same way you would handle input from a keyboard or a button pad.",
        "url": "supporting-controllers-on-amazon-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "amazon-fire-tv-dolby-integration-guidelines-html": {
        "title": "Dolby Integration Guidelines for Fire TV",
        "tags": "[]",
        "content": "This documentation provides integration guidelines for app developers who need to support Dolby Digital or Dolby Digital Plus audio content in their apps. Important: All apps that support Dolby audio content must also work on devices that do NOT support a Dolby decoder.You can see the Dolby settings in Fire TV by going to Settings &gt; Display &amp; Sounds &gt; Audio &gt; Dolby Digital Output.  Terms  Four Ways to Play Dolby Audio  Option 1: Custom Media Player Approach          AudioManager Overview      AudioTrack Overview      MediaCodec (Optional) Overview        Dolby Support in Fire TV – 2nd Generation          AudioTrack (Fire TV – 2nd Generation)      AudioManager (Fire TV – 2nd Generation)      MediaCodec (Fire TV – 2nd Generation)        Dolby Support in FireTV Stick          MediaCodec (Fire TV Stick)      AudioTrack (Fire TV Stick)                  A. Create the Decoder by MimeType          B. Handle MediaCodec Output Format Change Notification          C. Limitations of AudioTrack for Dolby encoding formats                      Dolby Support in Fire TV — 1st Generation          MediaCodec (Fire TV — 1st Generation)      AudioTrack (Fire TV — 1st Generation)      Limitations of AudioTrack for Dolby Encoding Formats (Fire TV — 1st Generation)        Option 2: Use ExoPlayer  Option 3: Use Other Supported Media Players  Option 4: Use Android Media Player  Handling non-Dolby End-Points and Private Listening ModesTermsNote the following abbreviations used in this documentation:  EAC3: Dolby Digital Plus (DDP)  AC3: Dolby Digital (DD)The following terms are used to refer to Fire TV:  Fire TV (1st Generation): Refers to the first version of the Fire TV box (released in 2014).  Fire TV (2nd Generation): Refers to the second version of the Fire TV box (released in 2015).  Fire TV Stick: Refers to the first (and so far only) version of the Fire TV stick (released in 2014). Note: Usually the latest version of the Fire TV box is just referred to as “Fire TV,” but since this documentation contrasts two versions of Fire TV, the terms “Fire TV – 1st Generation” and “Fire TV – 2nd Generation” are used. These terms always refer to the box. There is just one version of Fire TV Stick, so there’s no need to distinguish versions through a 1st Generation or 2nd Generation descriptor.Four Ways to Play Dolby AudioYou can play Dolby (DD or DDP) audio content in your app in four ways:  Custom Media Player Approach  ExoPlayer  Other Supported Media Players  Android Media PlayerOption 1: Custom Media Player ApproachImplement a custom player that uses  AudioManager,  AudioTrack, and (optionally)  MediaCodec APIs. This section specifies the use of AudioManager, AudioTrack, and optionally MediaCodec APIs to play Dolby audio content as recommended by Android.AudioManager OverviewAndroid L enhanced the ACTION_HDMI_AUDIO_PLUG intent in AudioManager to report the capabilities of sinks in Lollipop. This intent is broadcast whenever HDMI is plugged into or unplugged from to the device.This intent also has a provision for apps to detect the capabilities of the connected endpoint (AVR or TV) via EXTRA_ENCODINGS present in the intent. The possible values are one of the ENCODING_XXXX values. For example:  ENCODING_PCM_16BIT  ENCODING_AC3  ENCODING_E_AC3, and so onAudioTrack OverviewAndroid L added the support of ENCODING_AC3 and ENCODING_E_AC3 encoding formats to AudioFormat. If the AudioTrack is configured with Dolby encoding format, and if the connecting endpoint supports that encoding format, AudioTrack accepts the Dolby raw bitstream as input and passes the bitstream to the endpoint after IEC61937 packetization. AudioTrack supports only clear (not encrypted) input bitstream.Additionally, the creation of AudioTrack fails if the encoding format is not supported by the connected endpoint.Applications can use the ACTION_HDMI_AUDIO_PLUG intent to find the list of supported Dolby encoding formats for the connected device, create AudioTrack with one of the supported Dolby encoding formats, and pass the corresponding Dolby raw bitstream (in clear) as input to AudioTrack to achieve Dolby pass-through playback.Optionally, AudioTrack can also support transcoding DDP bitstream to DD if the connected endpoint only supports DD. This feature is made available to the application by adding ENCODING_E_AC3 to the EXTRA_ENCODINGS extra of the ACTION_HDMI_AUDIO_PLUG intent if the endpoint only supports DD.Hence, from an application’s perspective, an endpoint that supports DD also supports DDP and can continue to send DDP bitstream to AudioTrack, which internally transcodes the bitstream to DD before passing it through.MediaCodec (Optional) Overview Tip: Apps that use MediaCodec for Dolby must also be able to operate on devices without Dolby availability in MediaCodec. To do so, call findDecoderForFormat. If Dolby is not supported, apps must fall back to non-Dolby (such as AAC) content.AudioTrack does not support Dolby audio content that is encrypted with DRM keys. Hence, for an encrypted Dolby audio bitstream, it is mandatory to use MediaCodec APIs to decrypt the bitstream and then pass the decrypted bitstream to AudioTrack.Android provides a generic raw audio decoder via MediaCodec interface named “OMX.google.raw.dec,” which is essentially a no-op (no operation) copy decoder. If the bitstream is encrypted, it uses MediaCrypto APIs to decrypt the bitstream and outputs it. Apps must use this decoder to decrypt the encrypted Dolby bitstream and pass the clear Dolby bitstream to AudioTrack.Optionally, a platform can support Dolby decoder via MediaCodec interface. This decoder decodes the Dolby audio bitstream to PCM. Applications can use findDecoderForFormat to detect the presence of a decoder that supports Dolby MIME type.The following table summarizes various Dolby playback scenarios in a typical Android TV that does not support DDP to DD transcode in AudioTrack.                  Connected End-Point capabilities (AVR or TV)         EXTRA_ENCODINGS in ACTION_HDMI_AUDIO_PLUG intent         Source Audio Stream         MediaCodec (optional)         AudioTrack encoding format         Scenario                      EAC3, AC3 and PCM        ENCODING_E_AC3, ENCODING_AC3, ENCODING_PCM_16BIT        Clear EAC3 or AC3        None        ENCODING_E_AC3 or ENCODING_AC3        DDP or DD pass-through                      Encrypted EAC3 or AC3           OMX.google.raw.dec                              AC3 and PCM          ENCODING_AC3, ENCODING_PCM_16BIT          Clear AC3          None          ENCODING_AC3           DD passthrough                           Encrypted AC3             OMX.google.raw.dec                             PCM           ENCODING_PCM_16BIT           AAC or any non-Dolby (recommended)           OMX.google.aac.decoder           ENCODING_PCM_16BIT           PCM playback                       AC3 or EAC3 (only if non-dolby stream is unavailable &amp; Dolby decoder is available in the platform)         OMX.google.aac.decoder, OMX.dolby.eac3.decoder         ENCODING_PCM_16BIT         DD or DDP decode      Dolby Support in Fire TV – 2nd GenerationFire TV (2nd Generation) 4K was launched with Android L based Fire OS 5 and fully complies with the Android L recommended Dolby architecture. This section describes the Dolby support in Fire TV (2nd Generation).AudioTrack (Fire TV – 2nd Generation)AudioTrack supports both DDP/DD pass-through and DDP-to-DD transcoder. The AudioTrack accepts Dolby raw bitstream and, depending on the Dolby capability of the endpoint, decides to either do a DD/DDP pass-through or DDP-to-DD transcode and pass-through.AudioManager (Fire TV – 2nd Generation)Since AudioTrack also supports transcoding DDP bitstream to DD when the connected endpoint only supports DD, AudioManager indicates this by adding ENCODING_E_AC3 to the EXTRA_ENCODINGS extra of the ACTION_HDMI_AUDIO_PLUG intent if the endpoint only supports DD.Hence, from an application’s perspective, an endpoint that supports DD also supports DDP and can continue to send DDP bitstream to AudioTrack, which internally transcodes it to DD before passing it through.MediaCodec (Fire TV – 2nd Generation)The MediaCodec for Dolby Decoder (OMX.dolby.ac3.decoder &amp; OMX.dolby.eac3.decoder) supports decoding to PCM only. Additionally, Dolby decoders also down-mixes the multi-channel output to stereo. So irrespective of the number of input channels of the content, the output is always stereo PCM. The table below summarizes various Dolby playback scenarios in Fire TV – 2nd Generation:                  Connected End-Point capabilities (AVR or TV)         EXTRA_ENCODINGS in ACTION_HDM_AUDIO_PLUG intent         Source Audio Stream         MediaCodec         Output Mime Type of MediaCodec         AudioTrack encoding format         Scenario                      EAC3, AC3 and PCM        ENCODING_E_AC3, ENCODING_AC3, ENCODING_PCM_16BIT        EAC3 or AC3        OMX.google.raw.dec**        audio/eac3 or audio/ac3        ENCODING_E_AC3 or ENCODING_AC3        DDP / DD pass-through                      AC3 and PCM           ENCODING_E_AC3*, ENCODING_AC3, ENCODING_PCM_16BIT           EAC3 or AC3           OMX.google.raw.dec**           audio/eac3 or audio/ac3           ENCODING_E_AC3 or ENCODING_AC3           DDP-to-DD transcode or DD pass-through                                PCM only           ENCODING_PCM_16BIT           AAC (rec-ommended)           OMX.google.raw.dec**           audio/raw           ENCODING_PCM_16BIT           AAC decode                                EAC3           OMX.dolby.eac3.decoder           audio/raw           ENCODING_PCM_16BIT           DDP decode                                 AC3              OMX.dolby.ac3.decoder              audio/raw              ENCODING_PCM_16BIT              DDP decode           * Because transcoding from DDP to DD is supported.** Optional if the content is not encrypted.Dolby Support in FireTV StickFire TV Stick, which is based on JellyBean Android OS, was launched before Android L was released. Android L officially introduced support for Dolby pass-through audio in Android TV.Android L has a recommended architecture for Dolby integration in the platform, which unfortunately does not match with the Dolby integration architecture on Fire TV Stick. This section describes the Dolby support in Fire TV Stick. Note: The information contained in this section is applicable even though Fire TV Stick is now upgraded to Android L based Fire OS 5.MediaCodec (Fire TV Stick)The MediaCodec that handles Dolby bitstream supports all scenarios: Dolby pass-through, transcode, and decode. The MediaCodec depends on the Dolby capability of the connected endpoint and the system’s Dolby settings to select the appropriate mode for handling the incoming Dolby bitstream.  For Dolby pass-through or transcode mode, the decoder converts the raw input Dolby bitstream to the IEC61937 packetized format.  For Dolby decode mode, Dolby decoders also down-mixes the multi-channel output to stereo PCM. So irrespective of the number of input channels of the content, the output is always stereo PCM. The decoders available are OMX.dolby.ec3.decoder to handle DDP bitstream and OMX.dolby.ac3.decoder to handle DD bitstream.The following table illustrates the functionality of MediaCodec.                  Endpoint capability         Input stream type         Codec         Dolby Setting         Output format MimeType         Comments                      DDP, DD and PCM        DDP        OMX.dolby.ec3.decoder        DDP over HDMI or DDP Auto        audio/ec3*        DDP Pass-through                      DDP OFF           audio/raw           DDP Decode                         DD            OMX.dolby.ac3.decoder            DDP over HDMI or DD over HDMI or DDP Auto            audio/ac3            DD Pass-through                DD and PCM         DDP         OMX.dolby.ec3.decoder         DDP over HDMI, DD over HDMI, DDP Auto         audio/ec3*         DDP &gt; DD Transcode                         DDP OFF            audio/raw            DDP Decode                            DD             OMX.dolby.ac3.decoder             DDP over HDMI, DD over HDMI, or DDP Auto             audio/ac3             DD Pass-through                     DDP OFF       audio/raw       DD Decode                            PCM                DDP                OMX.dolby.ec3.decoder                N/A                audio/raw                DDP decode                                      DD              OMX.dolby.ac3.decoder              N/A              audio/raw              DDP decode           * The missing “a” in eac3 is intentional. This is a subtle difference between Fire TV Stick and Fire TV.AudioTrack (Fire TV Stick)AudioTrack in Fire TV Stick has certain limitations — it does not support Dolby Transcode or Dolby Decode, and only supports Dolby Pass-through. Additionally,the input Dolby bitstream must be in IEC61937 packetized format — which is same as the output of Dolby MediaCodec decoders.Due to these architectural differences between Fire TV Stick and Android L, app developers need to do major changes in their app to support Dolby audio content playback. The application must always use MediaCodec (even if the content is not encrypted) to process the Dolby bitstream and must configure the AudioTrack based on the output MIME type indicated by MediaCodec. The following steps provide more detail about this process.A. Create the Decoder by MimeTypeCreate the MediaCodec by MIME Type (audio/eac3, audio/ec3, or audio/ac3). This is a generic Android way of creating a codec — no custom changes are required.B. Handle MediaCodec Output Format Change NotificationWhen the app starts using MediaCodec to process the input bit stream, it detects an output format change and returns INFO_OUTPUT_FORMAT_CHANGED in the dequeueOutputBuffer API call. The application must handle this response and use the getOutputFormat API to find out the output format MIME type. It should use this MIME type to configure AudioTrack as per the following table:            MimeType AudioFormat value                         audio/eac3      ENCODING_E_AC3              audio/ac3      ENCODING_AC3              audio/raw      ENCODING_PCM_16BIT      C. Limitations of AudioTrack for Dolby encoding formatsAudioTrack for Dolby encoding formats ENCODING_E_AC3 and ENCODING_AC3 has following limitations and known issues:  The AudioTrack start/pause API is not effective. Your app might start writing data to the AudioTrack just after creation, and as a result, it will start playing. It does not wait for start API to be called.  AudioTrack’s getTimeStamp API (which was introduced in KitKat) is back-ported to Jelly-Bean-based Fire TV – 1st Generation and Fire TV Stick and can be used for A/V Sync logic. Note: These limitations are applicable only for the Dolby audio formats mentioned in this section.Dolby Support in Fire TV — 1st GenerationFire TV – 1st Generation was initially built on a Jelly-Bean-based OS and launched much before Android L – which officially introduced support for Dolby audio pass-through in Android TV.Android L has a recommended architecture for Dolby integration in the platform, which unfortunately does not fully match with the Dolby integration architecture on Fire TV – 1st Generation). This section describes the Dolby architecture in Fire TV – 1st Generation. Note: The information contained in this section is applicable even though the Fire TV – 1st Generation is now upgraded with Android-L-based Fire OS 5.MediaCodec (Fire TV — 1st Generation)The default MediaCodec for Dolby MIME type available in Fire TV – 1st Generation is a pass-through decoder only. It copies input data to output data without changing the MIME type. Hence, the output format has same MIME type as that of the input format.The decoders available are OMX.qcom.audio.decoder.passthrougheac3 to handle DDP bitstream and OMX.qcom.audio.decoder.passthroughac3 to handle DD bitstream. In addition, these decoders also decrypt the data if it is encrypted by a DRM scheme. Hence, if the content is encrypted by DRM, applications must use this decoder. Otherwise, the usage of this decoder is optional and the Dolby bitstream can be passed to AudioTrack directly.AudioTrack (Fire TV — 1st Generation)AudioTrack handles Dolby pass-through, Dolby Decode, and Dolby transcode internally. This means that depending on the Dolby capability of the connected endpoint and the system Dolby setting, AudioTrack selects the appropriate mode of handling the incoming Dolby bitstream.endpoint capabilityInput stream typeDolby SettingHDMI OutputComments      DDP, DD, and PCM    DDP    DDP over HDMI/Optical or DDP Auto    DDP    DDP Passthrough        DDP OFF    PCM    DDP Decode        DD    DDP over HDMI/Optical, DD over HDMI, or DDP Auto    DD    DD Passthrough        DD and PCM    DDP    DDP over HDMI/Optical, DD over HDMI, or DDP Auto    DD    DDP &gt; DD Transcode        DDP OFF    PCM    DDP Decode        DD    DDP over HDMI/Optical, DD over HDMI, or DDP Auto    DD    DD Passthrough        DDP OFF    PCM    DD Decode        PCM    DDP or DD    NA    PCM    DD or DDP decode  Limitations of AudioTrack for Dolby Encoding Formats (Fire TV — 1st Generation)AudioTrack for Dolby encoding formats ENCODING_E_AC3 and ENCODING_AC3 has following limitations and known issues:  The getPlaybackHeadPosition API of AudioTrack is not implemented. Consequently, do not depend on it for A/V sync. Your app must not call this API. Calling this API may result into a crash.  AudioTrack’s start/pause API is not effective. You app might start writing data to the AudioTrack just after creation and it will start playing. It does not wait for start API to be called.  AudioTrack’s getTimeStamp API (which was introduced in KitKat) is back-ported to Jelly-Bean-based Fire TV 1st Gen and Fire TV Stick and can be used for A/V Sync logic via reflection. Note: These limitations are applicable only for the Dolby audio formats mentioned in this section.Option 2: Use ExoPlayerExoPlayer is a open source player backed by Google that supports playing Dolby audio stream. However, due to the architectural differences in Dolby support between a standard Android L device and Fire TV – 1st Generation family of devices (as described in preceding sections), ExoPlayer fails to play Dolby audio content.Amazon has developed patches for Exoplayer to enable playback of Dolby audio content in Fire TV Gen1 family of devices. These patches are open sourced here: exoplayer-amazon-port. This port also includes other patches required to enable playback of PlayReady DRM protected content. (Note that each “amazon/rx.y.z” branch maps to ExoPlayer version x.y.z.)Option 3: Use Other Supported Media PlayersYou can use other supported media players for Fire TV, such as VisualOn or NexPlayer, to play Dolby audio content and DRM content. Refer to Media Players for Fire TV for further details.Option 4: Use Android Media PlayerYour app can use Android MediaPlayer to play Dolby content.Handling non-Dolby End-Points and Private Listening ModesThis section describes recommendations and best practices for Dolby audio content playback on the Fire TV family of devices when connected to a non-Dolby endpoint and private listening. Following these guidelines will help you create the best user experience for Dolby audio content playback.As described previously, Android L introduced a new API in AudioManager called ACTION_HDMI_AUDIO_PLUG intent. This intent allows apps to detect the capabilities of the connected endpoint (AVR or TV). This detection can be used to support Dolby audio content playback in various scenarios including private listening.  Q. How does an app detect the capabilities of the connected endpoint?  The app must register a broadcast receiver to receive the ACTION_HDMI_AUDIO_PLUG intent and read the EXTRA_ENCODINGS extra values in the intent. This list of encoding values will indicate the endpoint capabilities. The possible values are one of the ENCODING_XXXX values (for example, ENCODING_PCM_16BIT, ENCODING_AC3, ENCODING_E_AC3, and so on).  Q. Which audio stream should be selected for playback when the connected endpoint does not support DD or DDP?  In these cases, let your app select a non-Dolby audio content for playback (for example, AAC). This option has the advantage of reduced bandwidth usage as compared to Dolby audio content.    However, if the app cannot select an alternative non-Dolby audio content and chooses to continue to stream Dolby (DD or DDP) audio, it must do the following for each device.          Fire TV – 1st Generation: Send Dolby raw bitstream to AudioTrack, which internally decodes and down-mixes to stereo PCM.      Fire TV Stick and Fire TV – 2nd Generation: Use the MediaCodec for Dolby (OMX.dolby.ac3.decoder or OMX.dolby.eac3.decoder). This MediaCodec decodes the Dolby bitstream, down-mixes to stereo PCM, and configures AudioTrack with the ENCODING_PCM_16BIT audio format to render the PCM data. Since the Dolby Decoder in all the platforms down-mixes multi-channel content to stereo, there is no real advantage in choosing Dolby audio content when the endpoint does not support DD or DDP.         Tip: It is strongly recommended that you select a non-Dolby audio stream when the device is connected to an endpoint that does not support Dolby (DD or DDP).    Q. Which audio stream should be selected for playback when the connected endpoint supports DD but does not support DDP?  The answer depends on the Fire TV device:          Fire TV – 1st Generation and Fire TV – 2nd Generation: AudioTrack supports transcoding DDP bitstream to DD. Hence, even if the endpoint supports DD only, AudioManager appends DDP as the supported capability in the ACTION_HDMI_AUDIO_PLUG intent. As a result, from an app’s perspective, the endpoint that supports DD also supports DDP (via transcoding in AudioTrack).      Fire TV Stick: The app can select any audio content for playback because the MediaCodec decides whether to pass-through, transcode, or decode based on endpoint capabilities. In this use case, it would pass-through DD or transcode DDP to DD and pass-through DD.        Q. Which audio stream should be selected for playback when the connected endpoint supports DDP and DD?  Fire TV – 1st Generation and Fire TV – 2nd Generation: The app can select DDP or DD audio content for playback. If the audio is not encrypted, the app can then send this clear DD/DDP bitstream data as is to AudioTrack. Internally, AudioTrack will pass-through the DD/DDP bitstream to the connected endpoint.    If the audio contend is DRM protected, the app must instantiate the following MediaCodec to decrypt the bitstream:                  In Fire TV – 1st Generation, OMX.qcom.audio.decoder.passthrougheac3 or OMX.qcom.audio.decoder.passthroughac3 . This special decoder is a no-op pass-through decoder that supports decryption (that is, it copies the input bitstream to output after decrypting if needed).                    In Fire TV – 2nd Generation, OMX.google.raw.dec (by name). This special decoder is a no-op pass-through decoder that supports decryption (that is, it copies the input bitstream to output after decrypting if needed).               Note: OMX.google.raw.dec is also available in the Fire OS 5 version of Fire TV – 1st Generation.    Fire TV Stick: The app can select any audio content for playback because the MediaCodec decides whether to pass-through, transcode, or decode based on the endpoint capabilities. In this use case it would pass-through the Dolby audio content.    Q. How does the app handle private listening use cases involving audio headsets or Bluetooth A2DP headsets during Dolby pass-through playback?  Fire TV – 1st Generation: The app does not need to do anything special to handle the private listening use cases. This is automatically taken care of internally in AudioTrack (it switches over from pass-through to decode the mode of operating).    Fire TV Stick and Fire TV – 2nd Generation: When either an audio headset (via a game controller) or Bluetooth headset is connected to the device during Dolby pass-through playback, the operating system re-broadcasts the ACTION_HDMI_AUDIO_PLUG intent with modified encoding extra values.    Since the audio headset via a game controller or Bluetooth headset do not support Dolby pass-through, the encoding extra value would now be ENCODING_PCM_16BIT only. The app must register to receive this intent during playback and re-configure the audio pipeline to do one of the following:          Switch to an alternate non-Dolby audio content mid-stream (for example AAC)      If an alternative audio content is not available, re-configure the audio pipeline to use the MediaCodec Dolby decoder to decode the Dolby content to Stereo PCM. In case of Fire TV Stick, re-creation of the MediaCodec is required as part of re-creating the audio pipeline.         Note: The first option (switching to non-Dolby audio) is highly recommended because the Dolby decoder in the device always down-mixes multi-channel output to stereo internally, regardless of the endpoint’s multi-channel capabilities. As a result, there is no advantage of playing the 5.1 Dolby stream over stereo with a non-Dolby stream. Additionally, the non-Dolby audio stream (such as AAC) consumes less bandwidth than the multi-channel Dolby audio stream.  ",
        "url": "amazon-fire-tv-dolby-integration-guidelines.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "customizing-mouse-pointer-html": {
        "title": "Customizing the Mouse Pointer",
        "tags": "[]",
        "content": "If your app supports pointer-based input, Fire TV supports the use of a USB or Bluetooth-connected mouse that enables users to interact with your app. By default the mouse pointer appears as a large circle on the TV.You can change the appearance of this mouse pointer into an arrow with an addition to the Android manifest (AndroidManifest.xml). Note: Although the Fire TV platform supports the use of a mouse, your Fire TV app must use a controller as the primary mode of navigation and user input to be accepted by the Amazon Appstore. See Supporting Controllers on Fire TV for more information.Modify the Android ManifestTo change the default mouse pointer to an arrow for a given activity, add a &lt;meta-data&gt; element to your manifest inside &lt;activity&gt;:&lt;activity        android:name=\".MyActivity\"        android:label=\"My Activity\"&gt;    ...    &lt;intent-filter&gt;        &lt;action android:name=\"android.intent.action.MAIN\" /&gt;        &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;    &lt;/intent-filter&gt;    &lt;meta-data android:name=\"com.amazon.input.cursor\" android:value=\"pointer\"/&gt;&lt;/activity&gt;",
        "url": "customizing-mouse-pointer.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "dial-integration-html": {
        "title": "DIAL Integration",
        "tags": "[]",
        "content": "Amazon Fire TV devices support the DIAL (Discovery-and-Launch) protocol through the Whisperplay service. DIAL is an open protocol that enables your Fire TV app to be discoverable and launchable from another device via a second screen app. Both Fire TV and the second screen device must be on the same network.Note that DIAL is not a casting or mirroring API. DIAL only enables apps on a second screen device to find and launch apps on a Fire TV. In most cases you implement both the second screen app (to send a launch message) and the corresponding Fire TV app (to receive that message).For more information about the open DIAL protocol and to register your app with the DIAL service, see the DIAL website.  Implementing DIAL  Modify your Android Manifest  Add the Whisperplay.xml File  DIAL Payload IntentImplementing DIALDIAL functionality does not require any changes to your Fire TV app’s code, but you do need to modify your app’s manifest and resources to indicate support for DIAL and to accept launch intents.There are five steps to implementing DIAL support for your Fire TV and second screen apps:  In your second screen app, implement the DIAL protocol to discover and launch apps on Fire TV. See the DIAL website for more information, and specifically the information in Details for Developers.  Register your Fire TV app with the DIAL registry. See About the Registry for details.  In your Fire TV app, handle DIAL launch intent payloads. This step is only necessary if your second screen app sends an intent payload. That payload is delivered as an Intent extra with the value com.amazon.extra.DIAL_PARAM.  In your Fire TV app, modify the Android manifest to support DIAL. See Modify your Android Manifest.  In your Fire TV app, add a Whisperplay.xml file to your app’s resources. See Add the Whisperplay.xml File.Modify your Android ManifestThere are two changes you must make to your Android manifest (AndroidManifest.xml) to support DIAL:  Add a &lt;meta-data&gt; element to &lt;application&gt; that indicates support for Whisperplay and DIAL.  Add the DEFAULT category to your launch intent.In the &lt;application&gt; portion of your manifest, add the following &lt;meta-data&gt; element:&lt;application ... &gt;    &lt;meta-data android:name=\"whisperplay\"  android:resource=\"@xml/whisperplay\"/&gt;    ...&lt;/application&gt;Next, add the DEFAULT intent category to your primary (main) activity’s &lt;intent-filter&gt; element:    &lt;activity android:name=\".MainActivity\"              android:label=\"@string/title_activity_main\" &gt;        ...        &lt;intent-filter&gt;            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;            &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;Add the Whisperplay.xml FileAdd a file called Whisperplay.xml to your app’s resources, in the res/xml/ directory. The contents of the file should look like this, where DialAppName is the name of your app in the DIAL registry:&lt;whisperplay&gt;    &lt;dial&gt;        &lt;application&gt;            &lt;dialid&gt;DialAppName&lt;/dialid&gt;            &lt;startAction&gt;android.intent.action.MAIN&lt;/startAction&gt;        &lt;/application&gt;    &lt;/dial&gt;&lt;/whisperplay&gt;DIAL Payload IntentIf your app accepts a DIAL payload (information that can be passed to your app via the DIAL launch request), that payload will be delivered as an Intent extra with the value com.amazon.extra.DIAL_PARAM.",
        "url": "dial-integration.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "display-and-layout-html": {
        "title": "Display and Layout",
        "tags": "[]",
        "content": "Implementing an Android app that renders well on a television (or that behaves properly on both a tablet and a television) requires some attention to user interface layout.This document provides technical information for building your UI layouts on the Amazon Fire TV platform. See Design and User Experience Guidelines for general guidelines on TV design.  Screen Size and Resolution  Orientation  Resource ConfigurationsScreen Size and ResolutionMany Android devices such as Fire tablets have a fixed physical size and a single resolution. This is not the case with Amazon Fire TV devices, to which you can connect a 720p or 1080p screen of any size.The mechanism in Android to specify an activity layout in absolute coordinates independently of the video output resolution is to use density independent units (dp). Android scales the graphic resources so that the size remains constant independently of the screen resolution.The following table shows the pixel size, density and display resolution for various video outputs connected to an Amazon Fire TV device.                                                            TV setting      Output resolution (pixels)      Render surface (pixels)      Density identifier      screen density (dp)      Display resolution (dp)      Screen size identifier                  1080p      1920 x 1080      1920 x 1080      xhdpi      320      960x540      large              720p      1280 x 720      1920 x 1080      xhdpi      320      960x540      large              480p      640 x 480      1920 x 1080      xhdpi      320      960x540      large      OrientationThe orientation of the Amazon Fire TV device never changes, and requests for the rotation or orientation on the device return these results:                              Method      Result                  Display.getRotation()      0 (ROTATION_0)              Display.getOrientation() (deprecated)      0 (ORIENTATION_UNDEFINED)      Resource ConfigurationsIf you design your app to run on platforms other than Amazon Fire TV, such as tablets, you can create different layouts and drawables for each platform, and store them in subdirectories of res/ named for various platform and device configurations. For more information on using these resource configurations, see the Android best practices guide for Supporting Multiple Screens.The following table describes the resource configurations available for the Amazon Fire TV platform.                              Configuration      Value                  Smallest width      sw540dp              Available Width      w960dp              Available Height      h540dp              Screen Size      large              Screen aspect      long              Screen orientation      land (TV apps are always landscape)              UI mode      television              Night mode      notnight              Screen pixel density      xhdpi              Touchscreen type      notouch              Keyboard availability      keyssoft              Primary text input method      nokeys              Navigation key availability      navexposed              Primary non-touch navigation method      dpad              Platform version      v17      ",
        "url": "display-and-layout.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-4k-ultra-hd-html": {
        "title": "Playing 4K Ultra HD Videos on Fire TV",
        "tags": "[]",
        "content": "You can play 4K Ultra HD (UHD) media on Amazon Fire TV (2nd Generation) devices – but not on Fire TV (1st Generation) or Fire TV Stick. To support 4K playback, you must adhere to the supported output resolutions, DRM systems, and codecs for 4K UHD content.  HDMI Mode switch  Certification and Performance Testing  4K Ultra HD Specifications          Resolution and Refresh Rate      DRM Systems      Codecs      Input/Output Color Formats      Power Consumption        APIs for HDMI Mode Switch  Steps for Using HDMI Mode Switch  Interface for developers  Amazon 4K Extension Library          UHDHelper class      UhdHelperListener class      Display.Mode class        Interstitial during Mode SwitchHDMI Mode switchBy default, Fire TV (2nd Generation) operates at 1080p at 60 FPS mode even when connected to a 4K UHD TV. Hence, in order to play 4K UHD content, you must switch the TV to 4K UHD display mode. This switching between HDMI display modes is referred to as an HDMI Mode switch. The HDMI Mode switch is triggered by the application when it needs to play 4K UHD content.Amazon developed an Amazon Extension Library for 4K that provides high level APIs to trigger this HDMI Mode switch and show a user-friendly overlay message before the TV starts switching the display mode. This overlay message improves the overall customer experience. Note: Fire TV (2nd Generation) supports only up to 30 FPS for 4K UHD content.Certification and Performance TestingApps that support Ultra HD video will be certified by Amazon to ensure they meet the required customer experience. Typically, certification takes a couple of weeks.When you submit your app, add a note that it is 4K-enabled. Most likely in your app’s description, you would already highlight to users that your app offers 4K Ultra HD media playback. But adding a manual note will also let Amazon know to apply 4K performance testing on the app during the certification process.4K Ultra HD SpecificationsResolution and Refresh RateAmazon Fire TV (2nd Generation) supports the following output resolutions:  4K UHD at 24 FPS  4K UHD at 25 FPS  4K UHD at 30 FPS  Full HD (1080p) up to 60 FPSAmazon Fire TV (2nd Generation) is expected to stay mostly in Full HD (1080p) mode at 60 FPS, even on TVs that support 4K UHD format. Fire TV (2nd Generation) switches to 4K UHD mode only for 4K UHD content playback.The following frame rates are recommended when playing content:  For Full HD (1080p) and HD (720p) content, leave the device in Full HD (1080p) 60 FPS mode and use frame rate conversion from the content’s native frame rate (as in Fire TV - 1st Generation).  For 4K UHD content, switch to the nearest 4K UHD mode before starting playback. For example, switch to 4K UHD at 24 FPS to play 4k UHD content of 24 FPS or 23.97 FPS, switch to 4K UHD at 25 FPS to play content of 25 FPS, and switch to 4K UHD at 30 FPS to play content of 30 FPS or 29.97 FPS.  Initiate a mode switch only if the user enters the playback window or if the next title in the queue requires a different playback resolution / frame rate. Note: Fire TV (2nd Generation) switches the display back to Full HD at 60 FPS whenever the activity that switched the display to 4K mode is paused. An activity can be paused in several ways, such as pressing “BACK” button, the “HOME” button, or programmatically launching another activity on top of it.DRM SystemsAmazon Fire TV (2nd Generation) supports the following DRM solutions:  Widevine L1/L3 DRM  PlayReady DRM (2.5 max)  HDCP 2.2 link to compatible panelsCodecsAmazon Fire TV (2nd Generation) supports the following codecs:  MediaCodec that supports HEVC main L5 profile  MediaCodec that supports HEVC main10 L5 profile (The output will be in 8-bit Rec 709 color space for both 8-bit and 10-bit color input.)Input/Output Color FormatsAmazon Fire TV (2nd Generation) supports the following color specs:                              Supported Input Color Formats      Output Color Formats                  8-bit Rec709 (HEVC Main profile L5)      8-bit Rec709              10-bit Rec709 (HEVC Main10 profile L5)      8-bit Rec709              10-bit Rec2020 (HEVC Main10 profile L5)      8-bit Rec709      10-bit color input is supported by the codec, but the output does not support 10-bit output.Power ConsumptionThe following table specifies the maximum allowed power consumption for Fire TV devices:                                          Fire TV Stick (Gen. 2)      Fire TV (Gen. 2)      Fire TV Stick (Gen. 1)      Fire TV (Gen. 1)                  2.1 W      3.8 Watts      1.7 Watts      3.6 Watts      Run the app 10 minutes before measuring the power consumption on the Fire TV Stick. For Fire TV, run the app for at least 30 minutes before taking the power measurement. Your power measurement can continue for 5 minutes.If the power consumption from your app exceeds the limits in the previous table, Fire TV will throttle the performance of your app. If throttling is not enough, Fire TV will reset the system.In your code, you can check for the device (whether Fire TV Stick or Fire TV) by looking for the amazon.hardware.low_power feature. See Identifying Amazon Fire TV Devices for more details.APIs for HDMI Mode SwitchGoogle introduced 4K Display.Mode APIs in Android Marshmallow. Display.Mode allows applications to query physical display sizes and switch to a different HDMI display mode.Amazon implemented Display.Mode APIs in Fire TV (2nd Generation) running Fire OS 5 (based on Android L). Apps can use these APIs for the HDMI Mode switch.Since these APIs are not part of Android API Level 21 (Lollipop) in Android SDK, the apps can use “reflection” to access the APIs.  Alternatively, app developers can use the 4K Extension Library developed by Amazon, which wraps these Android APIs via reflection and provides a simple interface for them.You can also display an optional interstitial developed by Amazon to prepare customers for the HDMI Mode switch. This interstitial is distributed as part of the Amazon Extension Library For 4K.Fire OS will also provide a sys.display-size system property to report the maximum supported resolution of the connected display.Steps for Using HDMI Mode SwitchFollow these general steps when using the Android API to initiate an HDMI Mode switch:      Query supported display modes with Display.getSupportedModes().    Display.getSupportedModes() returns an array of Display.Mode objects. This synchronous API returns the modes (resolution and frame rate) supported by both Fire TV (2nd Generation) and the attached display. If the attached display supports 4K UHD, then 4K UHD modes will be included in the list.    Because frame rate conversion may not provide optimal results, Amazon recommends switching to the actual or closest frame rate of the content to be played (4K at 24fps, 4K at 25fps, or 4K at 30fps).        Retrieve the current display resolution and frame rate using Display.getMode().    Display.getMode() returns the current display resolution and refresh rate in a Display.Mode object.        Set the Display mode with the WindowManager.LayoutParams.preferredDisplayModeId property.    Applications use WindowManager.LayoutParams.preferredDisplayModeId property to initiate a mode switch. This allows the application to start up in Full HD (1080p) and then initiate a mode switch to 4K UHD when the user starts playback of 4K UHD content. Note the following:          A mode switch will not be initiated during Activity transitions if both activities prefer the same mode.      System and voice overlays will not initiate a mode switch.      The display switches back to Full HD (1080p) resolution when either the application or activity terminates.      The Display.Mode class definition aligns with Android Marshmallow.            Get notification for when the mode switch negotiation is complete.    Through the onDisplayChanged(int displayId) method, you can be notified when the mode switch negotiation is complete.    DisplayManager.DisplayListener sends a callback when properties of logical display have changed. This callback will be received once the mode change is complete. Note that the displayed content may not be visible for a few seconds after the callback is received.  Interface for developersApplications can use these APIs directly via reflection, or they can use an Amazon provided wrapper (the 4K Extension Library) to access these APIs. The following code sample shows the mode change directly without the extension:WindowManager.LayoutParams mWindowAttributes = mTargetWindow.getAttributes();try { if (attributeFlagField == null) {  Class &lt; ? &gt; cLayoutParams = mWindowAttributes.getClass();  attributeFlagField = cLayoutParams.getDeclaredField(sPreferredDisplayModeIdFieldName); } //attempt mode switch attributeFlagField.setInt(mWindowAttributes, modeId); mTargetWindow.setAttributes(mWindowAttributes);} catch (Exception e) { Log.e(TAG, e.getLocalizedMessage());}The approach using the 4K Extension Library is covered in the next section.Amazon 4K Extension LibraryHDMI Mode Switch APIs in Fire TV (2nd Generation) are not available in Android Lollipop SDK. To use them, you must use reflection. Amazon built the 4K Extension Library (provided in the form of source code) to demonstrate how to use the Android APIs and provide a helper class. Download Amazon 4K ExtensionThe extension ZIP file includes a sample app inside the Test folder called “DisplayModeCheckSample.” There’s also a Javadoc file, which you can view by expanding the doc &gt; javadoc folder and opening the index.html file.To build the app, go to File &gt; Open in Android Studio and select the DisplayModeCheckSample project. Then click the Run ‘app’ button . When you build the app, you will see a screen such as this:When you switch modes, the interstitial appears (on an Ultra HD TV) and the app switches to 4K Ultra HD mode.Amazon’s 4K Extension Library contains the classes listed in the following sections. In addition, it includes the API for displaying the “Amazon Interstitial” to prepare customers for the HDMI Mode switch on Amazon 4K devices. The following sections describe these classes.UHDHelper classUHDHelpder is a convenience class that wraps the 4K UHD capabilities and Mode Switch APIs. It provides the following public methods:setPreferredDisplayModeId(Window targetWindow, int modeId, boolean allowOverlayDisplay)This method lets you request a specific display mode (resolution and refresh rate). This method initiates a mode switch on the supported devices if the display is not currently set at the requested mode. UhdHelperListener is used to notify the application that the mode switch HDMI negotiation is complete.            Parameters      Description                  targetWindow      Window to use for setting the display and call parameters.              modeId      The desired mode to switch to. Must be a valid mode supported by the platform.              allowOverlayDisplay      Flag request to allow display overlay on applicable device.      Note that mode switch requests might not be successful, and you must verify the mode from UHDHelperListener#onModeChanged(Display.Mode mode) or call getMode(). You must wait until the mode switch is complete before starting content playback. Also, the mode switch works only with Fire TV (2nd Generation).”getSupportedModes()Determines all the supported modes on the connected device.            Returns                  An array of Mode objects or NULL if an error occurred.      getMode()Returns the current mode that the display is set to. This method is also used to determine the success of a mode switch. When a mode switch is in progress, the result of getMode() is undefined.            Returns                  Mode that is currently set on the system or NULL if an error occurred.      UhdHelperListener classThe UhdHelperListener class provides the onModeChanged(Display.Mode mode) method. This method is used to inform applications when the mode switch HDMI negotiation is complete. It also provides the current mode (which could be the requested mode) if the mode change was successful.            Parameters      Description                  mode      The Mode object containing the mode switched to, or NULL if there was a timeout or internal error while changing the mode.      Display.Mode classThe Display.Mode class mirrors the Display.Mode class in Android Marshmallow. This is used to describe a display mode’s resolution and refresh rate.Interstitial during Mode SwitchBecause the customer experience is interrupted during an HDMI Mode switch, Amazon has built an interstitial that can be optionallydisplayed to prepare customers before the HDMI Mode switch. The code to trigger this interstitial is available with the Amazon Extension Library For 4K.To display the interstitial through the extension code, call setPreferredDisplayModeId(Window_targetWindow, int_modeId boolean_allowOverlayDisplay) with allowOverlayDisplay set to true. The overlay will be shown for two seconds prior to the start of the mode switch.",
        "url": "fire-tv-4k-ultra-hd.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-advertising-id-html": {
        "title": "Advertising ID on Fire TV",
        "tags": "[]",
        "content": "The Advertising ID is a user-resettable, unique, anonymous identifier that can be used for advertising and user analytics. Users can reset the Advertising ID or opt out of tracking for interest-based ads altogether. The Advertising ID is currently available for tablet devices running Fire OS 5.1 and later and TV devices running Fire OS 5.2.1.1 and later.On Fire TV, users can manage the Advertising ID by going to Settings &gt; System &gt; Advertising ID.  When to Use the Advertising ID  Developer Expectations  Verifying and Responding to the User’s Advertising ID ChoicesWhen to Use the Advertising IDYou should use the Advertising ID (when supported by the device) if your app does the following:  Displays ads  Collects data for user analytics  Collects data to build user profiles for advertising purposes or for targeting users with interest based advertisingWhen available, use the Advertising ID over any other ID. Ensure that if you use a third-party ad service in your app, the service follows the requirements around the user’s choice.Developer ExpectationsWhen you use the Advertising ID, follow these principles:  Use the Advertising ID only for advertising and user analytics.  When the user opts out of interest-based ads, the Advertising ID is still available but the developer must honor the user’s opt-out choice. Do not collect information about the user’s behavior to build user profiles for advertising purposes or show them interest based ads. In your code, precede any call to retrieve the Advertising ID with a call that verifies the user’s opt-out choice. Allowed activities include contextual advertising, frequency capping, conversion tracking, reporting, and security and fraud detection.  Do not associate any persistent device identifier or personally-identifiable information with the Advertising ID unless the user has explicitly given consent to do so.  When a user resets the Advertising ID, do not fold earlier data into the new Advertising ID or associate the new ID with the old one unless the user has explicitly given consent for you to do so.For more information, see the App Distribution and Services Agreement.Verifying and Responding to the User’s Advertising ID ChoicesThe Android Settings.Secure class exposes the user’s Advertising ID choices through the getInt and getString methods. The following Java example shows the logic for verifying the user setting and retrieving an Advertising ID (if available).import android.content.ContentResolver;import android.provider.Settings.Secure;import android.provider.Settings.SettingNotFoundException;String advertisingID = \"\";boolean limitAdTracking = false;try {    ContentResolver cr = getContentResolver();    // get user's tracking preference    limitAdTracking = (Secure.getInt(cr, \"limit\\_ad\\_tracking\") == 0) ? false : true;    // get advertising    advertisingID = Secure.getString(cr, \"advertising\\_id\");} catch (SettingNotFoundException ex) {    // not supported}The code first gets the user’s ad tracking preference. Then depending on the ad tracking value, the following happens:  If the user has allowed ad tracking, the value for limit_ad_tracking will be false.  If the user has disabled ad tracking, the value for limit_ad_tracking will be 00000000-0000-0000-0000-000000000000. (Note: This is a bug. In the future, the value will be true, similar to the response for Fire tablets. )   The Advertising ID gets stored in the advertisingID variable. A sample Advertising ID value might be df07c7dc-cea7-4a89-b328-810ff5acb15d. (For child profiles, the advertisingID will be 00000000-0000-0000-0000-00000000000.)  If the system doesn’t return any value for limit_ad_tracking (such as for non-Fire-OS devices or Fire Devices running older versions of FireOS), a SettingNotFoundException gets thrown. You can handle this exception as desired.  When a user toggles the interest based opt-out value (from enabled to disabled or vice-versa), the Advertising ID is set to a new value. (Note: This is a bug. In the future, the same Advertising ID will be retained, similar to how it works on Fire tablets.)",
        "url": "fire-tv-advertising-id.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-handling-hdmi-events-html": {
        "title": "Handling HDMI Events",
        "tags": "[]",
        "content": "When users connect or disconnect an HDMI cable, your app must handle these HDMI events following the guidelines here.  HDMI Disconnection  Letting the App Know about HDMI Events  Other Connection EventsHDMI DisconnectionThe recommended behavior of an HDMI disconnection — because the TV is powered OFF, input to the TV switched to another HDMI port, or the HDMI cable disconnected physically — is as follows:  Apps that play video must pause playback when the TV is turned off or HDMI cable is disconnected. When the TV is powered ON or HDMI cable connected, playback should remain paused until the user explicitly presses PLAY button on the remote.  Apps that play only audio may continue to play even if the HDMI is disconnected, provided the Fire TV is connected to another audio device via digital optical cable (Fire TV – 1st Generation only), Bluetooth A2DP headset, or audio headset via the Game controller.Letting the App Know about HDMI EventsTo let your app know about connection or disconnection, listen for ACTION_HDMI_AUDIO_PLUG intent broadcast that has an extra (EXTRA_AUDIO_PLUG_STATE) indicating if the HDMI is in connected state or not.Other Connection EventsIf a digital optical cable (Fire TV - 1st Generation only), audio headset, or BT A2DP headset is connected to Fire TV, unfortunately there is no reliable way of knowing this in Android Lollipop based Fire OS 5 or later.As such, it is recommended that you provide a User Preference setting in the app that controls this behavior.",
        "url": "fire-tv-handling-hdmi-events.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-international-locales-html": {
        "title": "Resources for International Locales",
        "tags": "[]",
        "content": "Fire devices have a default locale with a region and language that you can query programmatically. You can increase the reach of your app and improve the experience for users in different locales by providing resources that are not only designed for a specific device, but are also responsive to locale. For example, you may already provide different bitmaps for your app based on the pixel density of the device running the app.You can extend this model and provide different bitmaps for each locale. When you put your resources for each locale in the correct folders, the system finds the appropriate resources at runtime. Creating resource files in this way is a preferred method of localizing your app.  Strings Resources  Drawable Resources  Currency ResourcesStrings ResourcesThe strings.xml file holds the user-viewable strings for your app. The following is a sample definition in strings.xml:&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\t&lt;resources&gt;  \t\t&lt;string name=\"hello\"&gt;Hello!&lt;/string&gt;\t&lt;/resources&gt;In your source code, you can use the following to reference the string resource named “hello”:String helloText = getString(R.id.hello);In your XML files such as layout.xml or AndroidManifest.xml, you can reference the resource by doing the following:&lt;application android:label=\"@string/hello\" &gt;To vary the strings by locale, create a strings.xml file that contains the non-default resources for the locale. Put the file in a directory named values-xx-rYY, where xx is the ISO-639 language code and YY is the ISO-3166-1 region code. The following shows several example directories.\t/res\t/values         (default directory, make sure all references are present)\t/values-fr      (contains French language strings, region not used)\t/values-de      (contains German language strings, region not used)\t/values-en-rGB  (contains English language strings for Great Britain)When the system looks for a string reference, it looks first for a resource that is specific to a region and language. It then tries to match by language. The system falls back to the default strings.xml for the resources that you do not specify in the locale-specific file. For example, if you do not put a “hello” string in values-en-rGB, the system falls back to using the default “hello” string. Important: Make sure that the default directory includes all string references. If the system fails to find a reference after searching the default directory, the system forces your app to close.Drawable ResourcesMany apps have menus, price lists, or instructions written as bitmaps or other graphical data. The following example shows a folder structure for providing dynamic resource handling for drawable resources./res  /drawable  /drawable-fr      (contains French language strings, region not used)  /drawable-de      (contains German language strings, region not used)If you have several drawable directories with resources based on pixel density, you can extend the directory structure to account for language. The following example shows how you can chain together language and pixel density. When you specify multiple qualifiers in a directory name, you must do so in the order listed in the Android documentation in this table.  /drawable-fr-ldpi  /drawable-fr-mdpiTo reuse a drawable asset, for example to put copies of the same bitmap in several folders, you can create an XML file to link to the asset. Suppose you want the resource named “background” in the Great Britain locale to point to a resource in the default drawable directory. You can create a file /drawable-en-rGB/background.xml with the following contents. Any reference to “background” that resolves to the drawable-en-GB directory automatically uses the resource /drawable/background_common.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;  &lt;bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"        android:src=\"@drawable/background_common\" /&gt;Currency ResourcesYou can format currency data by locale. Important elements are the currency symbol and the decimal divider, as shown in the following example:  €19,95   // in some European locales  $19.95   // in North AmericaThe following example shows how to display the price of In-App Purchasing items in local format. To fetch a price for an item from the regional store in your app, do the following. This applies formatting only, and does not exchange currency.NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.getDefault());  String formattedPrice = nf.format(19.99f);If you decide to use a locale other than the default, make sure you define it using both language and region, for example en_US, or fr_FR. Otherwise, you may not get the correct formatting. For example, not all countries that use French as primary language have the same currency.",
        "url": "fire-tv-international-locales.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-media-players-html": {
        "title": "Media Players for Fire TV",
        "tags": "[]",
        "content": "Any media player that uses the Android’s media playback and encryption APIs (such as the MediaCodec, MediaCrypto, and AudioTrack classes) will work on the Amazon Fire TV platform. The following are several recommended players, divided into free versus paid options:Free Options:  Amazon port of ExoPlayer  Android MediaPlayerPaid Options:  VisualOn OnStream MediaPlayer  NexStreaming NexPlayer SDKFor information about the audio and video formats supported by Amazon Fire TV, see Fire TV Device Specifications.Also, note that you can always build your own custom media players using standard Android APIs available in Android L (which is supported by the current Fire TV).  Amazon Port of ExoPlayer  Android MediaPlayer  VisualOn OnStream MediaPlayer  NexStreaming NexPlayer SDKAmazon Port of ExoPlayerExoPlayer is an open-source media player developed by Google and intended for Android media apps. To learn more about ExoPlayer, see the following resources:  ExoPlayer homepage  ExoPlayer Video from Google  ExoPlayer Developer GuideAmazon has a port of ExoPlayer that is compatible with Fire TV. Instead of integrating the default ExoPlayer into your Fire TV app, use the Amazon port of ExoPlayer. The Amazon port of ExoPlayer provides many fixes, workarounds, and other patches to make ExoPlayer work on Amazon devices.To understand how to use ExoPlayer, consult the standard ExoPlayer resources as listed previously.Download the Amazon Port of ExoplayerAndroid MediaPlayerThe standard Android MediaPlayer classes that handle audio and video playback are supported on Fire TV. These media classes can handle basic media playback in your app; however, for more robust media needs, the Amazon port of ExoPlayer (or one of the paid media player options) is recommended.VisualOn OnStream MediaPlayerYou can use the VisualOn OnStream MediaPlayer to integrate encrypted media playback in your Fire TV app. VisualOn supports AES 128-bit encryption with HLS, PlayReady DRM with the DASH and SmoothStreaming protocol, and AES 608 and 708 closed captions.Unlike with ExoPlayer, you will need to buy a license from VisualOn to use the VisualOn OnStream MediaPlayer in your Fire TV app.NexStreaming NexPlayer SDKThe NexStreaming NexPlayer SDK is supported on Amazon Fire TV. Like VisualOn, this media player provides a robust set of media playback features, including DASH, DRM content, Smooth Streaming, HTTP Live Streaming (HLS), and more.Similar with VisualOn, NexPlayer requires you to purchase a license to use their player in your Fire TV app.",
        "url": "fire-tv-media-players.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "identifying-amazon-fire-tv-devices-html": {
        "title": "Identifying Amazon Fire TV Devices",
        "tags": "[]",
        "content": "You can identify Amazon Fire TV devices by looking for amazon.hardware.fire_tv as a feature.The following table provides a list of features for different Fire TV devices:            Feature  Fire TV Stick (Gen 2)  Fire TV (Gen 2)  Fire TV Stick (Gen 1)  Fire TV (Gen 1)  amazon.hardware.fire_tv   ✓    ✓    ✓    ✓   amazon.hardware.low_power   ✓       ✓       amazon.hardware.uhd_capable     ✓            amazon.software.drm_teardown          ✓ android.hardware.type.television   ✓    ✓    ✓    ✓ In all cases, Fire TV devices can be identified through the feature amazon.hardware.fire_tv.You get the feature by calling the getPackageManager() method on the Context object and checking whether hasSystemFeature() returns com.hardware.amazon.fire_tv. The following code shows a sample:final String AMAZON_FEATURE_FIRE_TV = \"amazon.hardware.fire_tv\";if (getPackageManager().hasSystemFeature(AMAZON_FEATURE_FIRE_TV)) { Log.v(TAG, \"Yes, this is a Fire TV device.\"); } else {  Log.v(TAG, \"No, this is not a Fire TV device.\"); }Reasons for Checking the Fire TV DeviceYou might want to check for the Fire TV device in your code for a number of reasons:  To identify Amazon Fire TV for choosing strings or making special offers (like free Plex service).  To determine whether the app needs to tear down the DRM and HW decoding pipeline in their onPause() method (which is needed for Fire TV – 1st Generation and Fire TV Stick due to poor handling of multiple DRM contexts).  To check whether the TV platform requires a D-pad controller to drive the UI.  To determine whether the app should play 4k Ultra HD.Checking for the ModelPreviously, you could identify Fire TV devices by combining the android.os.Build.MODEL with the Build.MANUFACTURER. As more Amazon-powered devices come to market, this approach will no longer work.If you absolutely have to switch behavior based on a specific Amazon product model, you may use the MODEL name.  Be aware that such code will not likely work on future devices. As such, include a sensible fallback approach for future Fire TV devices based on the com.hardware.amazon.fire_tv feature.The android.os.Build.MODEL value for Fire TV devices is as follows:          Fire TV Stick (Gen 2)  Fire TV (Gen 2)  Fire TV Stick (Gen 1)  Fire TV (Gen 1)  AFTT  AFTS  AFTM  AFTBHere’s a code sample that looks for the model but falls back on the feature:final String AMAZON_FEATURE_FIRE_TV = \"amazon.hardware.fire_tv\";String AMAZON_MODEL = Build.MODEL;if (AMAZON_MODEL.matches(\"AFTS\")) { Log.v(TAG, \"Yes, this is a Fire TV Gen 2 device.\");} else if (getPackageManager().hasSystemFeature(AMAZON_FEATURE_FIRE_TV)) { Log.v(TAG, \"Yes, this is a Fire TV device.\");} else { Log.v(TAG, \"No, this is not a Fire TV device\");}",
        "url": "identifying-amazon-fire-tv-devices.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "implementing-search-fire-tv-html": {
        "title": "Implementing Search in Fire TV",
        "tags": "[]",
        "content": "Implementing search in Fire TV requires you to understand some key differences with text search and voice search.  Text Search in Apps  Global Text Search  Voice Search  Avoiding Speech Recognition Errors from Leanback  Alexa Skills and AppsText Search in AppsText search within an app refers to any specific text-search features you have specifically coded within your app. Text search for your app is not available by default on Fire TV.Global Text SearchFire TV provides a global text search available from the Fire TV home screen. The global text search returns results from the Fire TV catalog. In order for your media to appear in global text search results, you must integrate your app’s media into the Fire TV Catalog.Voice SearchFire TV also provides voice capabilities through the voice-enabled remote control. In addition to the Alexa voice capabilities on Fire TV, users can also use natural language to search for TV shows, movies, and other media.Regardless of where users are in Fire TV, when they press the microphone button on a voice-enabled remote and say the TV show or Alexa actions they want, this action initiates a global search using the Alexa cloud service instead of the Leanback library.Media requests through voice always return content from the Fire TV catalog. If you want your app’s media to appear in these results, you must integrate your app’s media into the Fire TV Catalog.If the user already has your app installed, your app’s content can appear directly in the catalog results. If a user doesn’t have your app, a “More Ways to Watch” option appears for users to get your app and view the content. (Note that catalog integration is only recommended as an option for apps whose content is the same for all customers.)Avoiding Speech Recognition Errors from LeanbackBecause Alexa is used for voice interactivity on Fire TV instead of the Leanback library, you must disable any speech recognition with the Leanback library’s SearchFragment class for your Fire TV app. If you don’t disable speech recognition, your app will potentially return errors when users perform searches.In Leanback’s SearchFragment class, the startActivityForResult method looks for the speech recognizer. Since FireTV does not support this speech recognizer, this action produces an error. To avoid the error, override the onCreate() method and comment out the speech recognition callback so that the method does not execute. Here’s an example:setSpeechRecognitionCallback(() -&gt; {    if (DEBUG) Log.v(TAG, \"recognizeSpeech\");    try {        //startActivityForResult(getRecognizerIntent(), REQUEST_SPEECH);    }    catch (ActivityNotFoundException e) {        Log.e(TAG, \"Cannot find activity for speech recognizer\", e);    }Here the startActivityForResult method is simply commented out, so the speech recognition feature will not execute and no error will result.Alexa Skills and AppsYou cannot create an Alexa-powered voice search specific to your app, returning media results from your app only. You can access any Alexa skill on Fire TV, but the skills are voice-only experiences. The voice skills do not interact with native apps on Fire TV. As such, there are no ways for an Alexa skill you create to control your app.",
        "url": "implementing-search-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "managing-audio-focus-html": {
        "title": "Managing Audio Focus on Fire TV",
        "tags": "[]",
        "content": "Audio playback on Amazon Fire TV is a shared resource. Although apps such as music players can play audio when they are not in the foreground, only one app should be playing audio at once.To manage audio playback across apps, Android provides the concept of audio focus via the AudioManager APIs. This document outlines how to manage audio focus on the Fire TV platform.  General Best Practices for Managing Audio Focus          Run Your App as a Foreground Service      Request Audio Focus      Register to Receive Media Button Events      Create a Focus Change Listener        Handling Audio Focus with Voice Interactions  Code Samples for Handling Audio Focus  Best Practices for Audio-only ApplicationsGeneral Best Practices for Managing Audio FocusFor the best user experience, do the following in your playback app:  Run Your App as a Foreground Service. During playback, run your app as a foreground service to prevent it from being unexpectedly halted by the system.  Request Audio Focus. At playback time, request audio focus.  Register to Receive Media Button Events. When you have the audio focus, register to receive the controller. Release the media buttons if your app loses focus, or when you’re done playing.  Create a Focus Change Listener. Listen for changes to audio focus and respond appropriately.Each of these best practices is explained in the sections below.Run Your App as a Foreground ServiceServices are used to perform operations in the background when the user may not be directly interacting with your app. Media players, especially those that play music, are ideal for services.However, services may be halted unexpectedly by the Fire TV platform if system resources run low. To give your playback app higher priority on the system and prevent it from unexpectedly being killed, make sure you run your app during playback as a foreground service by extending from Service and using the Service.startForeground() method.The startForeground() method requires two parameters that indicate a notification: a notification ID you define, and a Notification object. On Android devices, that notification appears in the notification drawer to indicate to the user that a high-priority service is running.On the Fire TV platform, heads-up notifications (high priority) display for a few seconds and fade out. You can view older notifications in the Notifications Center. You can use the Android Notification API to create a heads-up notification:// define the notificationNotification.Builder builder = new Notification.Builder(getApplicationContext());builder.setSmallIcon(R.drawable.notification_icon);builder.setContentTitle(title);builder.setContentText(text);builder.setPriority(Notification.[PRIORITY_HIGH][4]);builder.setType(Notification.Builder.TYPE_MEDIA_INFO);Notification notification = builder.build();// startstartForeground(1, notification);After you’ve stopped playing, remove your service from the foreground with Service.stopForeground(). The boolean parameter indicates whether to remove the associated notification.stopForeground(true);Request Audio FocusAudio output is a shared resource on the Fire TV platform — only one audio stream should be playing at any one time. The Android audio manager uses the concept of audio focus to enable apps to share audio playback, and to pause, stop, or lower the volume in response to other apps needing that focus.An application playing back audio must first request the audio focus with appropriate flags and continue playback only if focus is granted. The app can continue to play audio in the background if and only if it still has audio focus.Request the audio focus with AudioManager.requestAudioFocus(). The request has three parameters: a focus listener (see Creating a Focus Change Listener, below), an audio stream type (such as AudioManager.STREAM_MUSIC), and a duration.AudioManager am = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);int result = am.requestAudioFocus(focusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {    am.registerMediaButtonEventReceiver(MediaButtonReceiver);    // start playback}The duration parameter can be one of several options:      AUDIOFOCUS_GAIN(permanent focus): Use for when you want to hold the focus andcontinue playing audio for the foreseeable future, as with amusic player.        AUDIOFOCUS_GAIN_TRANSIENT (transient focus): Use for when you want to interrupt any existingaudio playback for a short period of time, and that other playbackshould pause while you are holding the focus.        AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK (transient with ducking): Same as transient, only the existing playback continues with the volume lowered, muted, or the playback paused.        AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE(transient focus, mutes other sounds): Same as transient but mutesother sounds, including system sounds, in a temporary way. If you’reincorporating voice recognition into your app, or if you have amicrophone input, this parameter can be useful.  After audio focus is granted to your app, you can register the handling of media events (such as Next, Fast Forward, Previous, or Play buttons on headsets, external keyboards, or remote controls) with the AudioManager.registerMediaButtonEventReceiver() method (see the next section). This is only necessary for continuous audio playback — typically you don’t need to own the media buttons for transient playback.After you’re done playing, release the audio focus with the method and unregister the media buttons.// playback complete, give up audio focusam.abandonAudioFocus(focusListener);//unregister media buttonsam.unregisterMediaButtonEventReceiver(MediaButtonReceiver);Register to Receive Media Button EventsIf you plan to play audio for more than a few moments (that is, you’ve requested non-transient audio focus), register a media button receiver when your audio focus request is granted.The media button receiver enables the user to control your media playback with the media buttons on the remote control, even if your app is not running in the foreground.Note that registering the media buttons just means your app receives those events before other apps – you must still handle those key events to actually control your media playback.Your media button receiver extends from BroadcastReceiver and listens for an ACTION_MEDIA_BUTTON intent. Register your receiver in your Android manifest (in this example, the receiver class is MediaButtonReceiver):&lt;receiver android:name=\"MediaButtonReceiver\" &gt;    &lt;intent-filter&gt;        &lt;action android:name=\"android.intent.action.MEDIA_BUTTON\" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;Implement the onReceive() callback in your receiver class to receive and handle media button intents:public void onReceive(Context context, Intent intent) {    if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {        KeyEvent key = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);        int keycode = key.getKeyCode();        if (keycode == KeyEvent.KEYCODE_MEDIA_NEXT) {            // next        } else if (keycode == KeyEvent.KEYCODE_MEDIA_PREVIOUS) {           // previous        } else if (keycode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {           // play or pause        }    }}Once you’re done playing, or if you lose the audio focus, unregister the media buttons so that other apps can control media playback when needed.Create a Focus Change ListenerAudio focus is a cooperative resource. Once you’ve been granted audio focus, it is not yours to hold until you’re done with it. If other apps request the audio focus, you must respond to those requests to pause playback or stop playing altogether. See Android’s Managing Audio Focus topic for more details. Note: The Fire TV platform does not support volume control from within your app. Although Android distinguishes between a transient loss of focus with or without ducking (lowering the volume), your app should pause playback for both these cases.Listen for audio focus changes withAudioManager.OnAudioFocusChangeListener and the onAudioFocusChange() method. Create this listener as you would any listener.OnAudioFocusChangeListener focusListener = new OnAudioFocusChangeListener() {    public void onAudioFocusChange(int focus) {        switch (focus) {            case AudioManager.AUDIOFOCUS_GAIN:                // continue playback and raise volume (if it was previously lowered)                // ...                break;            case AudioManager.AUDIOFOCUS_LOSS:                // stop playback, de-register buttons, clean up                // ...                break;            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:            case AudioManager.AUDIOFOCUS_LOSS_TRANIENT_CAN_DUCK:                // pause playback                // ...                break;        }    }}The argument for onAudioFocusChange() is an integer that may be one of the following:      AUDIOFOCUS_GAIN): Your app has gained or regained the audio focus. Continue playback or raise the volume.        AUDIOFOCUS_LOSS: Your app has lost the audio focus (likely permanently). Halt playback and de-register the media button receiver.        AUDIOFOCUS_LOSS_TRANSIENT: Your app has lost audio focus for a short amount of time.Pause playback.        AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: Same as transient; pause playback.  Handling Audio Focus with Voice InteractionsWhen users press the Microphone button, system-wide voice capabilities start and cannot be overridden. Your app should pause (implement the OnPause() method) in response to voice interactions. If you need search functionality within your app, you must implement it yourself and provide your own user interface for that function.For audio apps, the voice activity requests a transient audio focus (without ducking – that is, lowering the volume). As such, you should handle the AUDIOFOCUS_LOSS_TRANSIENT event to accommodate voice search.In addition to handling AUDIOFOCUS_LOSS_TRANSIENT, your application should handle other audio focus change events as well (AUDIOFOCUS_LOSS and AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK), since any application (not just voice search) might request any kind of audio focus. In short, all audio focus use cases should be handled appropriately.For backwards compatibility with older applications on the Fire TV platform, we send out both an AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK and an AUDIOFOCUS_LOSS_TRANSIENT when a voice search is initiated. Your applications should handle this use case correctly. Tip: As a best practice, implement all audio focus change events in your app.See the Android documentation on Managing Audio Focus for details on audio focus and audio ducking. For more information about voice search and the results returned from the Fire TV catalog, see Implementing Search on Fire TV.For video apps, your app should pause playback when voice capabilities are invoked (in your OnPause() method). When your app resumes, playback should remain paused until the user presses PLAY. Note: If you need search functionality in your app, you must implement text search yourself and provide your own user interface for the search function.Code Samples for Handling Audio FocusSeveral Java code samples are available that demonstrate how to handle audio focus. The code samples are as follows:  AudioCapabilities.java  AudioDeviceEventReceiver.java  AudioEventManager.java  AudioEventManagerCallbackListener.javaYou can download the code samples here:AudioFocusHandling.zip.These code samples are also available from the SDK download page in the “Other downloads” section.Best Practices for Audio-only ApplicationsIf you have an audio-only application, such as a streaming radio player, the following table provides guidelines about how your app should respond to various events when an audio stream is playing:Event TypeAUDIOFOCUS EVENTListen to Audio Focus Events?Listen to Media Controller Events?Customer/App ExperienceHome button press(none)YesYesAudio stream continues to play. Media controller buttons (for example, play/pause) continue to work.Microphone button pressAUDIOFOCUS_LOSS_TRANSIENTYesYesAudio stream pauses. When user exits the Alexa overlay, audio stream resumes. Media controller buttons continue to work.HDMI cable unpluggedACTION_HDMI_AUDIO_PLUGYesYesAudio stream pauses. When user reconnects HDMI cable, audio stream is in paused state. Media controller buttons continue to work. Audio stream resumes when Play button is pressed.HDMI input switchedACTION_HDMI_AUDIO_PLUGYesYesAudio stream pauses. When user switches HDMI input back to Fire TV, audio stream is in paused state. Media controller buttons continue to work. Audio stream resumes when Play button is pressed.New audio stream is started by different appAUDIOFOCUS_LOSSNoNoAudio stream stops. App stops listening to changes in audio focus and stops listening to media controller events. App cleans up resources used to listen to audio.",
        "url": "managing-audio-focus.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "notifications-for-amazon-fire-tv-html": {
        "title": "Notifications for Amazon Fire TV",
        "tags": "[]",
        "content": "2nd generation Fire TV devices now support standard Android notifications through the Android Notifications API. These notifications appear in a \"Notification Center,\" as described below. However, for 1st generation Fire TV devices, support for standard notifications and the Notifications Center will roll out at a later date.  What Are Notifications?  Types of Notifications Supported on Fire TV          Heads-up Notifications      Toasts      Standard Notifications        Requirements for Notifications  Code Samples  System Notifications  Migrating from the Deprecated Fire TV Notifications APIWhat Are Notifications?A notification is a message to your users that appears outside of your app’s user interface. Fire TV supports the Android Notification API, with some limitations.Typically you use notifications to let users know that you have an update available with your app. The update might be any of the following:  New content available  New levels in a game  New episodes available for an existing series  Live TV channel lineup changed  New game packs available in your app  New functionality  New badges or rewards earned  New releaseYou’re probably used to receiving messages from the various apps on your smartphone. Notifications for your Fire TV apps can provide the same kind of user engagement. The notifications are a way of reaching out to users to encourage them to re-engage with your app in some way.Note that notifications are not Recommendations. Recommendations use a different Android API (which is not currently supported on Fire TV) to recommend content to users, usually on specific rows on the home screen.Types of Notifications Supported on Fire TVThere several types of notifications you can create on Fire TV:  Heads-up notifications  Toasts  Standard NotificationsHeads-up NotificationsFire TV supports Android’s heads-up notifications. Typically on Android devices, heads-up notifications are floating windows that appear at the top of the screen and allow users to interact with the window (such as receiving a call while you’re in another app).On Fire TV, heads-up notifications appear at the bottom of the screen and fade away after a few seconds. Some interaction is allowed while the notification appears. For example, users can click a button or dismiss the notification with the Back button.All undismissed heads-up notifications will be displayed in the Notification Center, where users can review the notifications at their leisure. This also ensures that users will actually see the notifications. (Previously, if users missed the heads-up notification, there wasn’t any way to return to it.)When you create heads-up notifications, you must set the notification as a high priority:.setPriority(Notification.PRIORITY_HIGH) // heads up must be high priorityProgress displays and stacked notifications are not supported on Fire TV. Regarding layouts, heads-up notifications are limited in height to normal layouts only (there are no expanded layouts).ToastsThough rarely used, Fire TV also supports toasts. Toasts are small pop-ups that appear within your app briefly and then disappear, with no ability for the user to interact with the message. Unlike heads-up notifications, toasts are not stored within the Notification Center.Standard NotificationsStandard notifications are informational in nature and do not interrupt the current foreground activity (unlike heads-up notifications, which pop-up in the bottom-right corner of the screen). Notifications from your app are added to the Notification Center as soon as they are raised.The Notification Center appears under the Settings menu. When users have unseen notifications, a little bell appears next to Settings.Within Settings, users select Notifications. This opens what is referred to in the documentation as the Notification Center.The Notifications Center arranges the notifications in a single list ordered by most recent first. The Fire TV Appstore client itself will send notifications when your app has an update (hence you don’t have to worry about pushing these kinds of notifications). In the following screenshot, there are two apps that have updates.When users click the icon, they see the updates available for the app. Users can choose to update the app or not.Notifications should contain enough information to convey the reason for the notification. They can also include an optional intent to launch when the notification is selected. For example, your notification can allow the user to launch your app with a deep link to the specific activity related to the intent.When the update finishes, the user is prompted to launch the app.Users can also turn app notifications on or off on a device-by-device basis. (More granular notification configurations are not possible.) Users can control app notifications by going to Preferences &gt; Notification Settings &gt; App Notifications.Users can also select Do Not Interrupt to suppress heads-up notifications from appearing on the screen. (You will still see standard notifications in the Notification Center and see the bell icon on Settings on the main navigation.)All notifications appear in the Notification Center until the user engages with the notifications, dismisses them, disables notifications for the app, or until the app removes them.A notification that was not dismissed while displayed as a heads-up notification will appear in the Notification Center.Each notification indicates the time or date it was received.As soon as a user visits the Notification Center, whether to click on a notification or not, the bell icon on “Settings” is removed.Requirements for NotificationsThe following table lists requirements for notifications.FeatureDescriptionRequired?  Large Image  A large image used as the tile image in the notification card. This image appears in the Notification Center. The image should be a 16:9 aspect ratio. The actual size of the image container is 228dp with x 128dp, so the image should be at least these dimensions (or larger). Larger images will be scaled down. See setLargeIcon for more details. If a large image isn’t provided, Fire TV will use the large app icon.   Optional  Action  Android intent to launch app or deep-link.  Optional  Title  Title of the notification.   Required  Description  Description of the notification.  Required  Action Text  Text for the Menu button (the default is “Launch now”); this is only included in notifications marked as Urgent.  Optional  Priority  Android priority for the notification (range is -2 to +2). If the priority is +1 or +2 (HIGH or MAX), the notification is considered an Urgent notification. If not included, the default priority is 0.  OptionalCode SamplesFor code samples and technical instruction on how to create notifications, see the Notifications in the Android documentation.System NotificationsFire TV also sends system notifications to users. Although third-party apps can’t replicate or initiate system message notifications, it’s worth mentioning them here. Common Fire TV system notifications might include the following:  Low battery status  Disconnected headphones  Bluetooth pairing  Application download/installation complete  Other system updatesThese notifications appear as small popups in a corner of the screen and can be raised over any content that is on the screen.System notifications will also be stored in the Notification Center (unless users dismiss them in the initial display).Fire TV also provides notifications when your app has an update. These notifications aren’t something you create with your app but rather are triggered by the Fire TV appstore client.Fire TV creates two types of app update messages. A “Required Update” message is a visual prompt on an app icon, indicating that there is a new update available.Another update message is presented to users though an on-device dialogue box. When users start a new session in your app or game, they are presented with the option to “Update Now” or “Launch without Updating” along with details describing what’s new in the update.App Update NotificationAfter the app has been installed, users get a quick notification letting them know it’s ready to launch:Post-Install NotificationMigrating from the Deprecated Fire TV Notifications APIIn the past, Amazon Fire TV included a custom notifications API designed for TV use. As of Fire OS 5, the Amazon Notifications API is deprecated. If your app uses the Fire TV Notification API, those notifications will continue to work, but that API will be removed from the platform at a later date. If your app uses the Amazon Notifications API, we strongly suggest you move to using the standard Android (Lollipop) notification API instead.To migrate your app from the Amazon Notifications API:  Remove all references to AmazonNotification and AmazonNotificationManager as well as to the package com.amazon.device.notification. These can be replaced with the stock Notification and NotificationManager classes in the Android notification API.  References to the AmazonNotification.setType() method and the TYPE_INFO and TYPE_MEDIA_INFO constants should be removed. Android notifications do not specify these types.",
        "url": "notifications-for-amazon-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "specifying-installation-location-html": {
        "title": "Specifying Your App's Installation Location on Fire TV",
        "tags": "[]",
        "content": "The settings in your Android Manifest file determine where your app is installed on Fire devices. Two storage locations are possible:  External storage (such as an SD card)  Internal storage (using the device’s memory)Fire TV Stick doesn’t have external storage, but Fire TV (the set-top box) does provide external storage options through a memory card slot.Generally, your app should specify external storage as the default install location.  Best Practices  How to Specify External Storage  When to Select Internal Storage  Fire TV External Storage Settings  Handling secondary downloads in your app  Specifying Install Location with UnityBest PracticesAs a best practice, most apps should specify preferExternal for the installLocation in the Android Manifest file. If left unspecified, your app will be installed on internal storage.Filling up internal storage can lead to:  Fewer app installs  Poor app ratings  Negative customer experiencesSome users may have abundant space available in external storage, but if an app’s Manifest does not specify preferExternal, the app will be installed internally. As a result, users get prompted with low storage warnings or cannot install the app at all, which leads to user frustration.Selecting preferExternal helps ensure the greatest user base for your app and a better user experience on Fire devices.How to Specify External StorageIn the AndroidManifest.xml of your app, inside the &lt;manifest&gt; tag, add the installLocation attribute and set its value to preferExternal. Here’s an example:&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:installLocation=\"preferExternal\" ... &gt;    ...&lt;/manifest&gt;The installLocation parameter has several values available:                                                installLocation value             Description                                                    preferExternal                                        Recommended for most apps. Install your app on external storage when available. If external storage is full, install the app to internal storage (if available). The user can manually move the app later by selecting it from Settings &gt; Apps &amp; Games &gt; Manage All Applications.                                            internalOnly                                        Install the app only to internal storage. If there is not enough room in internal storage, the install will fail. The app cannot be manually moved later by the user. Not recommended for most apps. Choose this option only for the types of apps described in the next section.                                                        auto                                        Install to internal storage by default. However, if internal storage is full, install the app to external storage (assuming external storage is available). The user can manually move the app later by selecting it from Settings &gt; Apps &amp; Games &gt; Manage All Applications.                        Note that even though the APK file is installed on external storage, all databases, private user data, optimized .dex files, and extracted native code are stored on internal storage.See App Install Location in the Android documentation for more information.When to Select Internal StorageMost apps should select preferExternal for the installLocation. However, DRM-protected media apps are an exception:  If your app plays DRM-protected media, DRM resources may become unstable if USB storage becomes unavailable.  If your app plays DRM-protected media, either do not include installLocation at all, or set its value to internalOnly.In addition to DRM-protected media apps, the following types of applications should never be installed on external storage:  Services  Alarm Services  Input Method Engines  Account Managers  Sync Adapters  Device Administrators  Broadcast Receivers listening for “boot completed” message  Live Wallpapers (not supported on Fire OS)  App Widgets (not supported on Fire OS)See the App Install Location documentation in Android for more details.Fire TV External Storage SettingsFire TV (Generation 1) supports USB external storage and Fire TV (Generation 2) includes a microSD slot for external storage. On these devices, settings are provided for users to manage connected external storage.Users can also move internally stored apps to the SD card:Handling secondary downloads in your appFor apps that perform their own secondary downloads as part of first run or at any other time, these downloaded files are usually stored where the APK file was installed on the device. If the app was installed on external storage, the APK file will be on external storage.Some applications, particularly games, use secondary downloads containing additional textures, levels, or other asset files. If you are handling this download in your app code, such as part of first run initialization, use the Android PackageManager getApplicationInfo method to retrieve the ApplicationInfo class.The ApplicationInfo class contains the location of the APK (sourceDir) and the public parts of the source directory, including the resources and manifest (publicSourceDir). If the app has been installed on external storage, these paths will point to that location and indicate where users should install the additional downloaded content.If your app uses installLocation=\"preferExternal\" to install a 40MB APK onto external storage, but then stores a 1GB downloaded data file to internal storage because the app uses the ApplicationInfo dataDir path, this would defeat the purpose of using external storage and quickly fill up the device’s internal storage, leading to customer frustration. Therefore make sure the secondary downloads use the sourceDir for the download path.Specifying Install Location with UnityUnity is one of the most popular tools for creating games for the Amazon Appstore. Unity supports setting the install location through the Player Settings Inspector for Android. To configure your app install location on external storage:  From your Unity project, click File-Build Settings….      From the Build Settings dialog, select Android in the Platform list and click the Player Settings… button to display the inspector.            Open the Other Settings section and look for the Install Location setting. preferExternal is usually the default – this is almost always the best choice.      YoYo Games’ Gamemaker:Studio also uses preferExternal as the default for Android projects. Although you can manually change this default, it’s recommended that you leave it as is.Other engines and development frameworks provide similar options. Consult the documentation for the tool you are using to make sure you are using are configured to set the installLocation to preferExternal in the APK manifest.",
        "url": "specifying-installation-location.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "user-agent-strings-html": {
        "title": "User Agent Strings for Fire TV",
        "tags": "[]",
        "content": "The Fire TV platform includes the Android WebView (android.webkit.WebView), the Amazon WebView (com.amazon.android.webkit.AmazonWebView), and the Amazon web app platform. Each has an associated user agent string.An app or web page can read the user agent string to detect Fire TV and then provide a specific user experience. User agent strings can include the version of the host operating system, the version of the browser, and other information. Note: The Fire TV platform does not include a browser. Tip: If you’re trying to identify different Fire TV devices, see Identifying Amazon Fire TV Devices.  User Agent Strings  Placeholders in User Agent StringsUser Agent StringsWhen reading the user agent string, do not rely on specific version numbers within the string that are subject to change when the software is updated. To provide a Fire TV-platform specific experience, test for the string “AmazonWebAppPlatform” in combination with a device model that starts with “AFT”.The following table shows the user agent strings for Fire TV:            User Agent      String      Example                  Android WebView(android.webkit.WebView)      Mozilla/5.0 (Linux; U; Android &lt;android&gt;; &lt;locale&gt;; &lt;device&gt; Build/&lt;build&gt;) AppleWebKit/&lt;webkit&gt; (KHTML, like Gecko) Version/4.0 Mobile Safari/&lt;safari&gt;      Mozilla/5.0 (Linux; U; Android 4.2.2; en-us; AFTB Build/JDQ39) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30              Amazon WebView(com.amazon.android.webkit.AmazonWebView)      Mozilla/5.0 (Linux; Android &lt;android&gt;; &lt;device&gt; Build/&lt;build&gt;) AppleWebKit/&lt;webkit&gt; (KHTML, like Gecko) Chrome/&lt;chrome&gt; Mobile Safari/&lt;safari&gt;      Mozilla/5.0 (Linux; Android 4.2.2; AFTB Build/JDQ39) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.173 Mobile Safari/537.22              Amazon Web App Platform      Mozilla/5.0 (Linux; Android &lt;android&gt;; &lt;device&gt; Build/&lt;build&gt;) AppleWebKit/&lt;webkit&gt; (KHTML, like Gecko) Chrome/&lt;chrome&gt; Mobile Safari/&lt;safari&gt; cordova-amazon-fireos/&lt;amazon&gt; AmazonWebAppPlatform/&lt;amazon&gt;      Mozilla/5.0 (Linux; Android 4.2.2; AFTB Build/JDQ39) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.173 Mobile Safari/537.22 cordova-amazon-fireos/3.4.0 AmazonWebAppPlatform/3.4.0;2.0      Placeholders in User Agent StringsThe following placeholders in the user agent string are for version numbers that vary by device, for values that can be altered by the user, or for values that can change when Amazon updates the software on the device:  &lt;android&gt; indicates the Android version number, for example, 4.2.2.  &lt;locale&gt; indicates the chosen language and country or region for the phone. The value consists of the lowercase hyphenated concatenation of the two-letter ISO 639-1 language code and the two-letter ISO 3166-1 alpha-2 country code, for example, en-us.  &lt;device&gt; is the value of android.os.Build.MODEL, for example, ATFB. Test for a device that starts with “AFT” to cover all devices on the Fire TV platform.  &lt;build&gt; is the value of android.os.Build.ID, for example, JDQ39.  &lt;webkit&gt;, &lt;chrome&gt;, and &lt;safari&gt; indicate the version numbers for WebKit, Chrome, and Safari, for example, 534.30.  &lt;amazon&gt; indicates the version number of the Amazon web app platform, for example, 3.4.0.",
        "url": "user-agent-strings.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "user-interface-html": {
        "title": "Android Menu and ActionBar widgets",
        "tags": "[]",
        "content": "This page describes how to modify the Android Menu and ActionBar widgets to work for your Fire TV app.The Amazon Fire TV platform supports the majority of the existing Android UI framework (android.widget.*) with no changes. The two exceptions are Menu and ActionBar. All other Android widgets work without modifications, although those widgets may have a different appearance in the Fire TV user interface.Menus and Action BarWhen your app uses Android’s ActionBar, it is important to note that, in order to avoid cluttering the user interface, the action bar items do not appear on the screen. Instead, items from the action bar are displayed in a modal dialog box when the user presses the Menu button on one of the Fire TV remotes or the Fire Game Controller. The user can then pick an Action Item or a Navigation Tab from the dialog.Currently, only the action items, tabs, options menu and sub menus on the action bar are handled. On the launch of any application or activity, the action bar does not show up by default. Pressing the menu button brings up a dialog window containing two listviews arranged side by side, at a max. The left list view contains all the tabs and the one on the right shall contain the action items.Users can navigate between and within the lists with the directional navigation buttons on the remote or game controller. If for an item, a sub-menu exists, then clicking on the item causes its sub-menu appear as a list in the place of its parent. This implementation does not keep track of the menu hierarchy and the navigation state. Pressing Back at any point dismisses the dialog window.You can get a handle to the action bar using the getActionBar() method in the onCreate(Bundle) method for your activity. Access to its complete API is possible in your activity.Note that Drop-down lists and action Views are not supported by the Amazon Fire TV platform.",
        "url": "user-interface.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "amazon-fire-tv-differences-from-android-tv-development-html": {
        "title": "How Fire TV Development Differs from Android TV Development",
        "tags": "[]",
        "content": "Because both Fire TV and Android TV use Android, you can push your same Android app out to both the Amazon Appstore and Google Play Store. Making your app available on both Amazon and Google stores can significantly increase the visibility and downloads of your app.However, there are some differences with Fire TV that you need to account for in your code. Some of the differences are due to unique elements in the hardware or services. In some cases one service has features the other doesn’t have, or they use different but equivalent services.As you code for these differences, be aware that you can identify Amazon Fire TV devices and conditionalize your code to target different behavior accordingly.  What is Fire TV and Android TV?  Google Services  LeanBack Support Library  Voice Search  Global Search  Audio Focus  Fast-forward, Rewind, and Menu Buttons  In-app Purchasing  Analytics  SDK Level  Recommendations  Emulators  Notifications API  Accessibility  Appstore  Testing Your AppWhat is Fire TV and Android TV?First, let’s clarify what we mean by Android TV and Fire TV:  Android TV refers to the Android operating system that has been optimized for TV (starting at Lollipop). Android Lollipop and the Leanback Support Library provide features that optimize Android for TV platforms. TV devices themselves can run Android TV as their native OS, or TVs can run Android through set-top boxes. You can learn more about Android TV on Wikipedia.  Fire TV refers to the Fire TV set-top box or stick that run the Fire operating system (OS) on your TV. Fire OS is a fork of Android 5.1 (Lollipop, API level 22) that accommodates Amazon hardware and services. Fire tablets also run Fire OS but do not leverage the features typically used for the “10-foot media experiences” on TV platforms. (Learn more about Fire OS or see the Fire TV Device Specifications.)The important point is that both Android TV and Fire TV are Android-based, so the techniques you implement for your app share far more similarities than differences.The following sections list the differences you need to account for in your code when planning for Fire TV.Google ServicesAny APIs that rely on Google-specific services, such as Google location services, aren’t available on Fire TV. Although there is an Amazon Maps API as well as an Amazon Mobile Ads API, they are not yet supported on Fire TV.LeanBack Support LibraryFire TV supports some but not all of Android’s Leanback Support Library. For example, Fire TV uses TV-specific UI components from Leanback, Leanback widgets will work, and Fire TV will honor intents tagged for the LEANBACK_LAUNCHER. But Leanback’s SearchFragment (described in the next section) is not supported.Voice SearchFor voice search, Android TV uses app controls that rely on Leanback APIs (for example, speech recognition with the SearchFragment). However, voice search on Fire TV does not use Leanback’s SearchFragment. On Fire TV, voice search uses Amazon-specific system controls.No matter where users are on Fire TV (whether on the Launcher or in an app), when users press the microphone button on a voice-enabled remote and say the TV show or Alexa actions they want, this action initiates a global search using the Alexa cloud service instead speech recognition APIs in the Leanback library.Media requests through voice always return content from the Fire TV catalog. See Implementing Search in Fire TV for more details.Global SearchOn Android TV, to integrate your content into global search, you can do so locally through your app using a search results ContentProvider.With Fire TV, to make your content appear in global search results, you must integrate your media content with the Fire TV Catalog. Submission to the Catalog is done through a cloud-based model (rather than locally within your app).Audio FocusIf a user started playing music from a music app prior to starting your app, Fire TV will continue to play music over your app. The Play/Pause buttons will control the music instead of the video in your app.To receive the audio focus, your app must register a MediaButtonReceiver in your the manifest. The MediaButtonReceiver will transfer the audio focus to your app’s media service when your app starts. See Managing Audio Focus for more details and code samples.Fast-forward, Rewind, and Menu ButtonsBoth Android TV and Fire TV have 4-way directional pad (dpad), dpad_center/select, back, and play/pause buttons. However, Fire TV also offers rewind, fast-forward, and menu buttons that you can optionally use.The Menu button on Fire TV invokes the Android context menu, which appears as a list of menu items centered on the screen. You can override the menu button to provide your own custom menu user interface, or for any other purpose.If you only have one menu item, consider using the Menu button as a simple toggle — for example, to turn closed captions on or off. If you do this, consider providing an onscreen hint to expose this feature to your users.In-app PurchasingAndroid TV often uses Google In-App Billing for in-app purchases. For in-app purchases on Fire TV, you use Amazon’s In-App Purchasing (IAP) API. For more information, you can see a detailed comparison of the two.AnalyticsAndroid TV uses Firebase for Analytics. With Fire TV, you can use Amazon Mobile Analytics or another analytics package (Google Analytics, Flurry Analytics, Crashlytics, and so on). Many of these analytics packages are configurable as modules if you build your app with Fire App Builder.SDK LevelWhile Android TV can use the latest SDK (Nougat), Fire TV uses only Lollipop (API level 22) as the minimum SDK level. (Some APIs from Marshmallow have been backported into Fire OS to support certain apps.)RecommendationsAndroid TV lets apps make recommendations on the home screen. This same recommendations functionality is coming to Fire TV and will be available soon (most likely Q2 2017 or sooner).EmulatorsWhen testing out your Fire TV app code, you use an actual Fire TV device (either the set-top box or stick) instead of a virtual emulator. See Connect to Fire TV Through ADB for more details.Notifications APIYou use the standard Android Notifications API for creating notifications for your Fire TV app. Fire TV provides the same toast notifications and persistence model as Android TV. However, in addition to toasts, Fire TV also provides Heads up notifications, which allow interactive buttons.Additionally, instead of putting old notifications in a notification drawer, on Fire TV notifications are stored in a Notification Center. Learn more at Notifications for Amazon Fire TV.AccessibilityFire TV provides VoiceView to make your app accessible to the visually impaired. You can learn more about VoiceView and accessibility here:  Understanding Assistive Technologies for Fire OS  Implementing Accessibility in Fire OSAppstoreAndroid TV devices use the Google Play Store. In contrast, Fire TV uses the Amazon Appstore. Any links you have pointing to the Google Play store will need links to the Amazon Appstore.Testing Your AppYou can test your Android app’s compatibility with Amazon by sideloading your app onto an Amazon Fire TV device. See Connecting to Fire TV Through ADB. You can also test your app with the App Testing Service.When you connect to a Fire TV device through ADB and run your app with Android Studio, a successful app will load and play. If you close your sideloaded app, you can find it by going to Settings &gt; Applications &gt; Manage Installed Applications. Tip: See the Test Criteria for Amazon Appstore Apps for more details on requirements your app needs to meet for the Amazon Appstore.",
        "url": "amazon-fire-tv-differences-from-android-tv-development.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "amazon-fire-tv-sdk-frequently-asked-questions-html": {
        "title": "Amazon Fire TV Frequently Asked Questions (FAQs)",
        "tags": "[]",
        "content": "General  Q: How do I submit my app for the Amazon Fire TV platform?  To submit your app for an Amazon Fire TV device, create an account on the Amazon Apps &amp; Games Developer Portal and submit your app through the portal.    If you already have an app published at Amazon, update that app to include a separate binary APK for Amazon Fire TV. See Using Device Targeting for more information.    Q: Will my app work on the Amazon Fire TV platform?  Your app must be compatible with the specifications for Amazon Fire TV devices. See Device Specifications for detailed device and feature specifications.    Your app must comply the Amazon Appstore Content Policy Requirements. Amazon also recommends that you test your app on your own and submit an update if you discover any problems.    Q:  How can I identify whether my app is running on an Amazon Fire TV device?  A: You can check for the feature amazon.hardware.fire_tv. If you absolutely must look for the Fire TV Gen 1 or Fire TV Gen 2 device, you can check for the MODEL AFTB or AFTS respectively, but always include a fallback for the feature. See Identifying Amazon Fire TV Devices for more information.  Q: Can I sideload my app onto Amazon Fire TV for testing?  Yes, with the Android Debug Bridge (ADB).  See Getting Started Developing Apps and Games for Fire TV for more information.   Q: Are Amazon Fire TV test devices available for developers?  Amazon does not provide test devices for developers.    Amazon Fire TV devices are available for purchase on Amazon retail sites in the US, UK, and Germany. Check the product detail pages for country-specific availability.    Q: What specific features does the Amazon Fire TV platform support?  See Device Specifications, Fire tablets for detailed device and feature specifications.  Q: How do I get my app marketed on the Amazon Fire TV platform?  See Marketing Your App.  Q: How can I get more information about the Amazon Fire TV platform?  Please use the Contact Us form to send us your questions.  Q:  Under what circumstances should my app pause, and how do I implement pause behavior?  A: Your app pauses when the Microphone (voice search), Home, or GameCircle buttons are pressed on one of the Fire TV remotes or on the Amazon Fire Game Controller. The Back button also pauses the current activity and resumes the previous activity on the stack, which may or may not be your app.    To handle pause behavior, implement the onPause() method in your activity as you would in any other Android app. In your onPause() method, ensure that you save the user’s state or position, so that when your app resumes the user is in the same place that they were before the pause.    In addition, the following requirements apply to media apps:          Apps that play video should pause playback, and must release all media resources such as decoders immediately on pause, as these limited resources are hardware-based and memory-constrained. See Releasing the Media Player and MediaPlayer.release() for details.      Apps that play audio may continue playing after a pause, but must relinquish audio focus if requested by another app. See Managing Audio Focus for details.        Q:  Can I open an advertisement in the default web browser?  A: Amazon Fire TV does not include a browser app, so links to all URLs (advertisements or otherwise) do not work. You can use the Android WebView if you need to include a link to a web page in your app. Note, however, that the Android WebView requires you to manage your own cookies and authentication, as well as handle input events from controllers. (WebView in Android does support D-Pad navigation, but layout and navigation may need review.)    See the blog post Using WebViews on Tablets with HD Screens for tips on implementing an Android WebView. Although this post is specific to tablets, the advice can also be applied to TV.    Q:  Can I use the Amazon In-App Purchasing API in my Fire TV app?  A: Yes, Amazon’s In-App Purchasing (IAP) API works on all Fire TV devices and with the Fire TV remotes and game controllers. Use App Tester to preview your transactions.  Q:  Can I use Amazon Device Messaging (ADM) in my Fire TV app?  A: You can use Amazon Device Messaging to receive push messages and other data.  Q:  Can I use the Amazon Maps API in my Fire TV app?  A: There are no location services in Amazon Fire TV, so the Amazon Maps API is not supported at this time.  Q:  Can I use the Amazon Mobile Ads API in my Fire TV app?   A: The Amazon Mobile Ads API is not supported on Fire TV at this time.  Q:  Can I link to my app’s details page in the Amazon Appstore?  A: Yes, Amazon Appstore deep links work as they do for other apps. See Linking to the Amazon Client for more information on deep linking. Note, however, that the ability to rate apps is not currently supported by Amazon Fire TV. Your app should not prompt the user for a rating.  Q:  How do I change the onscreen keyboard to a numeric keypad?  A: You can use the standard Android mechanisms for configuring the IME (input method editor) for any EditText widget. In XML, use android:inputType=\"number\":    &lt;EditTextandroid:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\"android:id=\"@+id/edittext\"android:inputType=\"number\"/&gt;        Q:  How do I take screen shots on Amazon Fire TV?  A: To take screen shots, connect to the device with adb and use these commands. Substitute the name of your screen shot for filename.png and the directory on your development computer where you want to put the screen shot for /tmp:    adb shell screencap -p /sdcard/filename.pngadb pull /sdcard/filename.png /tmpadb shell rm /sdcard/filename.png        See Taking Screenshots of your Fire TV App for more details.    Q: My app uses Google’s in-app purchasing technology. Will it work on the Amazon Fire TV platform?  No. Services such as Google’s in-app purchasing API require access to Google Mobile Services, which do not work on the Amazon Fire TV platform. For in-app purchasing, Amazon offers an In-App Purchasing API that makes it easy for you to offer digital content and subscriptions in your apps.  Q: Are there any other criteria for distributing apps for Amazon Fire TV or Fire TV Stick in Germany and/or Austria?  Yes. We do not permit apps to be distributed on Amazon Fire TV or on Fire TV Stick in Germany and/or Austria, if the apps enable copying, recording, downloading, storing, or similar actions of any type of video or audio content onto the Amazon Fire TV or Fire TV Stick device, any SD memory card or any connected external storage (where applicable). If we determine that an app contains this functionality, we will not make it available in Germany and/or Austria.Fire OS 5 (Android Lollipop)  Q: Does Fire OS 5 support Android TV and the v17 Leanback Library?  A: Fire OS 5 includes both support for Android TV functionality and the Leanback Library. However, speech recognition with the Leanback library’s SearchFragment class is currently unsupported. See Implementing Search in Fire TV for more details.Media and DRM  Q: What third-party media player SDKs are supported by Fire TV?  A: Any media player SDKs that implement the Android media playback and encryption APIs work on the Amazon Fire TV platform.  Examples of these SDKs include the Amazon Port of the ExoPlayer, the Android MediaPlayer, the VisualOn OnStream MediaPlayer+ SDK, and the NexStreaming NexPlayer SDK. See Media Players for more details.  Q:  What are my options for implementing playback of media encrypted with Microsoft PlayReady DRM?  A: The Amazon Fire TV platform includes support for the Android MediaCrypto class for playing protected media, or you can use a third-party media player SDK that supports PlayReady. Amazon Fire TV supports PlayReady version 2.5 only. (Fire TV devices cannot support PlayReady Security Level 3000 (SL3000) because this was introduced in PlayReady 3.0, and Amazon Fire TV devices support version 2.5 only.)  Q:  Does Amazon Fire TV support PlayReady content that uses encrypted audio?  A: PlayReady content with encrypted video and clear (non-encrypted) audio is supported on Fire TV. Widevine DRM is also supported. See the DRM section on the Fire TV Device Specifications page for more details. If you need to play content with both encrypted audio and video, please contact us for further information.  Q:  How do I decode Dolby Digital audio on Fire TV devices?  A: Both Fire TV and Fire TV Stick contain decoders for Dolby Digital (AC3) and Dolby Digital Plus (eAC3). You should be able to play these formats with the standard Android media player libraries. Note that the DolbyAudioProcessing SDK for Amazon Fire tablets is not supported (or required) for Fire TV devices. For more information about playing Dolby, see Dolby Integration Guidelines.  Q:  Does the device support Secure Boot to verify firmware and OS?  A: Yes.  Q:  Does the OS enforce signature checking of apps?  A: Yes.  Q:  Is output HDCP protected though a secure channel over HDMI?  A: Yes.  Q: Does Amazon Fire TV support customizable closed captioning (CEA-708)?  A: Fire TV has limited platform-level closed captioning support at this time. Media apps are responsible for and must implement a UI that enables viewers to customize  captions through a third-party media playback SDK or their own implementation.  Q: What fonts are available on Amazon Fire TV for use with closed captions?  A: Amazon Fire TV includes limited platform fonts. You must license and embed your own font files for each of the style categories defined by CEA-708.Media Playback  Q:  What are best practices with media playback to preserve resources and memory?      A: Because the media playback resources in Amazon Fire TV are hardware-based and memory constrained, your app must be well-behaved and release the media resources when you are done with them.    Specifically, apps that play video should pause playback and must release all media resources such as decoders immediately in your onPause() method. See Releasing the Media Player and MediaPlayer.release() for details.    If your app plays video through an Android WebView (with the &lt;video&gt; HTML tag), hardware media resources are not currently released by the system when your app pauses or stops. To work around this issue, explicitly release these resources by killing the processes when you implement your onPause() and onStop() methods:    public void onStop() {   super.onStop();   android.os.Process.killProcess(android.os.Process.myPid());}        Q: My app plays music in the background. When my app pauses, why does the audio stop playing? OR when my app starts, why does audio from another app keep playing?  A: Your app is not correctly managing audio focus. When your app begins playing it should both request audio focus and register for media button events. When your app relinquishes audio focus (because you’re done playing or because another app has requested it), it should also unregister from media button events. Specifically:          When your app begins playing, request audio focus with AudioManager.requestAudioFocus()      If audio focus was granted, register a media button receiver with AudioManager.registerMediaButtonEventReceiver()      Listen for the loss of audio focus with AudioManager.onAudioFocusChangeListener()      If your app loses audio focus, stop playback and unregister the media buttons with AudioManager.unregisterMediaButtonEventReceiver()        See the following for more details:          Managing Audio Focus (Fire TV docs)      Managing Audio Focus (Android docs)      Allowing applications to play nice(r) with each other: Handling remote control buttons        Q:  Why does my music app keep getting randomly killed when it’s playing in the background?  A: Make sure you are running your music playback app as a foreground service. Background services (the default) are automatically shut down by the system when resources are low. See the Android guide for Media Playback and the startForeground() method in the Service class for details.  Q:  How should I handle the TV being turned off/disconnected with the HDMI cable?  A: The expected behavior for an HDMI disconnect is different for audio and video. See Handling HDMI Events for details.  Q:  During media playback, how do I prevent the device from entering standby or daydream mode (screen saver)?  A: To keep both Amazon Fire TV and the television awake during media playback, set the KEEP_SCREEN_ON flag for your activity, or acquire a wake lock from the power manager. Your app must release all wake locks when it is not actively playing audio or video so that both the device and the television can sleep and preserve power. See the PowerManager and PowerManager.WakeLock classes for details on using wake locks.    Note that if your app plays audio and you set a partial wake lock for your app PARTIAL_WAKE_LOCK, the television remains on and when idle the device enters daydream mode (displays the screen saver). This is different behavior from a partial wake lock on a mobile device (where it keeps the CPU on, but turns the screen off), as audio playback over HDMI requires the television to be on. Again, make sure you release the wake lock when your app stops actively playing audio so that the television can sleep.    Setting the SCREEN_BRIGHT_WAKE_LOCK or SCREEN_DIM_WAKE_LOCK flags has no effect on the behavior of the device.    Q:  How can I detect when the device has entered daydream mode (the screen saver is on)?  A: Daydream mode is an Android function. When Amazon Fire TV enters daydream mode it displays the screen saver if the TV is on. Register for Intent.ACTION_DREAMING_STARTED and Intent.ACTION_DREAMING_STOPPED to detect when the device enters or exits daydream.    Note that if your app plays audio but is not a music app, you should pause audio playback when the device enters daydream mode.    Q:  Can I use an Android WebView and the &lt;video&gt; HTML tag for video playback?  A: Yes, with limitations. Hardware media resources are not currently released by the system when your app pauses or stops. To work around this issue implement your onStop() method to explicitly kill the process for your app:    public void onStop() {super.onStop();android.os.Process.killProcess(android.os.Process.myPid());}        This issue may also cause instability in the user experience and navigation for your app. Use of a third-party media player SDK is the recommended method for media playback on the device.    Q:  Can I play 4K Ultra HD Videos in my App?      Yes, Fire TV (2nd Generation) can play 4K Ultra HD video when connected to a 4K-supported TV. Fire TV (1st Generation) and Fire TV Stick do not play 4K videos.    Before playing 4K content, your app needs to check whether (1) the device in a Fire TV (2nd Generation) device and (2) whether the connected TV supports 4K. An Amazon 4K Extension Library has been developed to allow you to initiate the 4K mode switch.    Apps that support Ultra HD video will be certified by Amazon to ensure they meet the required customer experience. Typically, certification takes a couple of weeks. See Playing 4K Ultra HD Videos for more details.  Controllers  Q:  The Amazon Fire TV Game Controller does not have media buttons like the previous version did. How do I handle media playback?  A: Amazon Fire TV generates media input events for the analog stick presses (Play/Pause) and for the left (Rewind) and right (Fast Forward) shoulder buttons (L1/R1). If you do not use those buttons in your app or game, make sure you do not capture or throw away those button events so the user can control media playing in the background.    If you repurposed the media buttons on the Amazon Fire Game Controller for other purposes in your app, users of the new Amazon Fire TV Game Controller cannot use that functionality without the buttons. Consider updating your app to use buttons common to both game controllers, and updating your on-screen hints.    Q: How do I manage volume control from the Amazon Fire TV Game Controller?  A: Amazon Fire TV can stream audio to the headphone jack on the Amazon Fire TV Game Controller (current generation devices only). The left and right trigger buttons (L2/R2) are used to control the volume.    Volume control is a system function and cannot be mapped to other buttons in your app. However, if you do not use the trigger buttons in your app or game, make sure you do not capture or throw away those button events so the user can control media playing in the background. If you do use these buttons for other purposes in your app or game, consider providing an on-screen hint that the user can control the volume from the GameCircle screen or the system launcher.    Q:  Can I override the Microphone button on the Fire TV Voice Remote in my app?  A: The Microphone button launches system-wide voice capabilities (requesting a transient audio focus) and cannot be overridden. Your application should handle this audio focus change event (AUDIOFOCUS_LOSS_TRANSIENT) as well as other audio focus change events too (AUDIOFOCUS_LOSS and AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK), since any application (not just voice) might request any kind of audio focus. In short, all audio focus use cases should be handled appropriately. See Handling Audio Focus with Voice Search for more details.  Q:  What does the Menu button do, and can I override it in my app?  A: By default, the Menu button invokes the Android context menu, which appears as a list of menu items centered on the screen. You can override the menu button to provide your own custom menu user interface, or for any other purpose.    If you only have one menu item, consider using the Menu button as a simple toggle (for example, to turn closed captions on or off), and provide an onscreen hint to expose that feature to your users.    Q:  Why doesn’t the GameCircle overlay for my game appear when I press the GameCircle button on the Fire Game Controller?  A: The GameCircle overlay appears only if:          Your game has implemented the GameCircle API.      Your game has been submitted to the Amazon Appstore, and is categorized as a game.      Your game has been installed on to a Fire TV device from the Amazon Appstore.        The GameCircle overlay does not appear if you have sideloaded your game onto a Fire TV device for testing. You can test your GameCircle implementation in your app before submitting it with Live App Testing.    The GameCircle overlay may also not appear if you have not yet published any leaderboards or achievements AND you’re not using a test account. In this scenario either publish at least one achievement or leaderboard in the Amazon Developer Console, or set up a test account (also in the Developer Console), and use that account to view draft achievements and leaderboards in the GameCircle overlay.    Q:  Why is my activity restarted from scratch when a controller is connected, disconnected or sleeps?  A: These events are handled as runtime configuration changes by Android. To ignore these events in your app, modify your AndroidManifest.xml to include the android:configChanges attribute, and include keys for keyboard, keyboardHidden, and navigation:    &lt;activity android:name=\"MyActivity\"android:configChanges=\"keyboard|keyboardHidden|navigation\"&gt;        See the Android Guide Handling Runtime Changes for information on the configChanges attribute and how to handle configuration changes in your app, if necessary.    Q:  How do I handle game controller disconnects in my app or game?  A: The Amazon Fire TV Game Controller may disconnect from the system if it is idle or if either stick is held at an angle for more than five minutes (to preserve battery life). Other controllers may also disconnect when idle or when battery life runs out. Use the Android OnInputDeviceRemoved listener to handle controller disconnection events. Consider pausing the game or displaying a dialog to let the user know the controller is no longer available.Amazon Fire TV Stick  Q:  What are the differences between Amazon Fire TV and Fire TV Stick?  A: Fire TV Device Specifications lists the specifications for all Fire TV devices.  Q:  How do I adapt my Amazon Fire TV app to Amazon Fire TV Stick?  A: Both Amazon Fire TV and Fire TV Stick run the same platform software. However, because of the more limited hardware on the Fire TV Stick, optimizing your app for performance and stability are critical. Make sure you follow Android best practices for hardware acceleration and performance. Watch out in particular for OpenGL and textures; the Fire TV Stick’s GPU supports OpenGL 2.0 with a MAX_TEXTURE_SIZE of 2048x2048.  Q:  How can I identify a Fire TV Stick device?  A: You can check for the feature amazon.hardware.fire_tv. If you absolutely must look for the Fire TV Stick, you can check for the MODEL AFTM. See Identifying Amazon Fire TV Devices for more information.  Q:  Some of the images/backgrounds in my app are not appearing, or I’m getting grey boxes for those images.  A: This is usually a result of bitmap images or textures that are too large. Fire TV Stick supports textures up to 2048x2048. You may see an error in the logs like this if your app has this problem:    W/OpenGLRenderer( 8941): Bitmap too large to be uploaded in a texture (3840x2160, max=2048x2048)        Also, make sure your images for Fire TV are in the drawables-xhdpi/ folder and not in drawables/. Platform scaling of the default drawables may result in large images that exceed the texture limit.  ",
        "url": "amazon-fire-tv-sdk-frequently-asked-questions.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "design-and-user-experience-guidelines-html": {
        "title": "Design and User Experience Guidelines for TV Platforms",
        "tags": "[]",
        "content": "Television user interface design differs significantly from the design for desktop computers, tablets, or phones. These guidelines will help you become familiar with the design principles for a 10-foot UI and help you integrate your application and its design into the Amazon Fire TV user interface.  General Principles          10-Foot UI      Clear, Simple, and Visual      Place Important Content First      Focus on Consumption        Design Guidelines          Screen Size and Resolution      Overscan and the Safe Zone      Color      Typography        Navigation and Input          D-Pad Directional Navigation      Focus and Selection      Text Entry        Screens, Views, and Flows          Home Screen (Launcher)      1D List Views      Detail View      Search      Additional Resources      General PrinciplesUse these principles to guide the design of your app as a whole.10-Foot UITV interfaces are often referred to as 10-Foot User Interfaces (10-ft UI), because the user is viewing the screen from 10 or more feet away. Although the screen itself can be large, the screen resolution is lower, and distance from the screen means a smaller angle of view.The design choices you would make for an application or web page running on a desktop computer, tablet, or phone are fundamentally different, as users typically view those screens from much closer distances.In addition, as the television is used in a more relaxed fashion than a computer, a tablet or a phone, the UI on the TV should not require as much attention and precision. 10-ft UI may require you to wholly rethink the design, layout, and navigation of an existing app.Clear, Simple, and VisualThe design of a screen in a 10-ft UI requires simplicity and clarity, with low information density. Limit the number of design elements or UI components (menus, buttons, images) on the screen, and ensure that those elements are large enough and spaced far enough apart to be read from a distance. Present a clear set of actions or options for each screen.Minimize the amount of text, as users do not read a lot of text on a television screen. Avoid requiring the user to input a lot of information and provide reasonable defaults where possible.Place Important Content FirstPlace the most important content or options first on the screen so they are easily viewable and navigable by the user.Focus on ConsumptionApplications should have a clear focus on getting users to content quickly. Television interfaces are primarily about providing entertainment. When users sit down in front of their television, they don’t want to do extra work. They need simple user interfaces that match their primary goal: “Give me something to watch or listen to or play with right now.”Design GuidelinesUse these guidelines when designing individual screens and views in your app.Screen Size and ResolutionWhen you design an app for a tablet or phone screen, you’re working with screens that have a fixed size and resolution. TV design differs in that the same app can appear in either 720p or 1080p resolutions, on a screen of any size.We recommend for the best possible experience that you design your app and its resources for a full 1080p television screen. The Amazon Fire TV platform scales your resources to the appropriate TV output. For 1080p the screen size is 1920x1080px, the density is 320dpi (“xhdpi”) and the output resolution is 960x540dp (“large”).The Amazon Fire TV platform also supports the standard Android configurations for enabling multiple resource directories for different output parameters, as described in the Android developer guide for Supporting Multiple Screens.When your app runs,  Fire TV loads your resources from the appropriate folder. See Display and Layout for more information on the resource configurations available for Amazon Fire TV.Overscan and the Safe ZoneRegardless of its physical size, TV hardware manufacturers reserve space around the displayable area of the screen. This reserved space is known as overscan. The amount of space a TV uses as overscan varies across manufacturers. That real estate is not available to your app.Although the Amazon Fire TV platform provides a way for the user to adjust for television overscan in the settings, for the safest possible behavior we recommend that you avoid placing any of your app’s UI elements within the outer 5% of any edge on the screen. The focused item and on-screen text, especially, should be fully within the inner 90% (the safe zone) of your user interface.You can display an overscan on your Fire TV through the Developer Options. See System X-Ray.ColorTelevision screens have a higher contrast than computer screens, which can make colors seem more saturated, brighter, and vibrant. The color gamut (the range of colors that can be displayed) is also less than that of a PC screen. In your app, use less saturated colors. Cool colors (blue, purple, gray) work better than warmer colors (red, orange).TypographyBecause television screens must be read from across the room, use larger type sizes for body text (at least 14sp, which is approximately 19px on 720p, 28px on 1080p). Amazon uses Helvetica Neue Regular as the system font.Keep item descriptions or other blocks of text as short as possible, both in content and in line width. Use greater line spacing than you would use on a desktop or tablet screen. Separate text into paragraphs or chunks and write in short, declarative sentences.Navigation and InputNavigation and user input on the Fire TV user interface are both accomplished with one of the Fire TV remotes (Amazon Fire TV Remote or Voice Remote), or with a game controller (either the Amazon Fire Game Controller, or other Bluetooth game controllers) The use of a physical controller instead of mouse, keyboard or touch input makes input and control methods for Fire TV apps less flexible than on other devices.D-Pad Directional NavigationThe Left, Right, Up, and Down D-Pad buttons on one of the Fire TV remotes or on a game controller are used to navigate the user interface of your app. Clearly indicate how users should move through your app’s user interface. A clear up-down and left-right orientation should be immediately apparent to the user and every actionable on-screen element should be reachable with the D-Pad.Focus and SelectionAs the user navigates the user interface with the directional buttons on a remote or game controller, different UI elements highlight to indicate that an element has the focus. Your app should clearly indicate which on-screen element currently has the focus. When users glance away from the TV, upon return their gaze it should remain clear what options they have for navigation.When the user presses Select (or the A button on a game controller) while a UI element has the focus, that element should momentarily change to the selected state.Text EntryWhen the user navigates the focus to a text field, a system keyboard automatically appears. Users can then enter information by selecting letters and numbers with the directional buttons on the remote or game controller. Suggested completions appear and can be selected at any time.Screens, Views, and FlowsThis section describes the patterns for the major screens and views in the Amazon Fire TV user interface, as well as descriptions of the controls used to build them. Use these patterns as a reference if you choose to optimize and integrate the design of your own apps with the system UI.Home Screen (Launcher)The home screen consists of a global navigation menu on the left and a set of content tiles on the right.The global navigation menu is the primary system menu. It appears in a row on the left side of the screen. The global navigation menu allows the user to choose major content categories or other options including Search, Home, Movies, TV, Music, Games, Apps, and so on. Each item in the global navigation menu can be selected with the Up and Down directional buttons.When the user focuses on any item in the global navigation menu, the home view for that node appears on the right side of the screen. Each node has its own home view with its own content. The overall system home view, sometimes called the launcher, is accessible with the Home key on the Fire TV remote or game controller, or by selecting Home from the global navigation menu.Each home view contains multiple horizontal content rows. The title tile for the row indicates the type of content (for example, Most Popular, My Movies, Recommended for You). The remaining tiles show examples of that content. From these content rows, the user can:  Navigate between rows with the Up and Down directional buttons.  Move back to the navigation menu with the Left button.  Choose Select or Right to select a row and view a 1D list for that row.1D List Views1D list views appear when the user selects a content row from a home view. 1D lists contain a single row of items. The title bar indicates the title of the list (for example, Most Popular, My Movies, Recommended for You), and two numbers indicating the number of items in the list and the position of the item that has the focus.The item with the focus in a browse list displays the mini details for that item below the list. Mini details can include basic item information (title, date, rating) as well as options such as Add to Watchlist.From the 1D list, the user can:  Navigate between items with the Left and Right directional buttons. Navigating past the end of the list wraps the focus around to the first item.  Choose an item with the Select button, which shows the detail view for that item.Detail ViewThe Detail view appears when the user selects an item from a browse list. This image shows the Detail view for a movie. The Detail may be different for TV, music, or other content. The Detail view displays information and actions related to a piece of content or other item.The actions under the description provide possible actions for this item. The actions available vary depending on the user’s subscription status (for example, whether they are an Amazon Prime member) as well as content availability.The discovery menu on the left side of the screen provides additional related information about the item (for example, Cast, Trivia, or Reviews).SearchThe Search menu item on the home screen opens the search screen, from which users can access voice search or text search. Search is also accessible with the Microphone button on the Amazon Fire TV Voice Remote, and appears in an overlay on the current app or content.For text search, the user moves LEFT and RIGHT through the alphabet, pressing SELECT on each letter to type a search query. Possible results appear in a list below the query.Global search is provided system-wide and is not customizable for individual apps. Developers may implement their own in-app search, but it is not included in the global search function.Additional ResourcesFor more information on UX best practices when designing for the ten-foot experience, see Android TV.",
        "url": "design-and-user-experience-guidelines.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "device-and-platform-specifications-html": {
        "title": "Fire TV Device Specifications",
        "tags": "[]",
        "content": "This page lists the media, device, and platform specifications for all Amazon Fire TV devices as well as supported technologies.   Fire TV Stick (Gen. 2)    Fire TV (Gen. 2)    Fire TV Stick (Gen. 1)    Fire TV (Gen. 1)Media Specifications (Fire TV Stick, Generation 2)                                                Type         Codec         MIME type         Details                     Video        H.263        video/3gp        Hardware accelerated up to WVGA (800x400) @ 30fps, 6 Mbps, Profile 0 Level 70                  H.264        video/avc        Hardware accelerated up to 1080p @ 30fps or 720p @ 60fps, 20 Mbps, High Profile up to Level 4                  H.265 (HEVC)        video/mp4        Hardware accelerated up to 1080p @ 30fps, 25 Mbps, Main Profile Level 4.0, Color space 8-bit support                    MPEG-4         video/mp4v-es         Decodes at 30fps, 20 Mbps, Advanced Simple Profile Level 5               Audio      AAC-LC      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv1 (AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv2 (enhanced AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            AC3 (Dolby Digital)      audio/ac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            eAC3 (Dolby Digital Plus)      audio/eac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            FLAC      audio/flac      Up to 48kHz, 2 channels, 16-bit and 24-bit (no dither for 24 bit)            MIDI      N/A      MIDI (Type 0 and 1), DLS (Version 1 and 2), XMF, and Mobile XMF. Ringtone formats RTTTL/RTX, OTA, and iMelody            MP3      audio/mp3      Up to 48kHz, 2 channels in DSP (16-bit and 24-bit) and software (16-bit)            PCM/Wave      N/A      Up to 96kHz, 6 channels, 16-bit and 24-bit            Vorbis      audio/vorbis      Ogg (.ogg)Matroska (.mkv)            AMR-NB   audio/amr-web              AMR-WB    audio/3gpp                    DRM        Widevine Level 1  PlayReady version 2.5 only        PlayReady supports only encrypted video, not audio. If you need to play content with both encrypted audio and video, contact us for specific customization details and steps. Other DRM details depend on the media player you choose to implement.                  Image        JPEG        N/A        Base and progressive                  GIF        N/A                          PNG        N/A                          BMP        N/A             Device and Platform Specifications (Fire TV Stick, Generation 2)                              Device Element      Details                    Screen resolution (px) and Refresh rate (Hz)      1920 x 1080 (1080p) - 60Hz        1280 x 720 (720p) - 60Hz             HDCP     1.4             Density (dp)      320 (1080p)  213 (720p)              Density Identifier      xhdpi (1080p)  tvdpi (720p)              Storage      8 GB internal              RAM      1GB              System on Chip (SoC) Platform      Mediatek 8127D              CPU      Quad-core ARM 1.3 GHz. 32-bit.              GPU      Mali-450 MP4              Networking: WiFi      Dual-band, dual-antenna Wi-Fi supports 2x2 MIMO 802.11a/b/g/n/ac              Networking: Ethernet      No              Bluetooth      Bluetooth 4.1. Supported profiles: A2DP, AVRCP, GAVDP, HID, IOPT.               USB      Micro USB 2.0 (Power only)              Expandable Storage      No  (See Specifying Your App’s Installation Location for best practices on manifest settings related to storage.)              Device OS/Platform software      Based on Android 5.0 - API 22              Location services      No              Front-facing camera      No              Microphone      No              Multi-touch      No              Accelerometer      No              Compass      No              Gyroscope      No              Light sensor      No              Proximity sensor      No              android.os.Build.MANUFACTURER      Amazon See Identifying Amazon Fire TV Devices for more details.              android.os.Build.MODEL      AFTT (Fire TV Stick Gen 2 only)  AFT* (all Fire TV devices)      OpenGL Properties and Limits (Fire TV Stick, Generation 2)                                    Property         Details                           OpenGL Version         OpenGL ES 2.0                     GPU         Mali-450 MP4                     MAX_TEXTURE_SIZE         4096                     MAX_CUBE_MAP_TEXTURE_SIZE         4096                     MAX_RENDERBUFFER_SIZE         4096                     MAX_VERTEX_TEXTURE_IMAGE_UNITS         0                     MAX_TEXTURE_IMAGE_UNITS         8                     MAX_COMBINED_TEXTURE_IMAGE_UNITS         8                     MAX_VERTEX_UNIFORM_VECTORS         256                     MAX_FRAGMENT_UNIFORM_VECTORS         256                     MAX_VERTEX_ATTRIBS         16                     MAX_VARYING_VECTORS         12                     MAX_VIEWPORT_DIMS         4096 x 4096           Media Specifications (Fire TV, Generation 2)                                                Type         Codec         MIME type         Details                    Video        H.263        video/3gp        Hardware accelerated up to WVGA (800x400) @ 30fps, 6 Mbps, Profile 0 Level 70                  H.264        video/avc        Hardware accelerated up to 1080p @ 30fps or 720p @ 60fps, 20 Mbps, High Profile up to Level 4                  H.265 (HEVC)        video/mp4        Hardware accelerated up to 3840x2160p (4K) @ 30fps, 25 Mbps, Main 10 Profile Level 5.0, Color space 8-bit and 10-bit input but just 8-bit output                  VP8        video/webm        Hardware accelerated, Profile 0               VP9        video/webm        Hardware accelerated up to Youtube 4K, Profile 0                 MPEG-4         video/mp4v-es         Up to 1080p @ 30fps, 20 Mbps, Advanced Simple Profile Level 5               Audio      AAC-LC      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv1 (AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv2 (enhanced AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            AC3 (Dolby Digital)      audio/ac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            eAC3 (Dolby Digital Plus)      audio/eac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            FLAC      audio/flac      Up to 48kHz, 2 channels, 16-bit and 24-bit (no dither for 24 bit)            MIDI      N/A      MIDI (Type 0 and 1), DLS (Version 1 and 2), XMF, and Mobile XMF. Ringtone formats RTTTL/RTX, OTA, and iMelody            MP3      audio/mp3      Up to 48kHz, 2 channels in DSP (16-bit and 24-bit) and software (16-bit)            PCM/Wave      N/A      Up to 96kHz, 6 channels, 16-bit and 24-bit            Vorbis      audio/vorbis      Ogg (.ogg)Matroska (.mkv)               AMR-NB      audio/amr-web                          AMR-WB       audio/3gpp                            DRM           Widevine Level 1  PlayReady version 2.5 only           PlayReady supports only encrypted video, not audio. If you need to play content with both encrypted audio and video, contact us for specific customization details and steps. Other DRM details depend on the media player you choose to implement.              Image      JPEG      N/A      Base and progressive            GIF      N/A                  PNG      N/A                  BMP      N/A               Device and Platform Specifications (Fire TV, Generation 2)                              Device Element      Details                  Screen resolution (px) and Refresh rate (Hz)      3840 x 2160 (2160p / 4K) - 30Hz        1920 x 1080 (1080p) - 60Hz        1280 x 720 (720p) - 60Hz             HDCP     2.2             Density (dp)      640 (2160p)  320 (1080p)  213 (720p)              Density Identifier      xxxhdpi (2160p)  xhdpi (1080p)  tvdpi (720p)              Storage      8GB              RAM      2GB              System on Chip (SoC) Platform      MediaTek 8173C              CPU      Quad Core (dual core ARM Cortex A72 up to 2 GHz, dual core ARM Cortex A53 up to 1.573 Ghz). 64-bit.              GPU      PowerVR Rogue GX6250              Networking: WiFi      802.11 a/b/g/n/ac; 2x2 MIMO  (2.4 GHz and 5.0 GHz dual band)              Networking: Ethernet      10/100Mbs              Bluetooth      Bluetooth 4.1, BTLE  HID, HFP, SPP Profiles              USB      USB 2.0 Type A (Accessories and media storage)              Expandable Storage      MicroSD up to 128GB  (See Specifying Your App’s Installation Location for best practices on manifest settings related to storage.)              Device OS/Platform software      Based on Android 5.0 - API 22              Location services      No              Front-facing camera      No              Microphone      No              Multi-touch      No              Accelerometer      No              Compass      No              Gyroscope      No              Light sensor      No              Proximity sensor      No              android.os.Build.MANUFACTURER      Amazon. See Identifying Amazon Fire TV Devices for more details.              android.os.Build.MODEL      AFTS (Fire TV Gen 2 only)  AFT* (all Fire TV devices)      OpenGL Properties and Limits (Fire TV, Generation 2)                              Item      Details                  OpenGL Version      OpenGL ES 3.0              MAX_TEXTURE_SIZE      8192              MAX_CUBE_MAP_TEXTURE_SIZE      8192              MAX_RENDERBUFFER_SIZE      8192              MAX_VERTEX_TEXTURE_IMAGE_UNITS      16              MAX_TEXTURE_IMAGE_UNITS      16              MAX_COMBINED_TEXTURE_IMAGE_UNITS      48              MAX_VERTEX_UNIFORM_VECTORS      256              MAX_FRAGMENT_UNIFORM_VECTORS      224              MAX_VERTEX_ATTRIBS      16              MAX_VARYING_VECTORS      15              MAX_VIEWPORT_DIMS      8192 x 8192      Media Specifications (Fire TV Stick, Generation 1)                                                Type         Codec         MIME type         Details                      Video         H.263         video/3gp         Hardware accelerated up to WVGA (800x400) @ 30fps, 6 Mbps, Profile 0 Level 70                     H.264         video/avc         Hardware accelerated up to 1080p @ 30fps or 720p @ 60fps, 20 Mbps, High Profile up to Level 4                       MPEG-4          video/mp4v-es          Up to 1080p @ 30fps, 20 Mbps, Advanced Simple Profile Level 5              Audio      AAC-LC      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv1 (AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv2 (enhanced AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            AC3 (Dolby Digital)      audio/ac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            eAC3 (Dolby Digital Plus)      audio/eac3, audio/ec3      Up to 48kHz, 6 channels, 16-bit and 24-bit            FLAC      audio/flac      Up to 48kHz, 2 channels, 16-bit and 24-bit (no dither for 24 bit)            MIDI      N/A      MIDI (Type 0 and 1), DLS (Version 1 and 2), XMF, and Mobile XMF. Ringtone formats RTTTL/RTX, OTA, and iMelody            MP3      audio/mp3      Up to 48kHz, 2 channels in DSP (16-bit and 24-bit) and software (16-bit)            PCM/Wave      N/A      Up to 96kHz, 6 channels, 16-bit and 24-bit            Vorbis      audio/vorbis      Ogg (.ogg)Matroska (.mkv)           AMR-NB    audio/amr-web                  AMR-WB     audio/3gpp                     DRM       Widevine Level 3  PlayReady version 2.5 only       PlayReady supports only encrypted video, not audio. If you need to play content with both encrypted audio and video, contact us for specific customization details and steps. Other DRM details depend on the media player you choose to implement.          Image      JPEG      N/A      Base and progressive            GIF      N/A                  PNG      N/A                  BMP      N/A              Device and Platform Specifications (Fire TV Stick, Generation 1)                              Device Elements      Details                  Screen resolution (px) and Refresh rate (Hz)      1920 x 1080 (1080p) - 60Hz        1280 x 720 (720p) - 60Hz                  HDCP       1.4               Density (dp)      320 (1080p)  213 (720p)              Density Identifier      xhdpi (1080p)  tvdpi (720p)              Storage      8GB              RAM      1GB (512MB system, 512MB video)              System on Chip (SoC) Platform      Broadcom Capri 28155              CPU      Dual Core ARM Cortex A9 up to 1 GHz. 32-bit.              GPU      Broadcom VideoCore IV GPU/VPU (Capri VC4)              Networking: WiFi      802.11 b/g/n; 2x2 MIMO  (2.4 GHz and 5.0 GHz dual band)              Networking: Ethernet      No              Bluetooth      Bluetooth 3.0  HID, SPP Profiles              USB      Micro USB 2.0 (Power only)              Expandable Storage      No  (See Specifying Your App’s Installation Location for best practices on manifest settings related to storage.)              Device OS/Platform software      Based on Android 5.0 - API 22              Location services      No              Front-facing camera      No              Microphone      No              Multi-touch      No              Accelerometer      No              Compass      No              Gyroscope      No              Light sensor      No              Proximity sensor      No              android.os.Build.MANUFACTURER      Amazon See Identifying Amazon Fire TV Devices for more details.              android.os.Build.MODEL      AFTM (Fire TV Stick Gen 1 only)  AFT* (all Fire TV devices)      OpenGL Properties and Limits (Fire TV Stick, Generation 1)                              Property      Details                  OpenGL Version      OpenGL ES 2.0              MAX_TEXTURE_SIZE      2048              MAX_CUBE_MAP_TEXTURE_SIZE      2048              MAX_RENDERBUFFER_SIZE      2048              MAX_VERTEX_TEXTURE_IMAGE_UNITS      8              MAX_TEXTURE_IMAGE_UNITS      8              MAX_COMBINED_TEXTURE_IMAGE_UNITS      8              MAX_VERTEX_UNIFORM_VECTORS      300              MAX_FRAGMENT_UNIFORM_VECTORS      300              MAX_VERTEX_ATTRIBS      8              MAX_VARYING_VECTORS      8              MAX_VIEWPORT_DIMS      2048 x 2048      Media Specifications (Fire TV, Generation 1)                                                Type         Codec         MIME type         Details                     Video        H.263        video/3gp        Hardware accelerated up to WVGA (800x400) @ 30fps, 6 Mbps, Profile 0 Level 70                  H.264        video/avc        Hardware accelerated up to 1080p @ 30fps or 720p @ 60fps, 20 Mbps, High Profile up to Level 4                    MPEG-4         video/mp4v-es         Up to 1080p @ 30fps, 20 Mbps, Advanced Simple Profile Level 5               Audio      AAC-LC      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv1 (AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            HE-AACv2 (enhanced AAC+)      audio/mp4a-latm      Up to 96kHz, 6 channels, 16-bit and 24-bit            AC3 (Dolby Digital)      audio/ac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            eAC3 (Dolby Digital Plus)      audio/eac3      Up to 48kHz, 6 channels, 16-bit and 24-bit            FLAC      audio/flac      Up to 48kHz, 2 channels, 16-bit and 24-bit (no dither for 24 bit)            MIDI      N/A      MIDI (Type 0 and 1), DLS (Version 1 and 2), XMF, and Mobile XMF. Ringtone formats RTTTL/RTX, OTA, and iMelody            MP3      audio/mp3      Up to 48kHz, 2 channels in DSP (16-bit and 24-bit) and software (16-bit)            PCM/Wave      N/A      Up to 96kHz, 6 channels, 16-bit and 24-bit            Vorbis      audio/vorbis      Ogg (.ogg)Matroska (.mkv)           AMR-NB    audio/amr-web                  AMR-WB     audio/3gpp                            DRM         Widevine Level 3  PlayReady version 2.5 only         PlayReady supports only encrypted video, not audio. If you need to play content with both encrypted audio and video, contact us for specific customization details and steps. Other DRM details depend on the media player you choose to implement.                    Image      JPEG      N/A      Base and progressive            GIF      N/A                  PNG      N/A                  BMP      N/A              Device and Platform Specifications (Fire TV, Generation 1)                              Device Element      Details                  Screen resolution (px) and Refresh rate (Hz)      1920 x 1080 (1080p) - 60Hz        1280 x 720 (720p) - 60Hz                 HDCP       1.4             Density (dp)      320 (1080p)  213 (720p)            Density Identifier      xhdpi (1080p)  tvdpi (720p)            Storage      8GB              RAM      2GB              System on Chip (SoC) Platform      Qualcomm Snapdragon 8064              CPU      Quad Core Qualcomm Krait 300 up to 1.7 GHz. 32-bit.              GPU      Qualcomm Adreno 320              Networking: WiFi      802.11 b/g/n; 2x2 MIMO  (2.4 GHz &amp; 5.0 GHz dual band)              Networking: Ethernet      10/100Mbs              Bluetooth      Bluetooth 4.0  HID, SPP Profiles              USB      USB 2.0 Type A (Accessories and storage)              Expandable Storage      USB up to 128GB (See Specifying Your App’s Installation Location for best practices on manifest settings related to storage.)              Device OS/Platform software      Based on Android 5.0 - API 22              Location services      No              Front-facing camera      No              Microphone      No              Multi-touch      No              Accelerometer      No              Compass      No              Gyroscope      No              Light sensor      No              Proximity sensor      No              android.os.Build.MANUFACTURER      Amazon  See Identifying Amazon Fire TV Devices for more details.              android.os.Build.MODEL      AFTB (Fire TV Gen 1 only)  AFT* (all Fire TV devices)      OpenGL Properties and Limits (Fire TV, Generation 1)                              Property      Details                  OpenGL Version      OpenGL ES 3.0              MAX_TEXTURE_SIZE      4096              MAX_CUBE_MAP_TEXTURE_SIZE      4096              MAX_RENDERBUFFER_SIZE      4096              MAX_VERTEX_TEXTURE_IMAGE_UNITS      16              MAX_TEXTURE_IMAGE_UNITS      16              MAX_COMBINED_TEXTURE_IMAGE_UNITS      32              MAX_VERTEX_UNIFORM_VECTORS      256              MAX_FRAGMENT_UNIFORM_VECTORS      224              MAX_VERTEX_ATTRIBS      16              MAX_VARYING_VECTORS      16              MAX_VIEWPORT_DIMS      4096 x 4096      All Fire TV DevicesRemotes and Game Controllers                              Controller      Input Device Name                  Amazon Fire TV Remote  Amazon Fire TV Voice Remote (all models)      \"Amazon Fire TV Remote\"              Amazon Fire TV Game Controller  Amazon Fire Game Controller      \"Amazon Fire Game Controller\"      Technology Support for Fire TVSupported technologies are the same for all Amazon Fire TV devices.                              Technology      Notes                  Miracast      Supported (sink)              DIAL      Supported. Apps for Fire TV require changes to your app’s Android manifest to be discoverable. See DIAL integration.              Web Browsing/external links      No web browser is available. Use Android WebView.              Amazon In-App Purchasing      Supported. Use the latest version of the App Tester.              Amazon Mobile Associates      Not supported              Amazon GameCircle      Supported. Use version 2.1 or higher              Login with Amazon      Supported              Amazon Maps      Not supported              Amazon Device Messaging      Supported for push messages              Amazon Mobile Ads      Not supported      Device Release Dates                              Device      Release Date                  Fire TV Stick (Generation 2)       September 2016               Fire TV (Generation 2)       December 2015              Fire TV Stick (Generation 1)        November 2014               Fire TV (Generation 1)      April 2014       ",
        "url": "device-and-platform-specifications.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-development-framework-comparison-html": {
        "title": "Amazon Fire TV Development Framework Comparison",
        "tags": "[]",
        "content": "If you’re planning to build a media-based app for Amazon Fire TV, Amazon provides two frameworks that can help accelerate the development of your app. Each framework is oriented toward developers with particular skill sets:  Web App Starter Kit for Fire TV: Intended for web developers building web apps using HTML5, CSS3, and JavaScript.  Fire App Builder: Intended for Android developers building native apps using Java.In addition to using different types of code, the two frameworks have somewhat different features. See the Feature Comparison for more details.  Web App Starter Kit for Fire TV  Fire App Builder  Feature Comparison  Transitioning from Web Apps to Android AppsWeb App Starter Kit for Fire TVThe Web App Starter Kit for Fire TV (available on Github here) is a starting point for creating media-oriented apps for Fire TV using HTML5, CSS3, and JavaScript. The web apps can then be packaged using the Amazon Developer Portal to create Fire TV apps that are available in the Amazon Appstore, indistinguishable from native apps.With WASK, you start with a base app template that contains specific media functionality (for example, support for Media RSS or JSON feeds, or support for online video providers such as YouTube or Brightcove). You then customize this template by changing settings files or adding extended functionality using standard web technologies — JavaScript, HTML5, and CSS3.Baked into the WASK template is the code needed to provide the large-screen experience consumers expect, as well everything needed to pass Amazon Appstore testing during the app submission process. At the bare minimum, you only need to provide a feed of media files, which the app will use to display a selectable list of categories and a rotating carousel of media content.Here’s a screenshot of a simple layout:While customizing or extending the basic WASK template, you can test your app using the Amazon Web App Tester. This is a Fire TV app used to test web apps on an actual device. The Web App Tester uses the same native app wrapper and web engine that will be used when the app is published, giving you an accurate preview of your app during development.When your app is ready, you can use the Amazon Developer Portal to submit your app to the Amazon Appstore and have it published within minutes, with no native coding needed.After signing up online, filling in the basic app details, and uploading thumbnail and preview images, you have a choice about where to host your app. You can either host the app’s asset files on your own web server and submit just the URL, or you can upload the assets to Amazon’s servers, where it will be bundled into a standalone packaged app.After you have submitted your app, it will go through an Amazon ingestion service, and you will be notified when your app is published.To learn more, see The Web App Starter Kit for Fire TV. Some examples of Fire TV apps built using WASK include Acorn TV, Urban Movie Channel, and Euronews.Fire App BuilderFire App Builder (available on Github here) provides a Java-based framework that you can use to easily and quickly build streaming media Android apps for Amazon Fire TV. In contrast to the HTML5/CSS3/JS used with WASK, Fire App Builder uses Java Android code.With Fire App Builder, you work in Android Studio, connect to your Fire TV device through Android Debug Bridge (ADB), and generate an APK (Android Package Kit) file to upload to the Amazon Appstore.Although Fire App Builder uses Android APIs (particularly the Leanback Library), you do much of the configuration and customization through JSON and XML files. For example, through JSON and XML files, you can configure more than a dozen components to add to your app. Components provide out-of-the-box functionality for analytics, ads, authorization, purchasing, and media players.Fire App Builder minimizes a dependence on Java expertise as much as possible, but for more deep-level integration, you can build on top of Fire App Builder. You can add your own custom Java classes to extend functionality through common interfaces and other code. (If you don’t care to do any custom Java programming, though, you don’t have to.)With Fire App Builder, your media feed can be JSON or XML, in any structure using any tag names. When you configure Fire App Builder, you’ll write query syntax (using JSON Jayway syntax or XPath expressions) to target the various elements of your feed.Your feed can also require tokens for media protected by DRM. Support for YouTube-based feeds and other video hosting services is on the roadmap but not currently included.You have a lot of control to adjust the colors, layout, typography, and more — all by editing XML or JSON files where these settings have been extracted.Here’s a screenshot of a sample app built using Fire App Builder:A more compressed homepage layout is also available.To learn more, see the Fire App Builder documentation. For a sample app built with Fire App Builder, see the Hallmark app.Feature ComparisonThe following table compares Fire App Builder and WASK features. Note: If a framework doesn’t have a feature, it doesn’t mean the framework won’t support it. It just means the feature isn’t already integrated in the code. Usually you can easily insert the third-party code needed to support these services.CategoryFeatureFire App BuilderWASK  Code Base  Java/Android      HTML5/CSS3/JS      Feed Formats  JSON feeds      Media RSS XML Feeds      Custom XML Feeds      App Delivery Options  Installed as APK on device      Hosted app directly from URL      Media Types  HLS, DASH, Smooth Streaming, MP4      DRM-protected media      Live streams      Media Providers  YouTube      Brightcove      Kaltura      Ooyala      Media Players  Amazon Media Player      Brightcove      Purchasing  In-App Purchasing      Authentication  Login with Amazon      Facebook Authorization      Adobe Primetime      Ad Services  Freewheel Ads      VAST Ads      Analytics  Omniture Analytics      Google Analytics      Crashlytics      Flurry Analytics      Global Catalog Search  Integration into the Fire TV catalog for global voice search.    Again, you can add the services and features you want into either framework. The code is open (and open source), and you’re free to enhance, extend, or otherwise build on top of the framework’s code.Transitioning from Web Apps to Android AppsSome companies prefer to start out with a web app (with WASK) and later transition to a Java Android app (such as with Fire App Builder). Note that when you submit an app to the Appstore, you select the app type (whether web app or Android app).Once you submit an app, you can’t transition from one app type to another. If you started out with a web app and wanted to upload a new version that was an Android app, you couldn’t do this. You would need to upload a separate app entirely, which would mean losing any existing users.If you’re planning to make this transition from web app to Android app, consider using Cordova with your web app. Cordova allows you to wrap your web app as an APK and submit the web app as an Android app. If you later decide to go entirely native with an Android app, you can publish a new version of your Android app in the Appstore.",
        "url": "fire-tv-development-framework-comparison.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-fire-os-overview-html": {
        "title": "What Is Fire OS?",
        "tags": "[]",
        "content": "Fire OS is the operating system that runs Amazon’s Fire TV, tablets, and other devices. Fire OS is a fork of Android 5.1 (Lollipop, API level 22), so if you have an Android app, it will most likely run on Amazon’s Fire devices.As a developer, you might not have to adjust your Android code at all to publish your app on Amazon’s platform. You can test your app here and see if it everything simply works.  Differences in Services  Devices and Fire OS VersionsDifferences in ServicesThe way Fire OS differs from Android is in the services. Instead of using Google’s services (for activities such as browsing, location, messaging, payments, and so on), Fire OS uses Amazon’s services. Most notably, Amazon uses the Amazon Appstore to list your app while Google uses Google Play.If your Android app connects into Google’s ecosystem of services, porting your Android app to the Fire OS platform will require you to tap into Amazon’s ecosystem of services instead. Additionally, Fire OS supports only Android Lollipop (API Level 22).When you’re building your app, follow the standard Android documentation. Where there are differences to account for with Amazon’s Fire OS platform, they’re noted in the documentation on this site.The goal is to provide as much parity as possible with Android (minus Google’s services) so that you don’t have to learn another development platform or make changes to your existing Android app.Devices and Fire OS VersionsMost Fire devices receive over-the-air updates to get the latest version of Fire OS automatically. Not every Fire device receives a push of the same Fire OS version at the same time. Sometimes the updates roll out to different devices at different times. But for the most part, Fire devices largely run the same version. Tip: For details on the differences between Android TV development and Fire TV development, see Fire TV Development versus Android TV Development.",
        "url": "fire-tv-fire-os-overview.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "getting-started-developing-apps-and-games-for-amazon-fire-tv-html": {
        "title": "Getting Started Developing Apps for Amazon Fire TV",
        "tags": "[]",
        "content": "To get started building apps for Fire TV, first decide whether you want to build an Android app or web app:  Android App: If you’re an Android Java developer, you can use existing tools (like Android Studio) and frameworks (including Unity) to develop apps and games for the 10-foot experience. Sample code, documentation, and guidelines are available to help you make the most of your apps. If you’re building a streaming media app, you can use Fire App Builder — a Java-based Android starter kit — to get up and running quickly.  Web App: If you’re an HTML5 web developer, you can leverage the Amazon WebView to develop apps and games. You have the option to build HTML5 web apps, Cordova apps using the Fire OS port, or hybrid apps. If you’re building a streaming media app, you can use the Web App Starter Kit for Fire TV to get up and running quickly. Tip: For an in-depth comparison between Web App Starter Kit for Fire TV (WASK) and Fire App Builder, see Fire TV Development Framework Comparison.Additionally, consider your skill set. Are you Java-based Android developer, or an HTML5/web developer? Choose an approach that aligns with your expertise and app requirements.  Android App Development for Fire TV  HTML5 Web App Development for Fire TV  APIs for Your Fire TV App  Device and Media Specifications  About the Fire TV Documentation  Fire TV ForumsAndroid App Development for Fire TVFor Java-based Android developers, Fire TV uses the same tools, IDEs, and APIs you’re already used to for Android development. To get started, see Fire App Builder, which is a starter kit for building Java-based Amazon Fire TV and Android apps. Fire App Builder is designed for streaming media TV apps (not games).If you’re building your own app from scratch, see these topics:  Setting Up Your Development Environment: If you’re new to Android development, this page helps you get started.  Connecting to Fire TV Through ADB: Connect your development computer to a Fire TV device over ADB, either via the network or a USB cable.  Installing and Running Your App: Install, run, and uninstall your app on a Fire TV device for testing before you submit it to the Appstore.If you’re an experienced Android developer, also check out this list of what’s different about developing on Fire OS.HTML5 Web App Development for Fire TVIf you’re an HTML5 web app developer building a streaming media app, you can use the Web App Starter Kit for Fire TV (WASK). WASK is an open source project designed to get you up to speed quickly with a simple media-oriented app for Fire TV. This starter kit includes an example user interface designed for the 10-foot experience, support for the Fire TV remote control, and sample components that you can use to create and customize your own media app.If you’re building your HTML5 web app from scratch, see Getting Started with Web Apps for Fire TV.APIs for Your Fire TV AppWhen you build your Fire TV app, you can also implement other Amazon APIs to provide a more robust experience:  In-App Purchasing API: When customers buy Fire TV devices and register with their Amazon accounts, they are already set up with their Amazon payment profiles and are ready to purchase apps or in-app items with no further effort. Amazon Fire TV and Fire TV Stick support the Amazon In-App Purchasing API, so you can offer consumable items, permanently entitled items, and even subscriptions for sale in your app.  Amazon Fling SDK: The Amazon Fling SDK allows customers to fling or cast the screen that appears on their phone or tablet directly onto their television. Extending apps to two screens allows more than one person to engage with your app.To see more Fire TV APIs and SDKs, see Apps &amp; Games Services SDKs.Device and Media SpecificationsIf you’re looking for information about the media, device, and specifications Fire TV supports, such as video formats, DRM, codecs, resolution rates, and more, see Fire TV Device Specifications.About the Fire TV DocumentationThe Fire TV documentation is organized into the following groups:  Getting Started  Fire App Builder  Catalog Integration  Fling SDKFire TV ForumsIf you need help, have a question, or want to share other feedback, use the Fire TV and Fire TV Stick categories on the Amazon Developer Forum.",
        "url": "getting-started-developing-apps-and-games-for-amazon-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "submitting-your-fire-tv-app-to-the-amazon-appstore-html": {
        "title": "Submitting Your Fire TV App to the Amazon Appstore",
        "tags": "[]",
        "content": "After you’ve developed and tested your app, use these resources to prepare your app for submission to the Amazon Appstore.  Understanding Amazon Appstore Submission: Find general information on the submission process here.  Test Criteria for Amazon Appstore Apps: When you submit your app or game to the Amazon Appstore, the app must pass tests before it can be published. Use the test criteria on this page as a guide for your own quality assurance testing.      Pre-Submission Assessment Guide for Fire TV Apps: When you submit your app or game for the Fire TV platform to the Amazon Appstore, the app must pass tests before it can be published. As you develop your app, use the test criteria in this document as a guide for your own quality assurance testing.    Image Guidelines for Amazon Appstore Submission: Your app submission includes icons and screen shots. This page describes the guidelines for those media assets.  Getting Started with Device Targeting: If you’ve developed your app for multiple platforms or devices (for example, for Kindle Fire tablets and for Amazon Fire TV devices), device targeting enables you to submit that app once and provide multiple binary APKs. This page describes how to manage device targeting for your app submission, or to add a Fire TV APK to your existing tablet app.",
        "url": "submitting-your-fire-tv-app-to-the-amazon-appstore.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "whats-new-in-the-fire-tv-sdk-html": {
        "title": "What's New in Fire TV Development",
        "tags": "[]",
        "content": "  Fire TV User Interface Update  Fire App Builder  Fire TV Stick (Generation 2)  Fire TV Documentation Updates  Fire TV Blog UpdatesFire TV User Interface UpdateFire TV Gen 2 devices received an update to the interface. The update provides a more cinematic experience thatoffers video trailers and content screenshots to help customers access the content they want more quickly. Third-party apps are also more visible on the homepage in recommended rows. Accessibility improvements were included that allow customers to use Fire TV and any compatible apps with the VoiceView screen reader. (See the original announcement.)To upload the new Fire TV assets required for the new UI, see the instruction in Image Asset Guidelines for Appstore Submission. The user interface update will be applied to generation 1 devices in a later phase.Fire App BuilderFire App Builder was released on September 29, 2016. Fire App Builder provides a Java-based framework that you can use to easily and quickly build streaming media Android apps for Amazon Fire TV. Fire App Builder lets you build an engaging, high-quality media experience on Fire TV following best practices and techniques — without having to develop all the code yourself. Fire App Builder’s code is Java-based and uses Android Studio, Gradle, and other tools common to Android app development. Fire App Builder is released as an open source project on Github (github.com/amzn/fire-app-builder) under the Apache 2.0 license.Fire TV Stick (Generation 2)Fire TV Stick with Alexa Voice Remote, referred to as Fire TV Stick (Generation 2) in the documentation, was released on September 28, 2016. This next-generation Fire TV Stick is 30 percent faster than the original best-selling version, offers access to more than 300,000 movies and TV episodes, and includes the Alexa Voice Remote—for only $39.99. Now sporting a quad-core processor, it has the horsepower to let your high-performance apps and games shine. Read more about it here: Introducing the All-New Fire TV Stick with Alexa Voice Remote. You can see the specs for Fire TV Stick (Generation 2) on Fire TV Device Specifications.Fire TV Documentation UpdatesThe following updates have been made to the Fire TV documentation:            Date      Page      Details                  Jan 20, 2016      System X-Ray Overview, Developer Tool Options, Customize System X-Ray      Updated details about System X-Ray and the Developer Tools Options menu.              Dec. 14, 2016      Amazon Fire TV Development Framework Comparison      Detailed comparison between Web App Starter Kit for Fire TV (WASK) and Fire App Builder.              Nov 29, 2016      Notifications for Amazon Fire TV      Updated to explain upcoming the Notification Center functionality that will be included in the Fire TV UI refresh release.              Nov 23, 2016      Specifying Your App’s Installation Location      Update with emphasis on preferring external storage on app install. Also includes details for app installs across platforms.              Oct 25, 2016      Image Asset Guidelines for Appstore Submission      Updated graphics and instruction for the Fire TV Assets section. Instead of generic diagrams, the graphics include real samples with more gradations shown in the content safe areas.              Oct 20, 2016      Getting Started Developing Apps and Games for Amazon Fire TV      New sidebar navigation on the right with expandable/collapsible sections              Oct 2, 2016      Fire App Builder: A Starter Kit for Java-based Amazon Fire TV and Android Apps      Extensive documentation (more than 30 pages) about how to use Fire App Builder to create Java-based Android TV apps for Fire TV.              Sep 29, 2016      Identifying Fire TV Devices      Contains feature identifiers for Fire TV Stick (Generation 2)              Sep 28, 2016      Image Asset Guidelines for Appstore Submission      Contains image asset guidelines for the Fire TV Assets section of the Images &amp; Multimedia tab used during app submission.              Sep 28, 2016      Fire TV Device Specifications      Includes specifications for Fire TV Stick (Generation 2). Also contains content from Media Specifications on the same page (for consolidated and centralized information). Information is organized through navtabs.              Sep 28, 2016      Image Asset Guidelines for App Submission      New section that explains Fire TV image assets for upcoming Fire TV UI refresh.              Sep 16, 2016      Android TV Development versus Fire TV Development      New page that explains what to account for when developing for Fire TV.              Sep 14, 2016      Getting Started Developing Apps and Games for Amazon Fire TV      Revision based on new site workflow              Sep 10, 2016      Using System X-Ray on Fire TV      New page that provides details for troubleshooting app issues through a System Xray overlay.              Sep 5, 2016      Getting the Advertising ID on Fire TV      New page that provides details for getting the advertising ID.              Sep 1, 2016      Playing 4K Ultra HD Videos on Fire TV.      New page with guidelines for developing 4K apps along with Extension support library for Fire TV.              Aug 30, 2016      Amazon Fire TV homepage      The homepage was migrated to the new version of the Developer Portal site (which is rolling out incrementally).              Aug 5, 2016      Identifying Amazon Fire TV Devices.      New methods for identifying Fire TV devices – look for the feature instead of the model + manufacturer.              July 23, 2016      Fire TV Device Specifications      Updated with H.265 details, Widevine support, and other details.              July 22, 2016      Dolby Integration Guidelines      New page that provides technical details for supporting Dolby audio.              July 1, 2016      Media Players      Updated info about supported media players, with an emphasis on the Amazon port of Exoplayer.              June 10, 2016      “Handling Audio Focus with Voice Interactions”      New section on how to handle audio focus when voice interactions start.              June 16, 2016      “Voice Search”      New section on how voice search versus text search works, and what returns for both searches.              June 1, 2016      Persistent sidebar navigation      Right sidebar appears throughout Fire TV docs to allow easier navigation within the Fire TV documentation.      Fire TV Blog UpdatesYou can follow the latest news about Fire TV by reading the Fire TV category on the blog.Read the Fire TV blog",
        "url": "whats-new-in-the-fire-tv-sdk.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-recommendations-best-practices-html": {
        "title": "Best Practices for Recommendations",
        "tags": "[]",
        "content": "The following are best practices for creating recommendations.  Understand the difference between recommendations and notifications  Personalize the notifications to the user  Delete stale cards  Don’t exceed the notifications limit  Limit the number of recommendations shown at one time  Sending recommendation as a background app  Handling back button events  Provide free, friendly content  Next stepsUnderstand the difference between recommendations and notificationsNote the difference between notifications and recommendations:  Recommendations try to guide users to guide users to content they might enjoy. The recommendations are based on prior the user’s history, new content available, or related content.  Notifications let users know about updates associated with your app. These updates might include new functionality, new levels, new release versions, changes in the app, or new badges earned.Personalize the notifications to the userRecommendations are most effective when you personalize them based on user profiles. The best recommendations look at your users’ interests, profile, and recent activity to come up with the recommendation. Personalizing recommendations leads to greater engagement and interest in your app.Delete stale cardsKeep your recommendations relevant by deleting old or stale cards. Additionally, avoid creating new instances of cards that are already stale.Track what content has been shown and visited before so you can delete it later. For example, if the user finishes watching the recommended content, delete it from the recommendation row.If you continue to send stale recommendations, users might turn off your recommendations or uninstall your app.Don’t exceed the notifications limitAndroid enforces a maximum limit of 50 notifications for each package. This limit includes both recommendations and other notifications your app sends.If you exceed 50 notifications, you may see errors such as the following:W/NotificationManager﹕ notify: id corrupted: sent 51, got back 0.Because of this limit, you should cancel older notifications before sending new notifications (if the number exceeds 50).Limit the number of recommendations shown at one timeAvoid sending too many recommendations at once. Consider batching recommendations together in smaller groups of 5 at a time.Sending recommendation as a background appSome apps choose to send recommendations as a background process. Note that the background processes can be killed if the system exceeds the available memory.Consider using trigger points to send recommendations instead. The trigger points could send recommendations using an AlarmManager at repeating intervals. The repeating intervals can be expired using an Android JobSchedule or Sync adapter task.Handling back button eventsWhen users press the Back button, your app should self-destroy and return to the recommendations row on the Fire TV home screen. (The return point should be where the application was launched when the user clicked a recommendation.)Provide free, friendly contentAs a best practice, consider sending free content to the recommendations row. After the user opens your app, then you can push more premium/paid content.Your app should not harass, hard sell, or recommend inappropriate content. Doing so will result in potential blacklisting of your app.Next stepsTo learn more, see the following:  Recommendations Overview  Test Your Recommendations  Send Recommendations that Include Amazon Extras",
        "url": "fire-tv-recommendations-best-practices.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-recommendations-overview-html": {
        "title": "Recommendations Overview",
        "tags": "[]",
        "content": " Note: Recommendations from 3rd-party apps is a feature in development. This functionality will roll out in a future release. You can prepare for the release by incorporating recommendations into your app now.You can send recommendations to users about the content (movies, shows, music, games) you want them to watch. Recommendations appear on a “Recommended By Your Apps” row on the Fire TV home screen.Recommendations encourage users to engage with your app. By appearing on the Fire TV home screen, recommendations are visible within the user’s regular view. The recommendation cards entice users back into your app with minimal effort.For more information about recommendations, see Recommending TV Content in the Android documentation. The Android TV Leanback Support Library app also contains sample code for sending recommendations.  Where Recommendations Appear  How the Recommendations Row Works  Recommendations Attributes  Requirements for Recommendations to Appear  What to Recommend  Send Recommendations  Amazon’s Extensions to Android Recommendations  Questions  Next stepsWhere Recommendations AppearOn the Fire TV home screen, the “Recommended By Your Apps” row shows all recommendations from apps the user has currently installed (and opened at least once).All recommendations from third-party apps appear as visually attractive cards in this row. You control the look and appearance of the recommendation cards.Recommendations are sorted by a selection algorithm provided by Fire TV. The row refreshes regularly.How the Recommendations Row WorksIf you select a recommendation and then click the Menu button on your remote, a launch menu appears in the lower-right corner. The menu shows different viewing options.The text shown in the launch menu — \"Watch\" — might differ across recommendations. Depending on the string set by the app, a recommendation can show any of the following strings:  Watch  Resume  Switch Profile  Change Settings  View  Play  Listen  OpenIf a user selects “Open TED TV” instead of “Watch,” the TED TV app will launch (instead of the selected content). Selecting this option is the same as launching an app the normal way on Fire TV.Additionally, you can control your app’s name in this launch menu by setting the value for DISPLAY_NAME, which is an Amazon extra in your recommendation.Recommendations AttributesThe following image shows the various attributes of the recommendations row.The attributes are as follows: Title of recommendation provided by the app  Name of the app that sent the recommendation  Description of the recommendation provided by the app  Image of the recommendation provided by the app  Operations available for the recommended media. (Press the Menu button on Fire TV remote to bring up this menu.) Requirements for Recommendations to AppearThe following two requirements must be met for recommendations to appear:  There must be at least 5 recommendations in total sent from all apps.  The user can’t have any viewing restrictions set under Settings &gt; Preferences &gt; Parental Controls.Note that Android limits the number of notifications to 50. This limit includes both standard notifications and recommendations combined.What to RecommendRecommendations should show content that is relevant to the user. For example, recommendations might present the following:  New episodes for shows the user watched earlier  Similar shows related to the user’s viewing history  Encouragement to resume watching a show the user didn’t finishYou will need to create the logic that determines which recommendations are shown to which users.Make sure the content you recommend is appropriate for the audience. See Best Practices for Recommendations for more details.Send RecommendationsYou can send recommendations by following the approach described in the Android documentation. See these Android topics:  Recommending TV Content  ContentRecommendationIn general, you build a service that looks at your app’s content and suggests recommendations. You send the recommendations as notification objects, tagged with a recommendation category and configured with the values you want. You also register the service with your app’s manifest.When you define the recommendations, you set the foreground and background image, color, app icon, title, subtitle, and more. See Recommendation Row in Google’s Android TV for more design and UX details with recommendations.You can group your recommendations using the NotificationCompat.Builder.setGroup() method.For more details on creating recommendations, see Send Recommendations that Include Amazon Extras.Amazon’s Extensions to Android RecommendationsAmazon extends the Android recommendations API to provide deeper integration with Fire TV. Note that using Amazon’s extras is optional. If you don’t use the extras, your recommendations will still work on Fire TV. However, you will lose out on some FireTV-specific features.The Amazon extensions won’t affect the display of your recommendations on other Android TV platforms.Questions  Can I view metrics to see clicks on recommendations from the Fire TV home screen?  You can add an extra to the pending intent. This will allow you to capture the origin of where the link was clicked.  Can users turn recommendations off?  No. Although users can turn notifications off for specific apps, they cannot turn recommendations off.For more background reading on recommendations, see Android TV Recommendations: What’s in it for my app or game? from NVIDIA.Next stepsTo learn more, see the following:  Test Your Recommendations  Send Recommendations that Include Amazon Extras  Best Practices for Recommendations",
        "url": "fire-tv-recommendations-overview.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-recommendations-send-recommendations-html": {
        "title": "Send Recommendations that Include Amazon Extras",
        "tags": "[]",
        "content": "You create recommendations by creating ContentRecommendation objects through the ContentRecommendation.Builder() class. In addition to the attributes in this class, you can also include Amazon-specific extras to better integrate with Fire TV.  Documentation for Creating Recommendations  Sample Recommendation  Code Example for a Recommendation  Recommended Attributes for Android API code  Amazon Enhancements to Recommendations  Configuring the Manifest  Delete Recommendations  Next stepsDocumentation for Creating RecommendationsAmazon’s recommendations use the standard Android ContentRecommendation.Builder API. For full details, see the Android documentation on Recommending TV Content and the ContentRecommendation.Builder class.In addition what’s included in the Android documentation, you can expand the recommendations functionality in your notification objects with Amazon-specific extras. These extras help integrate the recommendations into Fire TV in deeper ways.Sample RecommendationBefore diving into code examples, let’s look at a sample recommendation card. The numbers show several attributes set through the Android API and one Amazon extra. setTitle. Sets the title for the recommendation. (Android API) setText. Sets the description for the recommendation. (Android API) setContentImage. Sets the image used for the recommendation. (Android API) Sets an abbreviated name for your app, which is used in the launch menu. This is set by one of the Amazon extra fields: com.amazon.extra.DISPLAY_NAME\", \"displayName\".For example, if your app has a long name, such as “World Premier Association Videos,” this long title will be truncated in the launch menu. Instead of accepting the default truncation, you can specify the shortened name for your app through the Amazon extras (in this case, the DISPLAY_NAME).Code Example for a Recommendation Note: Before creating recommendations, you must add the Application Recommendation Support Library for TV to the dependencies block of your app’s build.gradle file.The following code shows how to create a ContentRecommendation object and getNotificationObject that includes Amazon extras:mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);//Sets an ID for the notification, so it can be updatedint notifyID = int_value;ContentRecommendation rec = new ContentRecommendation.Builder()        .setContentImage(myBitmap) // From API 23 this method also accepts Icon as argument.        .setBackgroundImageUri(myBackgroundImageUri)        .setContentIntentData(ContentRecommendation.INTENT_TYPE_***, mIntent, mRequestCode, mBundle)        .setText(mText)        .setTitle(mTitle)        .setBadgeIcon(R.drawable.&lt;app_icon&gt;)        .setGenres(mGenres)        .setContentTypes(mTypes)        .setProgress(mMaxLength,mProgress)        .setMaturityRating(mMaturityRating)//This is optional if com.amazon.extra.MATURITY_RATING is filled.        .build();Notification notification = rec.getNotificationObject(mContext);//The additional Amazon extra values get added as follows://Assign a business name for the application which may be shown on the UInotification.extras.putString(\"com.amazon.extra.DISPLAY_NAME\", mDisplayName);//Assign a Maturity rating to this recommendationnotification.extras.putString(\"com.amazon.extra.MATURITY_RATING\", mMaturityRating);//Specifies how recommendations from one app is ordered.notification.extras.putInt(\"com.amazon.extra.RANK\", mRank);//Assign a long description to this recommendationnotification.extras.putString(\"com.amazon.extra.LONG_DESCRIPTION\", mLongDescription);//Assign a last watched time to this recommendationnotification.extras.putLong(\"com.amazon.extra.LAST_WATCHED_DATETIME\", mLastWatchedTime);//Assign a preview video or image URL of this recommendationnotification.extras.putString(\"com.amazon.extra.PREVIEW_URL\", mPreviewUrl);mNotificationManager.notify(notifyID, notification); Tip: For more information on setContentIntentData(), see ContentRecommendation.The Amazon extras are added to the notification object. More information for using the Android recommendations API and Amazon extras are provided in the following sections.Recommended Attributes for Android API codeFollow these guidelines when using the ContentRecommendation.Builder from the Android API. These guidelines will help your recommendations align with the look and feel of Fire TV.                                          API         Description         Required                           setTitle(java.lang.String)         Sets the content title for the recommendation. The length limit is 125 characters. Additional text is truncated.         Yes                     setText(java.lang.String)         Sets the description text for the recommendation. The length limit is 125 characters. Additional text is truncated.         Yes                     setContentImage(Bitmap image)                     Use the following specifications for the large icon image:                           Height: 252px               Aspect ratio: 16:9                Title: Embedded within image               Transparency: No transparency                        Recommendations without images either won't be displayed or will receive a default placeholder instead. Recommendations with an aspect ratio other than 16:9 will be letterboxed. (Letterboxing means black bars will appear along the sides or top to compensate for the empty space.)                  Yes                     setContentIntentData(int intentType, Intent intent, int requestCode, Bundle options)                     Sets the data for the Intent that will be issued when the user clicks the recommendation. This pending intent deep links to the recommended content. When launched, the content plays.            The Intent data fields correspond to the fields passed into the PendingIntent factory methods. The actual PendingIntent object will  be created only at the time a recommendation is posted to the Fire TV Home screen.                  Yes                     setBadgeIcon(int iconResourceId)                     Sets the resource ID for the recommendation badging icon.            The resource id represents the icon resource in the source application package. If not set, or an invalid resource ID is specified, the application icon retrieved from its package will be used by default.                  Yes                        setGenres(String[] genres)          Sets the content genres for the recommendation. These genres may be used for content ranking. Genres are open ended String tags. Use the standard Android genres.         No                     setContentTypes(String[] types)          Sets the content types associated with the content recommendation. The first tag entry will be considered the content's priority type and will be used for ranking. Other secondary type tags may be provided, if applicable, and can be used for filtering. Only standard Android content recommendation categories are allowed.         No                     setProgress(int max, int progress)          Sets the progress information for the content pointed to by the recommendation. The progress amount for the content must be in the range (0 - max). The unit is seconds.         No                     setBackgroundImageUri(String imageUri)          Sets the Content URI that will be used to retrieve the background image for the recommendation. 1080P / 16:9 image is recommended.         Yes         Amazon Enhancements to RecommendationsThe following table lists extras that you can add to your notification objects.                                 Extra name         Data type         Details                           com.amazon.extra.DISPLAY_NAME         String         A shorter app name displayed in the Launch menu (#4 in the earlier screenshot with annotations). The length limit is 15 characters. Additional characters are truncated.                     com.amazon.extra.MATURITY_RATING         String         Used by the Parental Control settings on Fire TV to determine if content playback needs to be behind a PIN. Any recommendation without this extra or without setMaturityRating() will be treated as Mature content and may require a PIN subject to the Parental Control settings on the device.            Currently, supported values are as follows:                        US Marketplace: G, PG, PG13, R, NC17, NR, TVY, TVY7, TVG, TVPG, TV14, TVMA            German Marketplace: FSK0, FSK6, FSK12, FSK16, FSK18            Great Britain Marketplace: BBFCPG, BBFC12, BBFC18, BBFCU            Japan Marketplace: EIRIN_G, EIRIN_PG12, EIRIN_R15, EIRIN_18                                                   com.amazon.extra.RANK               int               Specifies the application's preferred ordering of recommendations. Fire TV's selection algorithm selects recommendations with lower rank numbers more often than higher numbers. Note that there is no guarantee for the sort order of recommendations displayed from different apps.                                       com.amazon.extra.ACTIONS               ArrayList&lt;int&gt;               Helps determine the context menu options displayed for each recommendation. Note that two context menu actions are supported, but only the first action is configurable.When users click a recommendation tile or its first context menu option, Fire TV uses the corresponding content intent data passed with recommendation to launch the app.                Possible values to include are as follows:                                      1: Watch with &lt;App name&gt;                   101: Watch                   2: Resume with &lt;App name&gt;                   102: Resume                   3: Switch &lt;App name&gt; Profile                   4: Change &lt;App name&gt; Settings                   104: Change Settings                   5: View with &lt;App name&gt;                   105: View                   6: Play with &lt;App name&gt;                   106: Play                   7: Listen with &lt;App name&gt;                   107: Listen                                      If no value is provided, the default action will be Open.                                         com.amazon.extra.LIVE_CONTENT         int         Helps determine whether a recommendation is live content and needs to be displayed or hidden based on CONTENT_START_TIME and CONTENT_END_TIME. Supported values are as follows:                          0: Not a Live content             1: Live Content                                           com.amazon.extra.CONTENT_RELEASE_DATE         String         Content release year. Example: 2016, 2015, 1977 etc.                      com.amazon.extra.CONTENT_CAPTION_AVAILABILITY         String         Caption availability of content.                          0: Caption not available for content             1: Caption available for content                                               com.amazon.extra.IMDB_ID         String         IMDB ID of content.                     com.amazon.extra.CONTENT_START_TIME         long         Start time in milliseconds (EPOCH).                     com.amazon.extra.CONTENT_END_TIME         long         End time in milliseconds (EPOCH).                     com.amazon.extra.TEXT_EMBEDDED_IMAGE         int         Whether recommendation image has text embedded on it.                          0: Text not embedded             1: Text embedded                                    com.amazon.extra.LONG_DESCRIPTION        String        Long description of a recommendation. Length is limited to 512 characters.                    com.amazon.extra.LAST_WATCHED_DATETIME        long        Last watched time of the recommended content in milliseconds (EPOCH).                    com.amazon.extra.PREVIEW_URL        String        Preview video or image URL for the recommendation.         Configuring the ManifestTo send recommendations when the device boots up, your app must have the RECEIVE_BOOT_COMPLETED permission. This permission lets your app receive and handle the broadcast that tells the app  your device was booted.To receive the broadcast, add the following permission (to your Android Manifest) as a child of the &lt;manifest&gt; element:&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/&gt;The initial launch point for supporting recommendations is to create a subclass of BroadcastReceiver. In the manifest, register the receiver as handling the ACTION_BOOT_COMPLETED intent. When the system first boots up, all applications that are interested will get an initial ‘ping’ to generate their recommendations.For the broadcast to work reliably, make sure your app is not installed on external storage.  Refer to the following for more details about storage locations:  Specifying Your App’s Installation Location  App install location  android:installLocation manifest attributeDelete RecommendationsAs a best practice, delete recommendations after users watch the recommended content. You can call cancel() for a specific notification ID to delete the recommendation.The following code sample shows how to delete recommendations:Notification notification = rec.getNotificationObject(mContext);//Use the same notification id which you used while creating this notificationnotification.cancel(notifyID);Next stepsTo learn more, see the following:  Recommendations Overview  Test Your Recommendations  Best Practices for Recommendations",
        "url": "fire-tv-recommendations-send-recommendations.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-recommendations-testing-html": {
        "title": "Test Your Recommendations",
        "tags": "[]",
        "content": "You can test your recommendations through options on the Developer Options Menu. The following steps walk you through this process.To test your recommendations:      Activate the Developer Tools Menu using either of the following options:          Amazon Remote Control: On the directional pad, press and hold the center and down together for 5 seconds. Then press the remote’s Menu button.      Amazon Game Controller: Press and hold A and Y buttons together for 5 seconds. Then press the controller’s menu button.            Slide the Developer Options to On. Then slide the Developer Row to On:            Select the Shared Recommendation Developer Row package.        Restart your Fire TV by going go to Settings &gt; Device &gt; Restart.  Open your app and stream content for several minutes.It takes some time for the Fire TV home screen to refresh and pick up the recommendations. After streaming content from the apps, wait about 5 minutes. Then navigate around a bit – go from the home screen to Settings, wait a few seconds, then go back to the home screen.Soon you will see a new row appear on the home screen called “Recommendation Testing Row.” This row will appear below Netflix or HBO Go rows, if you have the Netflix or HBO Go apps. (Otherwise, it appears directly below the “Featured Apps &amp; Games” row.)Next stepsTo learn more, see the following:  Recommendations Overview  Send Recommendations that Include Amazon Extras  Best Practices for Recommendations",
        "url": "fire-tv-recommendations-testing.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "connecting-adb-to-fire-tv-device-html": {
        "title": "Connecting to Fire TV Through ADB",
        "tags": "[]",
        "content": "You can use Android Debug Bridge (ADB) to connect your development computer to an Amazon Fire TV device or stick for installing, testing, and debugging your apps.Before you use ADB to connect to Fire TV or Fire TV stick, complete the following sections: Note: Android Debug Bridge is provided by the Android Open Source Project, not by Amazon.  Step 1. Enable Debugging on Amazon Fire TV  Step 2. Set Up Android Debug Bridge          Mac OS X      Windows        Step 3. Add Android Debug Bridge to Your Path          Mac OS X      Windows        Step 4: Options for Connecting ADB          Connect ADB Through the Network      Connect ADB Through USB        Update ADB  Run Your App  Troubleshooting  Next StepsStep 1. Enable Debugging on Amazon Fire TVYou must enable both ADB and debugging on your Fire TV device before you can connect to it:  From the main screen of your Fire TV, select Settings.  Select Device &gt; Developer Options.  Turn on ADB Debugging.      (Optional) If you plan to connect your computer to your Fire TV device using a USB cable, turn on USB Debugging.     Note: When USB Debugging is enabled, the USB port is unavailable for other uses such as external storage or input devices. To re-enable the USB port, turn off USB debugging.    Turn on Apps from Unknown Sources.Step 2. Set Up Android Debug BridgeAndroid Debug Bridge (ADB) is a command-line utility for running and managing Android apps on your device or emulator. ADB is available when you install Android Studio, but Windows users will need to install a special USB driver.Mac OS XNo action is required for ADB to work on Mac OS X.WindowsIf you’re on Windows and want to connect your computer to Fire TV through a USB cable, you need to install a special USB driver to connect your computer to a Fire TV device through ADB. The driver supports all the Fire TV platforms. To install the driver:  Download the USB file and extract the zip file’s contents.  Double-click the FireDevices_Drivers.  Complete the installation dialog boxes as prompted. Note: The USB driver is only certified through Windows 8.1. If you’re on Windows 10, you will need to explicitly accept that you are installing from an “un-certified source.”Step 3. Add Android Debug Bridge to Your PathYou need to add ADB to your PATH so you can more easily execute adb commands. (Your PATH is an environment variable used to specify the location of the program’s executable. If you don’t add ADB to your PATH, running adb commands will require you to browse to the &lt;Android SDK&gt;/platform-tools directory to run adb.)Mac OS XTo add ADB to your PATH on Mac:      Get the path to your Android SDK platform-tools directory:                  Open Android Studio and click the SDK Manager button .        The location to your Android SDK appears near the top next to Android SDK Location. For example: /Users/&lt;your username&gt;/Library/Android/sdk        If this is your first time opening Android Studio, there isn’t an SDK Manager button. Instead, at the Welcome to Android Studio prompt, click Configure &gt; SDK Manager and provide the location to the Android SDK.            Copy the path to the SDK and paste it somewhere convenient, such as a text editor.      Add /platform-tools to the end of the path you copied in the previous step. (“platform-tools” is the directory containing the adb executable.)      Copy the full path to your clipboard.            Use the following command to add adb to your .bash_profile, replacing /Users/&lt;your username&gt;/Library/Android/sdk/platform-tools/ with your path to your Android SDK.    echo 'export PATH=$PATH:/Users/&lt;your username&gt;/Library/Android/sdk/platform-tools/' &gt;&gt; ~/.bash_profile        Your .bash_profile file is usually in your user directory, which you can find by typing cd ~ (change to your user directory). Then type ls -a (list all) to show all files, including hidden ones.    If the file isn’t there, simply create one. You can then type open .bash_profile to see the paths listed. One of the lines should be something like this: export PATH=$PATH:/Users/&lt;your username&gt;/Library/Android/sdk/platform-tools/.        Restart any terminal sessions, and then type adb. If you successfully added ADB to your path, you will see ADB help info rather than “command not found.”  WindowsTo add ADB to your PATH on Windows:      Get the path to your Android SDK platform-tools directory:                  Open Android Studio and click the SDK Manager button .        The location to your Android SDK appears near the top next to Android SDK Location. For example: C:\\Users\\&lt;your user name&gt;\\AppData\\Local\\Android\\Sdk\\platform-tools        If this is your first time opening Android Studio, there isn’t an SDK Manager button. Instead, at the Welcome to Android Studio prompt, click Configure &gt; SDK Manager and provide the location to the Android SDK.            Copy the path to the SDK and paste it somewhere convenient, such as a text editor.      Add /platform-tools to the end of the path you copied in the previous step. (“platform-tools” is the directory containing the adb executable.)      Copy the full path to your clipboard.        Click Start and type view advanced system settings in the search box.  Click View advanced system settings.  When the System Settings dialog opens, click the Environment Variables button.  Under System Variables (the lower pane), select Path and click Edit.      Do one of the following:          On Windows 7 or 8, move your cursor to the farthest position on the right, type ; and then press Ctrl+V to insert the path to your SDK that you copied earlier. It may look like this: ;C:\\Users\\&lt;your user name&gt;\\AppData\\Local\\Android\\Sdk\\platform-tools. Click OK on each of the three open dialog boxes to close them.      On Windows 10, click the New button and add this location.        Restart any terminal sessions, and then type adb. If you successfully added ADB to your path, you will see ADB help info rather than “command not found.”Step 4: Options for Connecting ADBYou can use ADB to connect the Fire TV or Fire TV stick to your computer in two ways:  Connect ADB Through the Network. With this option, you connect using either a wired Ethernet or WiFi network connection. Both your computer and the Fire TV device must be on the same network for a network ADB connection to work.  Connect ADB Through USB. With this option, you use an A-to-A USB cable to establish a direct USB connection. Note: The following instructions apply to Generation 2 devices that have a more updated user interface. If you have a generation 1 device, the menu locations differ slightly.Connect ADB Through the NetworkYou need the IP address of your Fire TV device on your network to connect ADB to it.  If you haven’t already done so, connect your Fire TV device to a network (the same network that your computer is on). To do this, from the Fire TV home screen, go to Settings &gt; Network and select a network.  From the Fire TV home screen, select Settings.      Go to Device &gt; About &gt; Network. Make a note of the IP address listed on this screen.     Tip: Copy this IP address onto a convenient and visible place if you plan to connect regularly via the network.        Open a terminal window.    On a Mac, you can open Terminal by pressing Cmd + spacebar and then typing Terminal. On Windows, you open the Command Prompt usually by typing cmd in your program search. (The exact steps vary based on your Windows version.)    Make sure your Fire TV device and your computer are on the same network. You can use either a wifi network or a wired network.      Run the following commands, where &lt;ipaddress&gt; is the IP address of the Fire TV device noted in the previous section:    adb kill-serveradb start-serveradb connect &lt;ipaddress&gt;         Note: Make sure you added ADB to your PATH, as described in Add Android Debug Bridge to Your Path. Otherwise you will need to cd (change directories) to the platform-tools directory first and use./adb on a Mac or adb on Windows to run adb commands.    If the connection was successful, ADB responds with the message:    connected to &lt;ipaddress&gt;:5555            Verify that the Fire TV device appears in the list of devices:    adb devices        ADB responds with the message:    List of devices attached&lt;ipaddress&gt;:5555  device      If the serial number does not appear after running adb devices, update ADB and then repeat the steps here. Tip: You don’t always need to kill and start the server with ADB. Usually you can just run the adb connect &lt;ipaddress&gt; command.Connect ADB Through USBTo connect your computer to Fire TV through USB, you need an A-to-A USB cable. Note that you must have a Fire TV, not a Fire TV Stick, because only Fire TV (the box) has the USB cable port.  If you’re on Windows, install the USB driver as described in Set Up Android Debug Bridge.  Connect your Fire TV to a USB port on your computer.      Run the following commands:    adb kill-serveradb start-serveradb devices      After the last command, ADB responds with the following message, where &lt;serialno&gt; is the serial number of the device:List of devices attached&lt;serialno&gt; deviceIf the serial number does not appear after running adb devices, update ADB and then repeat the steps here.After ADB connects your computer to your Fire TV device, when you open Android Studio and click the Run App button, you’ll be prompted with a dialog box like this:In this example, “Amazon AFTS” refers to Fire TV (Generation 2).Update ADBIf your device isn’t listed when you type adb devices, try updating ADB:      Open a terminal session and navigate to your Android SDK tools directory.    In Android Studio, you can see the installation directory by going to Tools &gt; Android &gt; SDK Manager or by clicking the SDK Manager button . The directory is listed next to Android SDK Location.        In your Terminal or Command Prompt, change directories (cd) to your Android SDK directory, and then cd one level down to tools. (The tools directory is contained within the SDK directory.)        Run one of the following commands to update ADB:    Mac:    ./android update adb        Windows:    android update adb        You receive a message that says ADB has been updated.  Run Your AppAfter you have connected your computer to your Fire TV device through ADB, you can build and run your app on the Fire TV device. In Android Studio, click the Run App button .TroubleshootingIf you receive a message such as the following: unable to connect to 192.168.0.6:5555: Operation timed outorerror: device offlinetry any of the doing the following:  Make sure both Fire TV and your computer are using the same network and router.  When connecting wireless with adb connect &lt;ipaddress&gt;, make sure you’re typing the IP address correctly, with all the required dots .  Close Android Studio and any other emulators or USB cable connections.  Kill (adb kill-server) and restart (adb start-server) the server.  Restart Fire TV (Settings &gt; Device [or System] &gt; Restart).  Restart your router.  Update ADB.  Search online for the error message you’re seeing.Next StepsTo install and run your app on a Amazon Fire TV device for testing, see Installing and Running Your App.",
        "url": "connecting-adb-to-fire-tv-device.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "installing-and-running-your-app-html": {
        "title": "Installing and Running Your App",
        "tags": "[]",
        "content": "To test and debug your Fire TV app before submitting it to the Amazon Appstore, use Android Debug Bridge (ADB) to install and run your app on your Fire TV device. Installing your own app (outside of the Appstore) is sometimes referred to as “sideloading” an app.You must have already used ADB to connect your development computer to your Fire TV device. See Connecting to Fire TV Through ADB for more information. Note: Certain development tools and resources referenced on this page are provided by third parties, not by Amazon. Any links to these tools and resources will take you to third-party sites.  Installing Your App (Command Line)  Running Your App (Device)  Running Your App (Command Line)  Uninstalling Your App (Device)  Uninstalling Your App (Command Line)Installing Your App (Command Line)To install your app onto your Fire TV device from the command line, use the following command, where &lt;path-to-apk-file&gt; is the file system path to your app’s APK:adb install &lt;path-to-apk-file&gt;If the installation was sucessful, ADB responds with the message similar to this one:764 KB/s (217246 bytes in 0.277s)pkg: /data/local/tmp/HelloWorld.apkSuccessTo re-install an app that already exists on the device, you can use the -r option to reinstall the app:adb install -r &lt;path-to-apk-file&gt;Note that reinstalling an app does not replace any existing additional user data or cache. To clear this data, uninstall the old app before installing a new version, or clear the data by hand in System &gt; Applications.Running Your App (Device)Sideloaded apps appear in both the Recent row and in the My Library row in the Apps section. You can also find your app in the Settings menu:  From Fire TV’s main screen, select Settings &gt; Applications &gt; Manage Installed Applications..  Select your app.  Select Launch application. Note: If you have a generation 1 device, some of the menus may be slightly different.Running Your App (Command Line)To send a launch intent to your app on the Amazon Fire TV device, use the following command, where com.amazon.sample.helloworld is the package name of your app, and MainActivity is the name of your app’s primary activity.adb shell am start -n com.amazon.sample.helloworld/.MainActivityADB responds with a message similar to the following, and your app begins running:Starting: Intent { cmp=com.amazon.sample.helloworld/.MainActivity }Uninstalling Your App (Device)To uninstall your app from Amazon Fire TV on the device itself:  From Fire TV’s main screen, select Settings &gt; Applications &gt; Manage Installed Applications.  Select your app.  Select Uninstall &gt; Uninstall.Uninstalling Your App (Command Line)To uninstall your app from the command line, you need the package name for your APK. Use the following command to uninstall your app, where com.amazon.sample.helloworld is the package for your app:adb uninstall com.amazon.sample.helloworldIf you are unsure of your app’s package name, use the following command to see a list of all the installed APKs and their package names:adb shell pm list packages -f",
        "url": "installing-and-running-your-app.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "setting-up-your-development-environment-html": {
        "title": "Setting Up Your Development Environment",
        "tags": "[]",
        "content": "To start developing Android-based Fire TV apps for the Amazon Fire TV platform, you need to first set up your development environment.  Set Up the JDK  Set Up Android Studio  Next StepsSet Up the JDKYou need the Java Development Kit (JDK) from Oracle to compile Java apps on your machine.First check to see if you already have the JDK. Open Terminal or Command Prompt and type java -version. If you have the JDK, the response should be something like this:java version \"1.8.0_101\"Java(TM) SE Runtime Environment (build 1.8.0_101-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)If you don’t have the JDK, download the version of the JDK Installer for your machine from Java SE Development Kit Downloads and run it.For more details, see the following:  10 JDK 8 Installation for OS X  JDK Installation for Microsoft Windows. Specifically, see “Running the JDK Installer” and “Updating the PATH Environment Variable.”For other operating systems and information, see JDK 8 and JRE 8 Installation Start Here.Set Up Android StudioInstall Android Studio, the official IDE for Android projects. See Getting Started with Android Studio and Install Android Studio for information about setting up the Android Studio development environment on your machine.Next StepsTo connect your development computer to your Fire TV device with ADB, see Connecting to Fire TV Through ADB.To install and run apps you develop on your Fire TV device, see Installing and Running Your App.",
        "url": "setting-up-your-development-environment.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-system-xray-customized-metrics-html": {
        "title": "Customize System X-Ray Metrics",
        "tags": "[]",
        "content": "You can customize the display of metrics on System X-Ray by sending the information you want to be displayed. You can use this feature to display anything you find useful, such as static information, when a metric crosses different threshold boundaries, or when an event occurs. Note: See System X-Ray for an overview of System X-Ray, including how to show the Developer Tool Options menu and read the metrics displayed on the overlay.  Create Custom Metrics  Examples of Custom Metrics          Static Information      Thresholds      Events        See AlsoCreate Custom MetricsSystem X-Ray displays the App section when it receives an Intent, broadcast by your app, with metrics that you define. The following code shows how to create an intent for System X-Ray:private void updateMetrics(Context context) {// Initialize IntentIntent intent = new Intent(\"com.amazon.ssm.METRICS_UPDATE\");intent.putExtra(\"com.amazon.ssm.PACKAGENAME\", context.getPackageName());// Add Metricsintent.putExtra(\"Metrics1\", \"First metric\");intent.putExtra(\"Color1\", \"green\");intent.putExtra(\"Metrics2\", \"Second metric\");intent.putExtra(\"Color2\", \"yellow\");intent.putExtra(\"Metrics3\", \"Third metric\");intent.putExtra(\"Color3\", \"red\");// Sendcontext.sendBroadcast(intent);}This sample uses the Context class to get the necessary resources and classes for the environment.Initialize the Intent with the action com.amazon.ssm.METRICS_UPDATE and add the package name of your app as an extra. The package name is required because System X-Ray will only display the App section when your app is in the foreground. If you put this code in an Activity, you can call the getPackageName() helper method.The metric name must be Metrics1, Metrics2, or Metrics3. Any other name will be ignored. You can set a metric’s value to any String you want, but keep in mind that it may be truncated. System X-Ray displays each metric in the following format: [name]:[value].A metric’s default color is gray. If you choose to change the color, you will need to add an extra to the Intent. The name of the extra must be Color1, Color2, or Color3. The value can be red, yellow, green, or blue. The metric name and color name must have the same number in order for the color to apply. For example, Metrics1 will get Color1. The color values are independent of each other — you can have more than one metric with the same color.Now that the Intent is set up, you can call the sendBroadcast(Intent) method. If System X-Ray is enabled, it will add a section called App and display the metrics defined in the Intent. If you want to change the value or color of a metric, you must recreate the Intent with the new value or color and send it again.If you are tracking multiple metrics in System X-Ray, you must resend the status of all of them, even if they don’t all change, as System X-Ray does not cache a metric’s state. Otherwise, the metrics you don’t send will be removed from System X-Ray.Examples of Custom MetricsLet’s walk through a few examples of ways you can use this feature.Static InformationIf you test your app on multiple Fire TV devices or use different WiFi networks, you might want to see which Fire TV model you are testing, or the SSID of the WiFi network the Fire TV is using. As your app starts up, you could get this information and send it to System X-Ray. The following code shows a sample of how to show static information:private void updateMetrics(Context context, String buildModel, String ssid) {    // Initialize Intent    Intent intent = new Intent(\"com.amazon.ssm.METRICS_UPDATE\");    intent.putExtra(\"com.amazon.ssm.PACKAGENAME\", context.getPackageName());    // Add metrics    intent.putExtra(\"Metrics1\", buildModel);    intent.putExtra(\"Metrics2\", ssid);    // Send    context.sendBroadcast(intent);}The following image is an example display from the above input. In this image, System X-Ray shows that the Fire TV device model is AFTS, which is the 2nd generation Fire TV box. It also shows that Fire TV is connected to the Guest network.ThresholdsYou might want to track a metric that can cross different thresholds. For example, let’s say your app has video content and you want to track dropped frames during video playback. You might consider less than 5 drops to be green, 5-9 to be yellow, and 10 and higher to be red.As you update the number of dropped frames, you change the color to match the threshold. The following code sample shows how show a threshold:private void updateMetrics(Context context, int numFrameDrops, String frameDropStatus) {    // Initialize Intent    Intent intent = new Intent(\"com.amazon.ssm.METRICS_UPDATE\");    intent.putExtra(\"com.amazon.ssm.PACKAGENAME\", context.getPackageName());    // Add metrics    intent.putExtra(\"Metrics1\", \"FrameDrops:\"+numFrameDrops);    intent.putExtra(\"Color1\", frameDropStatus);    // Send    context.sendBroadcast(intent);}Here are screenshots of what the different thresholds look like:EventsEvent logging is useful, but you might want a visual way to track when an event last occurred. For example, perhaps testing reveals that an intermittent Exception is thrown after 3 hours of video playback. Here’s a sample of how to configure an event:private void updateMetrics(Context context, String message, String time) {    // Initialize Intent    Intent intent = new Intent(\"com.amazon.ssm.METRICS_UPDATE\");    intent.putExtra(\"com.amazon.ssm.PACKAGENAME\", context.getPackageName());    // Add metrics    intent.putExtra(\"Metrics1\", message);    intent.putExtra(\"Color1\", \"Red\");    intent.putExtra(\"Metrics2\", \"Time:\"+time);    intent.putExtra(\"Color2\", \"Red\");    // Send    context.sendBroadcast(intent);}In the following screenshot, System X-Ray displays the Exception, along with the time it occurred.See AlsoFor more details, see the following:  System X-Ray on Fire TV  Developer Tool Options on System X-Ray",
        "url": "fire-tv-system-xray-customized-metrics.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-system-xray-developer-tools-html": {
        "title": "Developer Tool Options",
        "tags": "[]",
        "content": "The Developer Tools Menu provides a number of options that provide real-time metrics and other information about your app. This information can assist you in troubleshooting, development, and testing.  Invoke the Developer Tools Menu  System X-Ray  Advanced Options  Snapshot  Record &amp; Share  Safezone  Developer Options  Launch Network Advisor  See AlsoInvoke the Developer Tools MenuYou can invoke the Developer Tools menu in several ways:  Remote Control: On the directional pad, press and hold the center and down together for 5 seconds; then press the remote’s menu button.  Amazon Game Controller: Press and hold A and Y buttons together for 5 seconds; then press the controller’s menu button.  If ADB is enabled on the Amazon Fire TV and a computer is connected, you can run the following command to invoke the dialog box: adb shell am start com.amazon.ssm/com.amazon.ssm.ControlPanelThe following screenshot shows the options on the Developer Tools menu:Not all the tools shown above are available in Generation 1 Fire TV devices. However, an upcoming release will bring the Development Tools Menu options into parity with Gen 1 devices. The only exception is with Advanced Options (the multimedia overlay), which won’t be available on Fire TV Stick Gen 1.System X-RaySystem X-Ray gathers instantaneous system metrics and displays on top of the screen as an overlay. When toggled on, the overlay will always visible on the screen.The System X-Ray overlay contains details about the following:  Display  CPU  Memory  NetworkFor deep-dive into System X-Ray, see System X-Ray on Fire TV.Advanced OptionsAdvanced Options enables multimedia information to appear when Android MediaCodec APIs are in use. When you switch this option on and then play media, an additional display (titled “MUL” for Multimedia) appears on the right. Note: Advanced Options is not available on Fire TV Stick Generation 1 (due to limited system resources). Even with future updates, Fire TV Stick Gen 1 devices won’t display the multimedia overlay.Information displayed in the Multimedia panel is divided into two sections: AUDIO and VIDEO.AUDIO:  Codec  Hardware Accelerated  Input Bitrate  SecureVIDEO:  Codec  Hardware Accelerated  Input Bitrate  Secure  Frames Dropped  Resolution  Frame RateSnapshotSnapshot provides a way for users to gather instantaneous all metrics information through adb command. Whenever you input the following command, metric information will display in the command line.adb shell dumpsys activity service com.amazon.ssm/.OverlayServiceSystem X-Ray must be running for this command to function.Here’s a sample output:SERVICE com.amazon.ssm/.OverlayService 3dde6680 pid=10820  Client:    [com.amazon.ssm.timestamp]: [2017-02-07 15:11:53]    [com.amazon.ssm.display.resolution]: [1080]    [com.amazon.ssm.display.refreshrate]: [60]    [com.amazon.ssm.display.hdcpversion]: [1.0]    [com.amazon.ssm.cpu.core0]: [30]    [com.amazon.ssm.cpu.core1]: [29]    [com.amazon.ssm.cpu.core2]: [0]    [com.amazon.ssm.cpu.core3]: [0]    [com.amazon.ssm.memory.appname]: [tv.twitch.android.viewer]    [com.amazon.ssm.memory.appmemory]: [56.8 MB]    [com.amazon.ssm.memory.activememory]: [1.3 GB]    [com.amazon.ssm.memory.availablememory]: [231.3 MB]    [com.amazon.ssm.network.rssi]: [-56]    [com.amazon.ssm.network.systemdownloadspeed]: [2.2 Mbps]    [com.amazon.ssm.network.appdownloadspeed]: [2.1 Mbps]Record &amp; Share Note: The Record &amp; Share feature is in experimental beta, so be aware that this feature may have some issues. For example, if the memory is too large, the output may time out.Record &amp; Share stores instantaneous metrics about CPU, memory, network, and multimedia into a database as historical data. Although the same information is displayed graphically in real-time through the System X-Ray overlay, Record &amp; Share takes this information and stores it into a history that you can dump to the command line.To use Record &amp; Share, first toggle the Record &amp; Share setting in the Developer Tools Menu to On. You’re then prompted to select the Record Settings:These properties control the following:  Interval: The time between two recordings: 2 seconds, 4 seconds, 8 seconds, 16 seconds, or 32 seconds.  Duration: How long the data gets stored in the database: 1 hour, 2 hours, 4 hours, 8 hours, or 16 hours.The default (2s interval, 1 hr duration) means that every 2 seconds, statistics will be recorded and stored in the database. The recording will be stored in the database for a total of 1 hour.After playing media to gather some recorded information, you can dump all historical metrics to the command line using the following::adb shell dumpsys activity service com.amazon.ssm/.OverlayService -allThe response includes the following information:CPU:  Timestamp  cpu0  cpu1  cpu2  cpu3Memory:  Timestamp  Total_Memory  Available_Memory  Active_Memory  Foreground_App_Memory  Foreground_App_PackageNameNetwork:  Timestamp  RSSI  Download_Speed  Foreground_App_Download_Speed  Foreground_App_PackageNameMultimedia:  Timestamp  AudioCodec  AudioInputBitrate  AudioAccelerated  AudioSecure  VideoCodec  VideoInputBitrate  VideoAccelerated  VideoSecure  VideoResolution  VideoFramerate  VideoFramedroppedHere’s an example of the display on the command line: CPU Timestamp           cpu0 cpu1 cpu2 cpu3 2016-10-31 11:40:22 19   16   13   18 MEMORY Timestamp           Total_Memory Available_Memory Active_Memory Foreground_App_Memory Foreground_App_PackageName 2016-10-31 11:40:23 919.3 MB     156.3 MB         731.8 MB      31.3 MB               com.amazon.ssm NETWORK Timestamp           RSSI Download_Speed Foreground_App_Download_Speed Foreground_App_PackageName 2016-10-31 11:40:21 -41  14.4 kbps      0 bps                         com.amazon.ssm 2016-10-31 11:40:23 -41  14.0 kbps      0 bps                         com.amazon.ssmIf you’re interested in only part of the metrics, you can add different options in the command. For example, to dump memory and network historical metrics to command line:adb shell dumpsys activity service com.amazon.ssm/.OverlayService -memory -networkThe following table shows all available options:            Option      Description                  blank (no option passed)      dump snapshot information              -snapshot      dump snapshot information              -all      dump all information from database              -memory      dump memory information from database              -cpu      dump CPU information from database              -network      dump network information from database              -multimedia      dump multimedia information from database      To check available options, pass the -help parameter:adb shell dumpsys activity service com.amazon.ssm/.OverlayService -helpYou can clear the recorded metrics stored in the database (before the duration time automatically clears the data). From the Developer Options Tools menu, select Record &amp; Share, and then click the menu button on your remote.SafezoneSome TVs use overscan with their display. Overscan means the TV displays some information off the edges of the visible screen (to accommodate discrepancies in monitors). You should not display important information in the overscan areas.To make the overscan areas visible, you can turn the SafeZone switch to On. This will make the overscan areas apparent so you can avoid displaying any information in these areas.Note that Fire TV Stick (Generation 2) does not include screen size calibration. If the screen display doesn’t fit correctly on the TV screen, the overscan area may not show accurately.Developer Options Note: This feature is still in development. More information will be released shortly about this feature.Currently some select third-party apps, such as Netflix and HBO Go, display recommendations on the Fire TV home screen in specific rows.Developer Options allows you to turn on a row called “Recommended By Your Apps” (displayed below the Netlix and HBO Go rows). This “Recommended By Your Apps” row will show recommendations sent from third-party apps.Currently, turning this row on shows only recommendations that your own app sends. When the feature is fully released, it will show recommendations from all third-party apps the user has installed (excluding some apps such as Netflix and HBO Go, which display recommendations on their own rows).Launch Network AdvisorLaunches a network analysis window that checks your network connection strength, channel, and other details. If there are problems, the Network Advisor provides recommendations to fix the issues.See AlsoFor more details, see the following:  System X-Ray on Fire TV  Customize System X-Ray Metrics",
        "url": "fire-tv-system-xray-developer-tools.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-system-xray-html": {
        "title": "System X-Ray Overlay on Fire TV",
        "tags": "[]",
        "content": "System X-Ray is a tool that helps internal and external developers identify app or system problems on Fire TV devices. System X-Ray gathers instantaneous system metrics and displays on top of the screen as an overlay. When toggled on, the overlay will always visible on the screen, even when users run applications, such as playing video or games.System X-Ray is available on all Amazon Fire TV and Fire TV Stick devices with Fire OS version 5.0.2 and higher.  Enable System X-Ray  Display (DIS)  CPU  Memory  Network  See AlsoEnable System X-RayYou can invoke the Developer Tools menu in several ways:  Remote Control: On the directional pad, press and hold the center and down together for 5 seconds; then press the remote’s menu button.  Amazon Game Controller: Press and hold A and Y buttons together for 5 seconds; then press the controller’s menu button.  If ADB is enabled on the Amazon Fire TV and a computer is connected, you can run the following command to invoke the dialog box: adb shell am start com.amazon.ssm/com.amazon.ssm.ControlPanelAfter the Developer Tools Menu dialog box appears, toggle System X-Ray On.(To close the dialog box, click your back button.) After you turn on System X-Ray, a long rectangular overlay appears on the screen showing different kinds of information:The System X-Ray overlay remains in place as you change apps or navigate around on Fire TV. The System X-Ray overlay is divided into four sections:  Display (DIS)  CPU (CPU)  Memory (MEM)  Network (NET)Display (DIS)The Display section shows the following:  HDMI Mode: Shows the physical height of display in pixels and the refresh rate in frames per second. For example, if the Display shows “1080p 60,” it means 1080 pixels is the physical height of the display, and 60 is the refresh rate in frames per second.  HDCP: Shows the HDCP (High-bandwidth Digital Content Protection) version used by Fire TV to encrypt content that is sent through the HDMI cable to the television.Note that Amazon Fire TV allows users to change their resolution by going to Settings &gt; Display &amp; Sounds &gt; Display &gt; Video Resolution. However, regardless of the resolution users select, an app can change the user’s selected resolution due to network or system resource reasons to give users a better experience. For example, when the YouTube app plays video, if your network connection is slow, the app might lower the resolution to ensure the playback is still smooth.CPUThe CPU (Central Processing Unit) section shows the % CPU usage of each core of the device at real time with different colors. Each column represents a different core. The CPU usage is depicted as follows:  0% to 33% (low utilization) shows in green  34% to 66% (moderate utilization) shows in orange  67% to 100% (high utilization) shows in redIf an Amazon Fire TV device only has two cores (as with the Fire TV Stick), only two columns will appear.CPU utilization can help identify CPU-intensive apps. A core that shows consistently heavy usage may indicate a need to make a process multi-threaded.MemoryThe Memory section has a bar with the labels App (blue), Other (gray), and Available (white):  Blue section: App — shows the memory usage (specifically, the Proportional set size (PSS) of the foreground application, not the GPU memory) and the package name of the foreground app. The package name of the foreground app is displayed below the bar. If you’re on the home screen, com.amazon.tv.launcher appears as the app name.  Gray section: Other — shows the memory usage by other applications.  White section: Available memory — shows the available (free) memory in the device.In this example, 44.7 MB of memory is used by the Fire TV launcher, 744.8 MB is used by the whole system, and 849.3 MB is still available.The Memory information can be used to identify issues such as:  Memory leaks in an app  Excessive memory consumption  Low memory conditions on the deviceNetworkThe Network section shows the strength of the WiFi signal along with the download rates across the entire device and for the visible app. The labels are as follows:  RSSI (Received Signal Strength Indication): Shows how strong the WiFi signal is, measured in dBm. The bar indicates the signal strength and is color-coded using the same color coding scheme as the CPU section to indicate the severity of a problem (green is strong, orange is average, and red is weak). The number is always negative – with better signal strength, the number moves closer to 0. If the Amazon Fire TV has a wired connection and is not using WiFi, RSSI is not shown.  System: Measures how many bits per second are being actively downloaded to the device (including both visible and background apps). This is not the available bandwidth. If 0 bps is displayed, no data is being downloaded at the moment.  Visible: Measures how many bits per second are being actively downloaded by the visible (also called foreground) app. This number will never be higher than the system download speed.The Network section can be used to diagnose issues such as:  Connectivity issues  Slow download speeds  Lower quality streams (selected by the media player)See AlsoFor more details, see the following:  Developer Tool Options on System X-Ray  Customize System X-Ray Metrics",
        "url": "fire-tv-system-xray.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "customizing-your-fire-tv-web-app-html": {
        "title": "Customizing Your Fire TV Web App",
        "tags": "[]",
        "content": "You can customize your web app for Fire TV in the following ways:  You can code for device-specific appearance or behavior and have your app detect the device on which it is running.  You can customize navigation and the way focus is indicated.In addition, you can scale up an app developed for a 720p display so it takes full advantage of Fire TV’s 1080p display.  Providing a Device-Specific Experience  Using a CSS to Customize the Appearance of Your Web App  Customizing Focus and Navigation in Your Web App  Displaying an App Developed in a 720p EnvironmentProviding a Device-Specific ExperienceAn app or web page can read the user agent string to detect a specific platform and then provide a specific user experience. User agent strings can include the version of the host operating system, the version of the browser, and other information. The user agent strings for the web app platform on FireTV are nearly identical to those on Fire tablets, but with a differing device model identifier. Also see the following sources of information:  For a list of non – Fire TV user agent strings, see the “Web App Development” section of Amazon Web Apps Frequently Asked Questions.  For the rules for the device model and how to detect current and future Fire TV devices, see Identifying Fire TV Devices.   Using a CSS to Customize the Appearance of Your Web AppIt is important that focused items on a page are styled in a way which clearly signifies that a subsequent press on the center button would select it. The default selection indicators (yellow border and/or blue background) are generally not recommended and should be customized on a per-application basis.  To define this styling, developers should use the CSS focus property.button:focus {    border : #ffffff 2px solid;    outline : 0;}Some elements when focused will show a blue highlight background. The following CSS property should remove it; however, note that any element this is applied to will have a transparent background which isn’t always desired (input text field, for example).*:focus {    outline:none;    background-color:rgba(0,0,0,0);}For information on the design guidelines for Fire TV web apps, see Design and User Experience Guidelines.Customizing Focus and Navigation in Your Web AppIf you want your web app to handle the selection highlighting or directional navigation on its own, simply capture the key event and consume it. For a working example of capturing key events and customizing navigation, see the template app in the Web App Starter Kit for Fire TV, which is available on GItHub at https://github.com/amzn/web-app-starter-kit-for-fire-tv.Displaying an App Developed in a 720p EnvironmentThe resolution for Fire TV apps is1080p (1920x1080). If your app was developed for a 720p interface, it fills only 2/3 of the display. In this case, the best solution is to alter your app to target 1080p. However, if you want to simulate a 720p environment, you can do so by putting the following meta tag in the header of your page. &lt;meta name=”viewport” content=”initial-scale=1.5, user-scalable=no”&gt;This meta tag sets a viewport, representing the area the web app page occupies, and sets a zoom level of 150%. The result is that the web app content looks like it would on a 720p display but fills the 1080p display area.For more information, see “Resolution and Page Scaling section” in Getting Started with Web Apps for Fire TV.",
        "url": "customizing-your-fire-tv-web-app.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "fire-tv-web-app-faq-html": {
        "title": "Fire TV Web App FAQ",
        "tags": "[]",
        "content": "The following are frequently asked questions about Fire TV Web Apps.  Q: How can I customize the Amazon Remote Back button behavior for a web app?  The Back button does not raise a standard key event. The default behavior for this button is to navigate back in the history stack until the WebView is at the root page, and once there a subsequent back press closes the application without informing the web app. As a workaround, you can use the History API to capture Back button presses by pushing to the history stack in the onLoad event.    Note that there is a bug in Chromium v25, which fires the onpopstate event on page load. This adds complexity to the following workarounds. For information about this bug, see the Chromium documentation for Issue 63040: Add window.history.state and don’t fire popstate after load.    There are two possible workarounds using the History API. Only one is needed. The following example is the preferred workaround. It uses the state to ensure that it acts on the correct popstate event.    window.addEventListener(\"load\", function () {    window.addEventListener(\"popstate\", function () {        if (window.history.state !== \"backhandler\") {            // put your back handler code here            window.history.pushState(\"backhandler\", null, null);        }    });    window.history.pushState(\"backhandler\", null, null);});        The second, non-preferred workaround sets a timeout to delay registering the onpopstate event until right after the load. This works, but relies on timers and therefore is not the primary recommendation.        window.addEventListener(\"load\", function() {    setTimeout(function() {        window.onpopstate = function(event) {            showConfirmDialog();            window.history.pushState(null, null, null);        };    }, 0);    window.history.pushState(null, null, null);});        Q: How do I properly close a web app?  Many apps need to explicitly close or end the application.  For example, they may override the Back button behavior to show a confirmation dialog prior to closing the app, and want to ensure the window is properly closed when selected by the user.  The snippet below provides a method of doing so.    window.open(\"\", \"_self\").close();        Q: Can web apps for Fire TV support digital rights management (DRM) for media playback?  No, the Web App Platform does not currently support any form of DRM for media playback.  For details about DRM support for native FireTV applications, see the DRM section of the Specifications for Fire TV Devices page.  Q: Does my web app need to disable the screen saver during video playback?  Yes, your app should disable the screen saver on the Fire TV during video playback to allow for long running times without user interaction. When you submit your app, select the Prevent Sleep for Video Playback check box.    Otherwise, the screen saver appears after a period of inactivity, just as it would during navigation through the main menu.    Q: Can web apps for Fire TV use HTTP live streaming (HLS)?  Yes. HLS video playback is supported in the Web App Platform. However, be aware of the following known issues:          Videos do not pause automatically if put in background while loading or buffering. As a workaround, use the Page Visibility API to manually pause videos. For information on using the Page Visibility API to detect focus changes, see Getting Started with Web Apps for Fire TV.      Short video segments (~1-2 sec) may cause pauses and artifacts during playback.      Seeking in an HLS stream is not supported.      Getting the duration of an HLS video is not supported.      When the user performs a voice search during HLS playback the video is paused, and when the playback resumes, the video starts from the beginning.      An alternative to HLS that does not have these issues is VisualOn. Be aware though that VisualOn runs only if full-screen mode, and so you cannot use overlays or custom controls.        Q:  Can web apps for Fire TV use the Blob Interface API?  No. The Blob APIs are currently unsupported in the Web App Platform.  Note that the the Blob object is incorrectly present in the namespace which may cause some feature detection libraries to wrongly identify the platform as being Blob-capable.  Q: Why does my web app show an unchanging duration of 1:40 seconds during audio and video playback?  For both audio and video elements, the duration property incorrectly reports a time of 100 seconds (1:40) during the initialization period.  If you set your text field at this time and do not update it, it will improperly show 1:40.  The correct value is in fact made available once the media element has begun playback.  The following code example shows a workaround of using the durationchange event to update the element with the correct duration during initialization.    video.addEventListener(\"durationchange\", function() {    // when this event fires, the media duration should be available    document.getElementById(\"duration\").innerHTML = video.duration;});        Q: How do I allow users to control video playback using the remote?  Some HTML5 elements cannot be focused with the remote. For example, div and span elements cannot be focused with the remote. Also, if you rely on default video controls, the individual Play, Pause, Forward, and Rewind buttons cannot be focused. However, the video element as a whole can be focused and can be controlled with the remote keys.  Q: Can I launch the virtual keyboard and tell when text has been submitted?  The virtual keyboard appears when the user presses the Select button on an text input field. This keyboard can be used by either the Amazon Remote or the Amazon Game Controller. Currently, there is no way to launch the virtual keyboard programmatically (for example, by setting focus).    If you want to know when the user has submitted text, you can listen for the change event, as demonstrated in the following code. Note that this event does not fire if the user clicks the Back button rather than the Submit button.    &lt;input id=\"test\" value=\"\"&gt;var testInput = document.getElementById(\"test\");testInput.addEventListener(\"change\", function(e){    console.log(this.value);});        Q: Why does my app show unexpected behavior with third-party authentication pages?  If you redirect to third-party authentication page within the same WebView, rather than using window.open() to create a new WebView, the authentication page replaces the original login page in history. This can cause an issue in scenarios with multiple login options (for example, Google or Facebook). The problem is that users cannot go back if they change their mind about logging in. The authentication page that replaced the app will typically just close.    The following actions cause such navigation problems:          Redirecting the window location -&gt; window.location.href = \"google_authentication_link\"      Using the window.location.replace() function        Instead, use the window.open() function.     Note: Using window.location.assign() does not work in the current WebView.    Q: Can my web app support MOV Files?  No, currently Amazon WebView has no support for MOV files.  Q: Can I use CSS viewport units?  You can use the vw/vh/vmin/vmax units except in conjunction with the CSS translate() function. In the current release of AWV (v25), you cannot translate an absolutely positioned element using CSS viewport units. This is a known issue in v25 of Chromium. See Issue 137617: vh, vw units don’t work in css transforms in the Chromium documentation. As a workaround, you can use the following calculation in v25 to get the equivalent viewport unit value in pixels for the unsupported CSS properties.    1vw = ( window.innerWidth/100 )1vh = ( window.innerHeight/100 )M vw = ( window.innerWidth/100 ) * MN vh = ( window.innerHeight/100 ) * N        Q: How can I simulate a 720p environment for my web app?  To simulate a 720p environment, put the following meta tag in the header of your web app page.  Please note that the viewport meta tag is technically unsupported for initial release and scales pages up on 1080p displays (potentially causing page distortion). This makes the following snippet more of a workaround than a solution.    &lt;meta name=”viewport” content=”initial-scale=1.5, user-scalable=no”&gt;        This meta tag sets a viewport, representing the area the web app page occupies, and sets a zoom level of 150%. The result is that the web app content looks like it would on a 720p display.    For more information, see the “Resolution and Page Scaling” section on Getting Started with Web Apps for Fire TV.    Q: Can I use VisualOn for media playback?  You cannot force Fire TV or Fire TV Stick to use VisualOn for media playback. The platform automatically chooses the best player to handle the video type.     Note: The amazon_enhanced_hls video attribute flag was introduced on 1.4.1 (Fire TV) and 1.0.1 (Fire TV stick) for applications to route HLS playback to the VisualOn player. The downside of this attribute was that playback would take place in full-screen with built-in controls and the web developer did not have an option to override the controls.    As of Fire TV 1.5 and Fire TV Stick 1.1, these platforms no longer support the amazon_enhanced_hls attribute because the platform automatically chooses the best player (native or VisualOn) depending on the video type. Pages that were authored to have the amazon_enhanced_hls attribute will continue to load on a suitable player; however, video playback will not automatically go to full screen. The page must request to go full screen in JavaScript as needed.    Q: How can I improve scaling performance?  When a video element gets focus, its size is often scaled up by setting the CSS property “height” and “width”. This practice causes full background repaint during navigation. Use -webkit-transform: scale() instead for image resizing to avoid unnecessary repaints. For example, the following CSS code causes unnecessary repaints:    .focused .video-element-thumb {    width: 288px;    height: 162px;    //...}        The following CSS code avoids unnecessary repaints:    .focused .video-element-thumb {    -webkit-transform: scale(1.125, 1.125);    //...}        Q: Is Web Audio supported in web apps for Fire TV  Yes. Starting with  Fire TV 1.5 and Fire TV Stick 1.1, Fire TV supports Web Audio. For more information, See Getting Started with Web Apps for Fire TV.  Q: If I use the img tag for buttons, do I have to include alt text?  Yes. Applications using img tag as buttons (with onClick handlers) must have the “alt” attribute to have those buttons read out in accessibility mode. Otherwise, the buttons are not accessible to users in accessibility mode.  Q: Are Known Media Source Extensions (MSE) supported in web apps for Fire TV  No. MSE support is disabled in Web Apps for Fire TV (though not for other platforms). Because MPEG-DASH is built on MSE, MPEG-DASH is not supported as well. Without the adaptive streaming support offered by MSE, it is possible that the end user devices might take longer to recover from network congestion and that seeks may take longer. Note, however, that Web Apps on Fire TV platform does support the other adaptive streaming standard, HLS.",
        "url": "fire-tv-web-app-faq.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "getting-started-with-web-apps-for-fire-tv-html": {
        "title": "Getting Started with Web Apps for Fire TV",
        "tags": "[]",
        "content": "Amazon Fire TV, including both Fire TV and the Fire TV Stick, supports HTML5 web apps. You can port your web app to a new platform and submit it to the Amazon Appstore with minimal effort.  Options for Submitting Apps  Including the Amazon APIs  Using Web App Tester and DevTools  Resolution and Page Scaling  Web Audio API Support  Focus Changes          Custom Amazon Events      The Page Visibility API        Voice Search Interruption  Testing IAP  Features Not Available on Fire TVOptions for Submitting AppsYou have three ways of submitting your web app to the Amazon Appstore:  Hosted app: Customers run a wrapper that opens a web view to your URL.  Packaged app: Customers run the same wrapper that loads your HTML/JS/CSS/assets from local copies, submitted as a ZIP archive.   Android app: You build your own wrapper with Cordova or create your own hybrid app and submit it like any other native app. For more information on Cordova, see Apache Cordova. For information on using Cordova with Amazon WebView, see the Apache Cordova API topic, Amazon Fire OS Platform Guide.For a comparison of hosted apps and packaged apps, see Differences between Packaged and Hosted Apps. For information on submitting both hosted and packaged apps, see Submitting or Updating Your Web App to the Amazon Appstore.The Amazon WebView API also enables creating hybrid HTML5 apps. For more information on the Amazon WebView API, see Building and Testing Your HTML5 Hybrid App.Be aware of the issues presented in detail below as you develop your web app for Fire TV.For more information, also see the following topics:  Supporting Controllers in Web Apps  The Web App Starter Kit for Fire TV  Customizing Your Fire TV Web App  Migrating Your Web App to Fire TV   The Fire TV Web Apps FAQIncluding the Amazon APIsIf your web app uses Amazon APIs, such as the In-App Purchasing API, you need to include the Amazon API JavaScript library. This library initializes any Amazon plugins and raises an amazonPlatformReady event to to signal that the APIs are ready for use. The library is hosted at the URL http://resources.amazonwebapps.com/v1/latest/Amazon-Web-App-API.min.js. To include this library, add the following &lt;script&gt; tag to your web app:&lt;script src=\"https://resources.amazonwebapps.com/v1/latest/Amazon-Web-App-API.min.js\"&gt;&lt;/script&gt; Note: Including the Amazon API JavaScript library is necessary only if your app uses Amazon APIs.Because this library raises an amazonPlatformReady event when initialization is complete, wait for the amazonPlatformReady event before you call any Amazon APIs, as in the following example:document.addEventListener('amazonPlatformReady', function () {    //API code goes here});Using Web App Tester and DevToolsWeb App Tester is a tool that lets you test your hosted and packed apps on the Fire TV device.Web App Tester also enables using DevTools to debug your web app. For information on getting and using DevTools, see Debugging Your Web App.To enable DevTools on Fire TV:  In the Web App Tester tool, launch your web app.  On the Amazon Fire TV remote, press the Menu button.  Select the Enable Devtools menu item and follow the instructions in the dialog box that appears.Resolution and Page ScalingTarget a resolution of 1080p (1920x1080) for web apps for Fire TV. For information on scaling up your app from 720p to 1080p, see Customizing Your Fire TV Web App. For more information about design guidelines for Fire TV web apps, see Design and User Experience Guidelines. Web Audio API SupportFire TV and Fire TV Stick both support the Web Audio Api for web apps. They also support the suspend and resume methods of the AudioContext interface. These methods allow applications to pause the audio device when needed. Suspending audio playback reduces CPU usage and prolongs battery life. The following example illustrates creating an AudioContext object and calling the suspend and resume methods. // Create contextvar context = new (window.AudioContext || window.webkitAudioContext)();// Start contextvar oscillator = context.createOscillator(); oscillator.connect(context.destination); oscillator[oscillator.start ? 'start' : 'noteOn'](0);// Suspendcontext.suspend();// Resumecontext.resume();// Since both suspend and resume return a promise, their success/failure can be determinedcontext.suspend().then( function() { alert('success!'; }, function() { alert('failure!'; });context.resume().then( function() { alert('success!'; }, function() { alert('failure!'; });Coupled with the page visibility API, suspend and resume provides an ideal way to silence games and other applications that use Web Audio when they go into the background and when the user initiate a voice search. For more information and code examples, see the following Focus Changes and Voice Search Interruption sections. Focus ChangesA web app may need to track when it is moved to the background (as when the user presses the Home button) so that the app can preserve its state at the moment when it is moved to the background and can resume when it is brought to the foreground. The following table shows the different methods and their behavior.            Method      Description                  Custom Amazon events: pause and resume      pause event is fired when the app is sent to the background (app completely hidden) or when its partially obscured (for example, when the Voice Search dialog box is displayed)resume event is fired when the app is brought to the foreground (app completely visible) including when the Voice Search dialog box is dismissed.               Page Visibility API       webkitvisibilitychange event is fired:  • when the app is sent to the background (completely hidden)  • when the app is brought to the foreground (completely visible)       Custom Amazon EventsTo use the custom Amazon events, you need to include the Amazon Webapp API script in your app and have your app listen for pause and resume events fired on the document.  To register as a listener for the pause event, use the following syntax.document.addEventListener(“pause\", yourCallbackFunction, false);The pause event is fired when the app is sent to the background (app completely hidden) or when it’s partially obscured (e.x Voice Search Dialog is displayed). The app should use document.addEventListener to attach an event listener once the amazonPlatformReady event fires.To register as a listener for the resume event, use the following syntax.document.addEventListener(“resume\", yourCallbackFunction, false);The resume event is fired when the app is brought to the foreground (app completely visible) including when the Voice Search Dialog is dismissed.  The app should use document.addEventListener to attach an event listener once the amazonPlatformReady event fires.The following code snippet illustrates registering for the pause and resume events.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Page Visibility Test Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt; Visibility : &lt;/h2&gt;&lt;div id=\"appstate\"&gt; Visible &lt;/div&gt;&lt;script src=\"https://resources.amazonwebapps.com/v1/latest/Amazon-Web-App-API.min.js\"&gt;&lt;/script&gt;&lt;script&gt;    var visibility =  document.getElementById(\"appstate\");    function onPause() {        visibility.innerHTML = 'Hidden';    }    function onResume() {        visibility.innerHTML = 'Visible';    }    function onAmazonPlatformReady() {        document.addEventListener(\"pause\" , onPause, false);        document.addEventListener(\"resume\" , onResume, false);    }    document.addEventListener(\"amazonPlatformReady\" , onAmazonPlatformReady, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;The Page Visibility APIFor all types of apps, the web app platform fires a visibility changed event, using the Page Visibility API, when the app loses or gains focus. (For more information on detecting loss of focus, see the FAQ Web Apps for Fire TV.)For video-playback apps, the video is paused automatically when the app loses focus. However, you must ensure that your UI is in the proper state when the app regains focus. For example, it is a good idea to bring up the media controls so the user can see the state of the playback, and to ensure the app responds to Play/Pause button. Alternatively, you may want to resume the video automatically.However, for audio apps, the app itself must pause the audio playback. This is especially important because presses on the media buttons are not passed to an app when it is in the background, so the user has no way to pause audio playback. The following code shows how to detect changes in focus. Note that these events use the “webkit” prefix. var handleVisibilityChange = function() {    if (document.hidden || document.webkitHidden) {        // pause audio/video playback, pause game, adjust video control UI, etc.    } else {        // resume playback, adjust UI, etc.    }}document.addEventListener('webkitvisibilitychange', handleVisibilityChange);document.addEventListener('visibilitychange', handleVisibilityChange);If you are using Web Audio, you can use the Page Visibility API to detect changes in focus and use the suspend and resume methods of the AudioContext object to pause and resume audio playback, as illustrated in the following example. (For more information on Web Audio, see the preceding Web Audio Support section.)// Create contextvar context = new (window.AudioContext || window.webkitAudioContext)();// Start contextvar oscillator = context.createOscillator(); oscillator.connect(context.destination); oscillator[oscillator.start ? 'start' : 'noteOn'](0);// Determine the correct visibility api names.var hidden, visibilityChange;if (typeof document.hidden !== \"undefined\") { // Opera 12.10 and Firefox 18 and later support        hidden = \"hidden\";        visibilityChange = \"visibilitychange\"; }else if (typeof document.webkitHidden !== \"undefined\") {        hidden = \"webkitHidden\";        visibilityChange = \"webkitvisibilitychange\"; }// Page visibility listener.function handleVisibilityChange() {   if (document[hidden]) {     if (context.suspend) {       context.suspend();     } else {       // Browser does not support suspend()     }   } else {     if (context.resume) {        context.resume();     } else {          // Browser does not support resume()     }   }}document.addEventListener(visibilityChange, handleVisibilityChange, false);Voice Search InterruptionA requirement for applications submitted for Fire TV is that they stop or pause audio playback when the user presses the Voice Search button on the remote.  This is to ensure that the microphone on the remote does not pick up audio from the system and perform poorly. Your app can detect when the user presses the Voice Search button in two ways:  By responding to the custom Amazon pause and resume events  By using the Page Visibility API, as explained in the previous section (for platform version 1.3 only)For more information and codes examples, see the preceding Focus Changes section.For video-based media applications, the web app platform will automatically handle pausing the video. You only need to ensure that your UI is in the proper state when your app regains focus. For example, ensure that the Play/Pause button is correctly set, or you may decide to bring up the video control overlay.For games, you must also ensure that audio playback is muted or paused. A common solution in this situation is to put the game in a paused state.Audio-only apps must also stop or pause playback. When you use Web Audio, you can use the suspend and resume methods of the AudioContext object to properly handle voice search requests when using WebAudio.  (For more information on Web Audio, see the preceding Web Audio Support section.)&lt;script src=\"https://resources.amazonwebapps.com/v1/latest/Amazon-Web-App-API.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var context = new (window.AudioContext || window.webkitAudioContext)();function onPause() {    context.suspend();}function onResume() {    context.resume();}function onAmazonPlatformReady() {    document.addEventListener(\"pause\" , onPause, false);    document.addEventListener(\"resume\" , onResume, false); }document.addEventListener(\"amazonPlatformReady\" , onAmazonPlatformReady, false);&lt;/script&gt;Testing IAPIf you use the IAP API 1.0 in your web app (IAP 2.0 does not currently support web apps), you can test IAP by using the SDK tester. For more information on testing IAP see Testing In-App Purchasing.To use SDK Tester:   Download the Amazon Web App SDK from Amazon Apps and Games Services SDKs.  Install the SDK tester apk in App-SDk.zip/Android/In-App-Purchasing/1.0/tools/AmazonSDKTester.apk.      Create a JSON file with the following contents. (This example was developed for the YouZeek music-streaming app.)     {    \"vip_unlimited\" : {        \"itemType\" : \"ENTITLED\",        \"price\" : 0.99,        \"title\": \"VIP Subscription Parent\",        \"description\": \"VIP Subscription Parent\",        \"smallIconUrl\": \"Any Image Link Here\"    },    \"vip_unlimited_monthly\" : {        \"itemType\" : \"SUBSCRIPTION\",        \"price\" : 0.99,        \"title\": \"VIP Monthly Subscription\",        \"description\": \"VIP Monthly Subscription\",        \"smallIconUrl\": \"Any Image Here\",        \"subscriptionParent\": \"vip_unlimited\"    }}            Run the following command:    adb push amazon.sdktester.json /mnt/sdcard/amazon.sdktester.json        or copy the JSON file into the root folder of the device as amazon.sdktester.json.     Launch web app using the Web App Tester.Features Not Available on Fire TVThe following web application platform features are not available on Fire TV:  Geolocation (GPS)  Popup windows  Multiline text boxes  Launching an app to an external browser  Uploading files    Downloading files WebGL is supported on Fire TV, but not supported on the Fire TV stick.",
        "url": "getting-started-with-web-apps-for-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "migrating-your-web-app-to-fire-tv-html": {
        "title": "Migrate Your Web App to Fire TV",
        "tags": "[]",
        "content": "Amazon Fire TV supports HTML5 web apps. If you have an existing web app that you want to make available on Fire TV, review the following checklist for migrating your web app to the Fire TV platform.If you are developing a new web app instead of migrating an existing app, see Getting Started with Web Apps for Fire TV.Before you begin, review the Design and User Experience Guidelines for details about designing your app for the 10-foot User Interface experience.Web App Migration Checklist            If your web app…      You need to…                  Plays video      Make sure your UI is the proper state when your app regains focus. Note that the video playback is automatically paused when your app loses focus.  You can use the Page Visibility API to detect focus changes and respond appropriately. See “Focus Changes” in Getting Started with web Apps for Fire TV. In addition, be sure to select the Prevent Sleep for Video Playback check box when submitting your app. This disables the Fire TV screensaver while your app plays videos.              Plays audio      Pause the audio playback when your app loses focus. The audio is not automatically paused, and the user cannot pause the audio with the remote once the app is in the background. You can use the Page Visibility API to detect focus changes and respond appropriately. See “Focus Changes” in Getting Started with web Apps for Fire TV for more details.              Shows audio or video duration during playback      Listen for the durationchange events to show the appropriate duration. Note that the duration property reports an incorrect duration during initialization, so you need to update the duration once playback begins. See “Why does my web app show an unchanging duration of 1:40 seconds during audio and video playback?” in the Fire TV Web App FAQ in the FAQ.              Uses custom playback controls      Capture the key presses to use input from the Amazon Fire TV Remote and Amazon Fire TV game controller. See Supporting Controllers in Web Apps.              Has an exit button      Properly close your web app. See “How do I properly close a web app?” in the Fire TV Web App FAQ.              Is a single-page application      Use the W3C history to move through the content and respond to the back button correctly. See “How can I customize the Amazon Remote Back button behavior for a web app?” in the Fire TV Web App FAQ.              Uses the viewport API to control scaling      Make sure your app targets 1080p. See “Resolution and Page Scaling” in Getting Started with web Apps for Fire TVgetting-started-with-web-apps-for-fire-tv in Getting Started.              Explicitly targets 720p resolution      Change your app to target 1080p. If the device is set to 720p, your app is automatically scaled down. See “Resolution and Page Scaling” in Getting Started with web Apps for Fire TVgetting-started-with-web-apps-for-fire-tv in Getting Started.              Relies on touch or click events for navigating between app components      Review your UI and make sure it will work with remote and game controller input instead of touch and click input. All selectable UI elements should be reachable using the up, down, left, and right navigation buttons available on remotes and game controllers. See Design and User Experience Guidelines and Supporting Controllers in Web Apps.              Is a game      Review the information about supporting game controllers and handling focus changes. See “Using Input from the Amazon Fire Game Controller” in Supporting Controllers in Web Apps and “Focus Changes” in Getting Started.      ",
        "url": "migrating-your-web-app-to-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "supporting-controllers-in-web-apps-html": {
        "title": "Supporting Controllers in Web Apps",
        "tags": "[]",
        "content": "Amazon Fire TV supports user input from the Amazon Fire TV remote, the Amazon Fire game controller, and other game controllers that support the Bluetooth HID gamepad profile. These controllers give users a means of navigating in your app and selecting items.  Using Input from the Amazon Fire TV Remote  Using Input from the Amazon Fire Game Controller  Play/Pause Media ButtonUsing Input from the Amazon Fire TV RemoteThe bundled Amazon Fire TV Remote has the keys shown in the following image.Remote controlTo enable users to interact with your web app by using the remote, you need to capture the key events when users press one of the keys. Most key presses can be captured just as standard keyboard events in a browser.For keycode mappings, see the following table. The Back, Home, Menu, and Voice Search buttons cannot be captured. For a workaround that allows customizing Back button behavior, see the Fire TV Web Apps section of Amazon Web Apps Frequently Asked Questions.                                    Amazon Fire TV Remote Button      Key Code      Standard Behavior                  Select (D-Pad Center)      13      Selects the user interface item with the current focus.              Up (D-Pad)      38      Moves the focus upward in the user interface.              Down (D-Pad)      40      Moves the focus downward in the user interface.              Left (D-Pad)      37      Moves the focus left in the user interface.              Right (D-Pad)      39      Moves the focus right in the user interface.              Play/Pause      179      Controls media playback. Play/Pause is a toggle.              Rewind      227      Rewinds or skips backwards in media playback contexts.              Fast Forward      228      Fast Forwards or skips ahead in media playback contexts.               Back      NA      Navigates back in the history stack.      These key events are sent only to apps that are in focus.Using Input from the Amazon Fire Game ControllerDeveloping for the Amazon Fire Game Controller is straightforward:  Amazon WebView supports the W3C standard Gamepad APIs.  The buttons on the Amazon Fire Game Controller map to the standard gamepad format.  In using the Gamepad APIs with the Amazon Fire Game Controller, the Back button is equivalent to Select on a standard controller, and the Menu button is equivalent to Start. If you do not use the Gamepad APIs, the buttons behave as Back and Menu buttons.For more information on developing for the Standard Gamepad APIs, see Jumping the Hurdles with the Gamepad API.If you choose not to use the Gamepad APIs, the buttons on the Amazon Fire Game Controller generally map to the same functions as on the Amazon Fire TV Remote (other than the B button).The Amazon Fire TV (2nd Generation) Game Controller has these buttons:The Amazon Fire TV (1st Generation) Game Controller has these buttons:The following table shows the key mappings.                                    Amazon Gamepad Controller Button      Key Code      Standard Behavior                  Up (D-Pad/Joystick)      38      Move the focus upward in the user interface.              Down (D-Pad/Joystick)      40      Move the focus downward in the user interface.              Left (D-Pad/Joystick)      37      Move the focus left in the user interface.              Right (D-Pad/Joystick)      39      Move the focus right in the user interface.              A       13      Select the user interface item with the current focus.              B      8      None              X      13      Select the user interface item with the current focus.              Y      13      Select the user interface item with the current focus.              Back      NA      Navigates back in the history stack.      Play/Pause Media ButtonA requirement for all media apps submitted for Fire TV is that they handle the media Play/Pause key events to control media playback. All Game applications must also handle the media Play/Pause key events to play or pause the game. The key code for the Play/Pause button is 179. Note: The button is a toggle. If the app is paused the  Play/Pause button should start the app. If the app is running, the Play/Pause button should pause it.",
        "url": "supporting-controllers-in-web-apps.html",
        "product": "Fire TV"
      }
      ,
      
    
          
      "the-web-app-starter-kit-for-fire-tv-html": {
        "title": "The Web App Starter Kit for Fire TV",
        "tags": "[]",
        "content": "The Web App Starter Kit for Fire TV, available on Github at github.com/amzn/web-app-starter-kit-for-fire-tv, includes the Fire TV web app template and associated text files. The Fire TV web app template is both an illustration of best practices for developing a web app for Fire TV and a starting point for developing your own web app. Tip: For an in-depth comparison between Web App Starter Kit for Fire TV (WASK) and Fire App Builder, see Fire TV Development Framework Comparison.  Working with WASK  Downloading the Template  For Brightcove Video Cloud CustomersWorking with WASKYou can easily create your own app by replacing sections of code in the template with your code, making the tweaks your app requires, and using your own data sources.The template is an app that displays movies in different categories. These categories are displayed vertically in the left-hand navigation pane, and the movies in each category appear in a horizontal row to the right of the category.The user can navigate up and down the left-hand navigation pane or move to one of the rows and navigate back and forth in the row. The user can also select one of the movies in a row to see details about that movie.Although the items in the template are movies, the same format and techniques can be used for almost any sort of items.The template incorporates good design for Fire TV web apps, optimized user experience, and handling input from the Amazon Fire TV Remote. For more information on Fire TV design guidelines, see Design and User Experience Guidelines.For more information on handling controller input, see Getting Started with Web Apps for Fire TV.Downloading the TemplateThe Fire TV web app template is available for download from GitHub at github.com/amzn/web-app-starter-kit-for-fire-tv.For information on installing and running the template, see the accompanying Readme. For information on the structure of the template and on the visual presentation, see the accompanying “Architecture” and “Styling” files. For Brightcove Video Cloud CustomersBrightcove Video Cloud customers can now start with the Brightcove Web App Kit solution, an easy way to get content from the Brightcove Video Cloud into a Fire TV app template.The Brightcove Fire TV Web App Kit is available for download from Github here. For more information on installing and customizing the template, see the supporting documentation in Github.",
        "url": "the-web-app-starter-kit-for-fire-tv.html",
        "product": "Fire TV"
      }
      ,
      
    
          
    
          
      "docs-sitemap-en-xml": {
        "title": "Sitemap_en",
        "tags": "[]",
        "content": "                    /about-the-cdf.html        2017-March-07        daily        0.5                    /catalog-data-format-ingestion-report-messages.html        2017-March-07        daily        0.5                    /catalog-data-format-schema-reference.html        2017-March-07        daily        0.5                    /fire-tv-catalog-integration-faqs.html        2017-March-07        daily        0.5                    /getting-started-catalog-integration.html        2017-March-07        daily        0.5                    /integrating-your-catalog-with-fire-tv.html        2017-March-07        daily        0.5                    /launcher-integration.html        2017-March-07        daily        0.5                    /migrating-a-cdf-file-to-the-latest-version.html        2017-March-07        daily        0.5                    /receiving-and-understanding-the-catalog-ingestion-report.html        2017-March-07        daily        0.5                    /setting-up-your-aws-account-for-fire-tv-catalog-integration.html        2017-March-07        daily        0.5                    /test-cases-for-verifying-deep-links-from-your-fire-tv-catalog.html        2017-March-07        daily        0.5                    /testing-launcher-integration-with-adb.html        2017-March-07        daily        0.5                    /testing-launcher-integration-with-the-test-app.html        2017-March-07        daily        0.5                    /understanding-fire-tv-catalog-integration.html        2017-March-07        daily        0.5                    /uploading-your-catalog.html        2017-March-07        daily        0.5                    /fire-app-builder-app-tour.html        2017-March-07        daily        0.5                    /fire-app-builder-connecting-adb-to-fire-tv.html        2017-March-07        daily        0.5                    /fire-app-builder-download-and-build.html        2017-March-07        daily        0.5                    /fire-app-builder-configure-navigator-open-feeds.html        2017-March-07        daily        0.5                    /fire-app-builder-configure-navigator-token-feeds.html        2017-March-07        daily        0.5                    /fire-app-builder-configure-navigator.html        2017-March-07        daily        0.5                    /fire-app-builder-load-media-feed.html        2017-March-07        daily        0.5                    /fire-app-builder-set-up-recipes-categories.html        2017-March-07        daily        0.5                    /fire-app-builder-set-up-recipes-content.html        2017-March-07        daily        0.5                    /fire-app-builder-set-up-recipes-overview.html        2017-March-07        daily        0.5                    /fire-app-builder-customize-look-and-feel.html        2017-March-07        daily        0.5                    /fire-app-builder-freewheel-ads-component.html        2017-March-07        daily        0.5                    /fire-app-builder-vast-ads-component.html        2017-March-07        daily        0.5                    /fire-app-builder-crashlytics-component.html        2017-March-07        daily        0.5                    /fire-app-builder-flurry-analytics-component.html        2017-March-07        daily        0.5                    /fire-app-builder-google-analytics-component.html        2017-March-07        daily        0.5                    /fire-app-builder-omniture-analytics-component.html        2017-March-07        daily        0.5                    /fire-app-builder-adobe-pass-auth-component.html        2017-March-07        daily        0.5                    /fire-app-builder-facebook-auth-component.html        2017-March-07        daily        0.5                    /fire-app-builder-login-with-amazon-component.html        2017-March-07        daily        0.5                    /fire-app-builder-amazon-media-player-component.html        2017-March-07        daily        0.5                    /fire-app-builder-brightcove-media-player-component.html        2017-March-07        daily        0.5                    /fire-app-builder-amazon-in-app-purchase-component.html        2017-March-07        daily        0.5                    /fire-app-builder-create-a-new-component.html        2017-March-07        daily        0.5                    /fire-app-builder-interfaces-and-components.html        2017-March-07        daily        0.5                    /fire-app-builder-load-a-component.html        2017-March-07        daily        0.5                    /fire-app-builder-end-to-end-process.html        2017-March-07        daily        0.5                    /fire-app-builder-overview.html        2017-March-07        daily        0.5                    /fire-app-builder-questions-and-answers.html        2017-March-07        daily        0.5                    /fire-app-builder-release-notes.html        2017-March-07        daily        0.5                    /fire-app-builder-catalog-integration.html        2017-March-07        daily        0.5                    /fire-app-builder-live-stream-configuration.html        2017-March-07        daily        0.5                    /fire-app-builder-pulling-updates-from-github.html        2017-March-07        daily        0.5                    /fire-app-builder-querying-json.html        2017-March-07        daily        0.5                    /fire-app-builder-querying-xml.html        2017-March-07        daily        0.5                    /fire-app-builder-troubleshooting.html        2017-March-07        daily        0.5                    /fire-app-builder-use-an-android-tv-emulator.html        2017-March-07        daily        0.5                    /amazon-fling-frequently-asked-questions.html        2017-March-07        daily        0.5                    /android-remote-install.html        2017-March-07        daily        0.5                    /designing-amazon-fling-ux.html        2017-March-07        daily        0.5                    /iap-entitlements-webapps.html        2017-March-07        daily        0.5                    /integrating-amazon-fling-into-your-android-app.html        2017-March-07        daily        0.5                    /integrating-amazon-fling-into-your-fire-tv-app.html        2017-March-07        daily        0.5                    /integrating-amazon-fling-into-your-ios-app.html        2017-March-07        daily        0.5                    /integrating-amazon-fling-with-an-existing-android-cast-app.html        2017-March-07        daily        0.5                    /integrating-amazon-fling-with-an-existing-ios-cast-app.html        2017-March-07        daily        0.5                    /integrating-amazon-fling-with-cast.html        2017-March-07        daily        0.5                    /ios-remote-install.html        2017-March-07        daily        0.5                    /remote-install.html        2017-March-07        daily        0.5                    /setting-up-your-amazon-fling-development-environment-for-android.html        2017-March-07        daily        0.5                    /setting-up-your-amazon-fling-development-environment-for-ios.html        2017-March-07        daily        0.5                    /understanding-the-amazon-fling-service.html        2017-March-07        daily        0.5                    /unity-controller-plugin.html        2017-March-07        daily        0.5                    /unity-player-plugin.html        2017-March-07        daily        0.5                    /using-amazon-fling-with-android-mediarouter.html        2017-March-07        daily        0.5                    /working-with-built-in-receiver-on-fire-tv.html        2017-March-07        daily        0.5                    /fire-tv-accessibility.html        2017-March-07        daily        0.5                    /fire-tv-assistive-technologies.html        2017-March-07        daily        0.5                    /fire-tv-preview-future-voiceview-accessibility-features.html        2017-March-07        daily        0.5                    /amazon-fire-game-controller-input.html        2017-March-07        daily        0.5                    /amazon-fire-tv-remote-input.html        2017-March-07        daily        0.5                    /controller-behavior-guidelines.html        2017-March-07        daily        0.5                    /controller-image-assets.html        2017-March-07        daily        0.5                    /controller-input-with-unity.html        2017-March-07        daily        0.5                    /gamecontroller-api.html        2017-March-07        daily        0.5                    /identifying-controllers.html        2017-March-07        daily        0.5                    /supporting-controllers-on-amazon-fire-tv.html        2017-March-07        daily        0.5                    /amazon-fire-tv-dolby-integration-guidelines.html        2017-March-07        daily        0.5                    /customizing-mouse-pointer.html        2017-March-07        daily        0.5                    /dial-integration.html        2017-March-07        daily        0.5                    /display-and-layout.html        2017-March-07        daily        0.5                    /fire-tv-4k-ultra-hd.html        2017-March-07        daily        0.5                    /fire-tv-advertising-id.html        2017-March-07        daily        0.5                    /fire-tv-handling-hdmi-events.html        2017-March-07        daily        0.5                    /fire-tv-international-locales.html        2017-March-07        daily        0.5                    /fire-tv-media-players.html        2017-March-07        daily        0.5                    /identifying-amazon-fire-tv-devices.html        2017-March-07        daily        0.5                    /implementing-search-fire-tv.html        2017-March-07        daily        0.5                    /managing-audio-focus.html        2017-March-07        daily        0.5                    /notifications-for-amazon-fire-tv.html        2017-March-07        daily        0.5                    /specifying-installation-location.html        2017-March-07        daily        0.5                    /user-agent-strings.html        2017-March-07        daily        0.5                    /user-interface.html        2017-March-07        daily        0.5                    /amazon-fire-tv-differences-from-android-tv-development.html        2017-March-07        daily        0.5                    /amazon-fire-tv-sdk-frequently-asked-questions.html        2017-March-07        daily        0.5                    /design-and-user-experience-guidelines.html        2017-March-07        daily        0.5                    /device-and-platform-specifications.html        2017-March-07        daily        0.5                    /fire-tv-development-framework-comparison.html        2017-March-07        daily        0.5                    /fire-tv-fire-os-overview.html        2017-March-07        daily        0.5                    /getting-started-developing-apps-and-games-for-amazon-fire-tv.html        2017-March-07        daily        0.5                    /submitting-your-fire-tv-app-to-the-amazon-appstore.html        2017-March-07        daily        0.5                    /whats-new-in-the-fire-tv-sdk.html        2017-March-07        daily        0.5                    /fire-tv-recommendations-best-practices.html        2017-March-07        daily        0.5                    /fire-tv-recommendations-overview.html        2017-March-07        daily        0.5                    /fire-tv-recommendations-send-recommendations.html        2017-March-07        daily        0.5                    /fire-tv-recommendations-testing.html        2017-March-07        daily        0.5                    /connecting-adb-to-fire-tv-device.html        2017-March-07        daily        0.5                    /installing-and-running-your-app.html        2017-March-07        daily        0.5                    /setting-up-your-development-environment.html        2017-March-07        daily        0.5                    /fire-tv-system-xray-customized-metrics.html        2017-March-07        daily        0.5                    /fire-tv-system-xray-developer-tools.html        2017-March-07        daily        0.5                    /fire-tv-system-xray.html        2017-March-07        daily        0.5                    /customizing-your-fire-tv-web-app.html        2017-March-07        daily        0.5                    /fire-tv-web-app-faq.html        2017-March-07        daily        0.5                    /getting-started-with-web-apps-for-fire-tv.html        2017-March-07        daily        0.5                    /migrating-your-web-app-to-fire-tv.html        2017-March-07        daily        0.5                    /supporting-controllers-in-web-apps.html        2017-March-07        daily        0.5                    /the-web-app-starter-kit-for-fire-tv.html        2017-March-07        daily        0.5                    /index.html        2017-March-07        daily        0.5                    /docs/sitemap_en.xml        2017-March-07        daily        0.5                            /search-fireappbuilder.html        2017-March-07        daily        0.5                    /search-firetv.html        2017-March-07        daily        0.5                    /search-fling.html        2017-March-07        daily        0.5                    /search.html        2017-March-07        daily        0.5        ",
        "url": "docssitemap_en.xml",
        "product": ""
      }
      
      
    
          
          
          
      "search-fireappbuilder-html": {
        "title": "Search - Fire App Builder",
        "tags": "[]",
        "content": "                                    ",
        "url": "search-fireappbuilder.html",
        "product": ""
      }
      ,
      
    
          
      "search-firetv-html": {
        "title": "Search - Fire TV",
        "tags": "[]",
        "content": "                                    ",
        "url": "search-firetv.html",
        "product": ""
      }
      ,
      
    
          
      "search-fling-html": {
        "title": "Search - Fling SDK",
        "tags": "[]",
        "content": "                                    ",
        "url": "search-fling.html",
        "product": "Fling SDK"
      }
      ,
      
    
          
    
  };
  console.log("window store:" + window.store + store)
</script>

<script src="assets/js/lunr.min.js"></script>
<script src="assets/js/search-global.js"></script>





            </div>
        </div><!--/.container-->


    </div><!--/.page-container-->
    
    <div class="footertop">
    <div class="container">
        <div class="col-md-6">
            <p></p>
        </div>
        <div class="col-md-6">
            <ul class="bottom_ul">
        </div>
    </div>
</div>

<footer>
    <div class="container">
        <div class="row">
            <div class="col-md-4 col-sm-6 footerleft ">
                <div class="logofooter"> About the Developer Portal</div>
                <p>The Amazon Developer Portal provides documentation for developers creating apps for the Amazon
                    appstore, including Alexa skills. Apps include streaming media apps, game apps, skills, and more. </p>

            </div>
            <div class="col-md-2 col-sm-6 paddingtop-bottom">
                <h6 class="heading7">Links</h6>
                <ul class="footer-ul">
                    <li><a class="noCrossRef" href="https://developer.amazon.com/"> Developer Portal</a></li>
                    <li><a class="noCrossRef" href="/index.html">Documentation Home</a></li>
                    <li class="noCrossRef"><a href="https://developer.amazon.com/support"> Support</a></li>
                    <li class="noCrossRef"><a href="https://aws.amazon.com/documentation/"> AWS docs</a></li>
                    <li class="noCrossRef"><a href="https://www.amazon.com/mobile-apps/b?ie=UTF8&node=2350149011"> Amazon Appstore</a></li>
                </ul>
            </div>

            <div class="col-md-3 col-sm-6 paddingtop-bottom">
                <h6 class="heading7">Amazon News</h6>
                <ul class="footer-ul">
                    <li class="noCrossRef"><a href="https://developer.amazon.com/blogs"> Blog</a></li>
                    <li class="noCrossRef"><a href="https://www.youtube.com/channel/UCT9ApARFgQJOeqD-ygmxnJQ"> YouTube</a></li>
                    <li class="noCrossRef"><a href="https://twitter.com/AmazonAppDev"> Twitter</a></li>
                    <li class="noCrossRef"><a href="http://phx.corporate-ir.net/phoenix.zhtml?p=irol-mediahome&c=176060"> Amazon Press Room</a></li>
                </ul>
            </div>

            <div class="col-md-3 col-sm-6 paddingtop-bottom">
                <h6 class="heading7">Forums</h6>
                <ul class="footer-ul">
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/23/index.html"> Alexa Skills Kit</a></li>
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/33/index.html"> Smart Home Skill API</a></li>
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/38/index.html"> Alexa Voice Service</a></li>
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/167/index.html"> Appstore</a></li>
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/12/index.html"> Underground</a></li>
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/166/index.html"> Fire Devices</a></li>
                    <li class="noCrossRef"><a href="https://forums.developer.amazon.com/spaces/61/index.html"> Dash</a></li>
                </ul>
            </div>
        </div>
    </div>
    </div>
</footer>
<!--subfooter start from here -->

<div class="copyright">
    <div class="container">
        <div class="col-md-12">
            <p>© 1996-2017, Amazon.com, Inc. or its affiliates</p>
        </div>
    </div>
</div>

    
    <!--scripts loaded here-->



</body>

</html>
